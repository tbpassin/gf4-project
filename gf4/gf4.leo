<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="tom.20211211170510.1"><vh>GF4 Files</vh>
<v t="tom.20220411232217.1"><vh>Administrative and License</vh>
<v t="tom.20220411133313.1"><vh>@clean Copyright_and_Authorship.txt</vh></v>
<v t="tom.20220411133954.1"><vh>@clean Software_License.txt</vh></v>
<v t="tom.20220411171338.1"><vh>@clean ABOUT.txt</vh></v>
</v>
<v t="tom.20211211170532.1"><vh>Program files</vh>
<v t="tom.20211207165011.1"><vh>Smoother and Tests</vh>
<v t="tom.20211211171913.12"><vh>@clean smoother.py</vh>
<v t="tom.20211211171913.13"><vh>Imports</vh></v>
<v t="tom.20211211171913.14"><vh>sqr</vh></v>
<v t="tom.20211211171913.15"><vh>cspline</vh></v>
<v t="tom.20211211171913.16"><vh>splineSmooth</vh></v>
<v t="tom.20211211171913.17"><vh>class WtStats</vh>
<v t="tom.20211211171913.18"><vh>WtStats.__init__</vh></v>
<v t="tom.20211211171913.19"><vh>WtStats.MakeGaussianWeights</vh></v>
<v t="tom.20211211171913.20"><vh>WtStats.omitOne</vh></v>
</v>
<v t="tom.20211211171913.21"><vh>correlationCoeff</vh></v>
<v t="tom.20211211171913.22"><vh>SmoothPointLowess</vh></v>
<v t="tom.20211211171913.23"><vh>lowess</vh></v>
<v t="tom.20211211171913.24"><vh>lowess1</vh></v>
<v t="tom.20211211171913.25"><vh>deriv</vh></v>
<v t="tom.20211211171913.26"><vh>lowess2</vh></v>
<v t="tom.20211211171913.27"><vh>lowessAdaptive</vh></v>
<v t="tom.20211211171913.28"><vh>leastsqr</vh></v>
<v t="tom.20211211171913.29"><vh>determinant</vh></v>
<v t="tom.20211211171913.30"><vh>SmoothPointLowessQuad</vh></v>
<v t="tom.20211211171913.31"><vh>ySmoothPointLowessQuad</vh></v>
<v t="tom.20211211171913.32"><vh>lowess2Quad</vh></v>
<v t="tom.20211211171913.33"><vh>xlowessAdaptiveAC</vh></v>
<v t="tom.20211211171913.34"><vh>lowessAdaptiveAC</vh></v>
<v t="tom.20211211171913.35"><vh>SmoothPointPoisson</vh></v>
<v t="tom.20211211171913.36"><vh>poissonSmooth</vh></v>
<v t="tom.20211211171913.37"><vh>thiel_sen</vh></v>
<v t="tom.20211211171913.38"><vh>moving_median</vh></v>
</v>
<v t="tom.20211206195731.2"><vh>@clean test_smooth.py</vh>
<v t="tom.20211206210622.1"><vh>Imports</vh></v>
<v t="tom.20211206200219.1"><vh>Declarations</vh></v>
<v t="tom.20211206195731.3"><vh>Main</vh></v>
</v>
<v t="tom.20211206205420.2"><vh>@clean testing/smoother_tests.py</vh>
<v t="tom.20211210160855.3"><vh>Organizer: Declarations (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.4"><vh>self_printer (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.5"><vh>cspline_fit (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.6"><vh>spline_smooth (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.7"><vh>lowess_smooth (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.8"><vh>lowess2_smooth (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.9"><vh>lowess1_autocorr (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.10"><vh>test_lowess_adaptive_ac (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.11"><vh>lstsqr (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.12"><vh>lowess2_mse (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.13"><vh>test_adaptive_lowess (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.14"><vh>lowess_smooth_quad (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.15"><vh>slope_var (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.16"><vh>test_thiel (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.17"><vh>test_lowess_devs (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.18"><vh>stdErrOfFit (smoother_tests.py)</vh></v>
<v t="tom.20211210160855.19"><vh>test_moving_median (smoother_tests.py)</vh></v>
</v>
</v>
<v t="tom.20211207165051.2"><vh>@clean gf4.pyw</vh>
<v t="tom.20211207165051.3"><vh>Imports</vh></v>
<v t="tom.20211207171026.1"><vh>Declarations</vh></v>
<v t="tom.20211207165051.4"><vh>class PlotManager(AbstractPlotManager)</vh>
<v t="tom.20211207211642.1"><vh>Decorators</vh>
<v t="tom.20211207165051.5"><vh>doErrorBands</vh></v>
<v t="tom.20211207165051.6"><vh>REQUIRE_MAIN</vh></v>
<v t="tom.20211207165051.7"><vh>REQUIRE_MAIN_BUFF</vh></v>
</v>
<v t="tom.20211207165051.8"><vh>__init__</vh></v>
<v t="tom.20211207165051.22"><vh>setMenus</vh></v>
<v t="tom.20211207165051.9"><vh>openAuxWin</vh></v>
<v t="tom.20211207211739.1"><vh>Widget Utilities</vh>
<v t="tom.20211207165051.10"><vh>open_editDialog</vh></v>
<v t="tom.20211207165051.11"><vh>setWindowTitle</vh></v>
<v t="tom.20211207165051.12"><vh>label_select_all</vh></v>
<v t="tom.20211207165051.13"><vh>setupFigure</vh></v>
<v t="tom.20211207165051.14"><vh>fadeit</vh></v>
<v t="tom.20211207165051.15"><vh>flashit</vh></v>
<v t="tom.20211207165051.16"><vh>announce</vh></v>
<v t="tom.20211207165051.17"><vh>set_editable_labels</vh></v>
<v t="tom.20211207165051.18"><vh>edit_label</vh>
<v t="tom.20220115225226.1"><vh>&lt;&lt; configure editwidget &gt;&gt;</vh></v>
</v>
<v t="tom.20211207165051.19"><vh>doneEditLabel</vh></v>
</v>
<v t="tom.20211207212159.1"><vh>Data Stack</vh>
<v t="tom.20211207165051.32"><vh>copyToBuffer</vh></v>
<v t="tom.20211207165051.33"><vh>swap_data</vh></v>
<v t="tom.20211207165051.34"><vh>paste_data</vh></v>
<v t="tom.20211207165051.35"><vh>drop_stack</vh></v>
<v t="tom.20211207165051.36"><vh>push_with_copy</vh></v>
<v t="tom.20211207165051.37"><vh>rotate_stack_up</vh></v>
<v t="tom.20211207165051.38"><vh>rotate_stack_down</vh></v>
<v t="tom.20211207165051.39"><vh>copy_to_top</vh></v>
<v t="tom.20211207165051.40"><vh>copy_from_top</vh></v>
<v t="tom.20211207165051.66"><vh>store1</vh></v>
<v t="tom.20211207165051.67"><vh>recall1</vh></v>
</v>
<v t="tom.20211207211946.1"><vh>Configure Graph</vh>
<v t="tom.20211207165051.24"><vh>set_axis_bg</vh></v>
<v t="tom.20211207165051.20"><vh>setYMin</vh></v>
<v t="tom.20211207165051.26"><vh>setSemilogX</vh></v>
<v t="tom.20211207165051.25"><vh>setSemilogY</vh></v>
<v t="tom.20211207165051.21"><vh>fix_ticks</vh></v>
<v t="tom.20211207165051.27"><vh>setLogLog</vh></v>
<v t="tom.20211207165051.28"><vh>setLinLin</vh></v>
<v t="tom.20211207165051.41"><vh>setPlotLineWidth</vh></v>
<v t="tom.20211207165051.42"><vh>setLineColor</vh></v>
<v t="tom.20211207165051.43"><vh>setLineColorMain</vh></v>
<v t="tom.20211207165051.44"><vh>setLineColorBuffer</vh></v>
<v t="tom.20211207165051.45"><vh>setSymColor</vh></v>
<v t="tom.20211207165051.46"><vh>setSymColorMain</vh></v>
<v t="tom.20211207165051.47"><vh>setSymColorBuffer</vh></v>
<v t="tom.20211207165051.48"><vh>setBgColor</vh></v>
<v t="tom.20211207165051.49"><vh>setMainLineWidth</vh></v>
<v t="tom.20211207165051.50"><vh>setBufferLineWidth</vh></v>
<v t="tom.20211207165051.51"><vh>setMarkerStyle</vh></v>
<v t="tom.20211207165051.52"><vh>setMainMarkerStyle</vh></v>
<v t="tom.20211207165051.53"><vh>setBufferMarkerStyle</vh></v>
<v t="tom.20211207165051.54"><vh>setSymShape</vh></v>
<v t="tom.20211207165051.55"><vh>setSymShapeMain</vh></v>
<v t="tom.20211207165051.56"><vh>setSymShapeBuffer</vh></v>
<v t="tom.20211207165051.57"><vh>setXlabel</vh></v>
<v t="tom.20211207165051.58"><vh>setYlabel</vh></v>
<v t="tom.20211207165051.59"><vh>setFigureTitle</vh></v>
</v>
<v t="tom.20211207212931.1"><vh>Data Load/Save</vh>
<v t="tom.20211207165051.60"><vh>set_data</vh></v>
<v t="tom.20211207165051.61"><vh>save_data</vh></v>
<v t="tom.20211207165051.62"><vh>load_data</vh></v>
<v t="tom.20211207165051.63"><vh>load_plot_data</vh></v>
<v t="tom.20211207165051.64"><vh>copy_data_to_clipboard</vh></v>
<v t="tom.20211207165051.65"><vh>load_data_from_popup</vh></v>
</v>
<v t="tom.20211207213410.1"><vh>Curve Operations</vh>
<v t="tom.20211207165051.68"><vh>setNumPoints</vh></v>
<v t="tom.20211207165051.69"><vh>replaceX</vh></v>
<v t="tom.20211207165051.70"><vh>dedup</vh></v>
<v t="tom.20211207165051.71"><vh>pad_truncate</vh></v>
<v t="tom.20211207165051.73"><vh>shift</vh></v>
<v t="tom.20211207165051.74"><vh>transpose</vh></v>
<v t="tom.20211207165051.75"><vh>sortX</vh></v>
</v>
<v t="tom.20211207213522.1"><vh>Curve Math</vh>
<v t="tom.20211207165051.76"><vh>scale</vh></v>
<v t="tom.20211207165051.77"><vh>add_constant</vh></v>
<v t="tom.20211207165051.78"><vh>differentiate</vh></v>
<v t="tom.20211207165051.79"><vh>differentiate2</vh></v>
<v t="tom.20211207165051.80"><vh>integrate</vh></v>
<v t="tom.20211207165051.81"><vh>absolute</vh></v>
<v t="tom.20211207165051.82"><vh>square</vh></v>
<v t="tom.20211207165051.83"><vh>rectify</vh></v>
<v t="tom.20211207165051.84"><vh>half_rectify</vh></v>
<v t="tom.20211207165051.85"><vh>clip</vh></v>
<v t="tom.20211207165051.86"><vh>decimate</vh></v>
<v t="tom.20211207165051.87"><vh>trim</vh></v>
<v t="tom.20211207165051.88"><vh>log</vh></v>
<v t="tom.20211207165051.89"><vh>log10</vh></v>
<v t="tom.20211207165051.122"><vh>normalize</vh></v>
<v t="tom.20211207165051.90"><vh>mulBuffer</vh></v>
<v t="tom.20211207165051.91"><vh>divBuffer</vh></v>
<v t="tom.20211207165051.92"><vh>addBuffer</vh></v>
<v t="tom.20211207165051.93"><vh>subFromBuffer</vh></v>
<v t="tom.20211207165051.113"><vh>make_phasespace</vh></v>
<v t="tom.20211207165051.114"><vh>YvsX</vh></v>
</v>
<v t="tom.20211207213812.1"><vh>Data Processing</vh>
<v t="tom.20211207165051.123"><vh>fft</vh></v>
<v t="tom.20211207165051.97"><vh>lopass</vh></v>
<v t="tom.20211207165051.98"><vh>hipass</vh></v>
<v t="tom.20211207165051.94"><vh>convolveWithBuffer</vh></v>
<v t="tom.20211207165051.95"><vh>correlateWithBuffer</vh></v>
<v t="tom.20211207165051.96"><vh>autocorrelate</vh></v>
<v t="tom.20211207165051.99"><vh>moving_median</vh></v>
</v>
<v t="tom.20211207213827.1"><vh>Fit</vh>
<v t="tom.20211207165051.100"><vh>cubicSpline</vh></v>
<v t="tom.20211207165051.72"><vh>fit_piecewise</vh></v>
<v t="tom.20211207165051.110"><vh>leastsqr</vh></v>
<v t="tom.20211207165051.111"><vh>leastsqr_quad</vh></v>
<v t="tom.20211207165051.112"><vh>thiel</vh></v>
</v>
<v t="tom.20220402083822.1"><vh>Plot Operations</vh>
<v t="tom.20211207165051.29"><vh>overplotbuff</vh></v>
<v t="tom.20211207165051.30"><vh>overplot_errorbands</vh></v>
<v t="tom.20211207165051.31"><vh>overplot</vh></v>
</v>
<v t="tom.20211207214009.1"><vh>Smoothing</vh>
<v t="tom.20211207165051.101"><vh>lowess</vh></v>
<v t="tom.20211207165051.102"><vh>lowess2Quad</vh></v>
<v t="tom.20211207165051.103"><vh>lowess_adaptive</vh></v>
<v t="tom.20211207165051.104"><vh>lowess_adaptive_ac</vh></v>
<v t="tom.20211207165051.105"><vh>correlationCoeff</vh></v>
<v t="tom.20211207165051.106"><vh>poissonSmooth</vh></v>
<v t="tom.20211207165051.115"><vh>spline_smooth</vh></v>
</v>
<v t="tom.20211207214046.1"><vh>Statistics</vh>
<v t="tom.20211207165051.107"><vh>spearman</vh></v>
<v t="tom.20211207165051.108"><vh>pearson</vh></v>
<v t="tom.20211207165051.116"><vh>cdf</vh></v>
<v t="tom.20211207165051.118"><vh>fitCdfWithNormal</vh></v>
<v t="tom.20211207165051.119"><vh>fitCdfNormalAdaptive</vh></v>
<v t="tom.20211207165051.120"><vh>histogram</vh></v>
<v t="tom.20211207165051.121"><vh>mean_std</vh></v>
</v>
<v t="tom.20211207214310.1"><vh>Trend</vh>
<v t="tom.20211207165051.117"><vh>trend_mann_kendall</vh></v>
</v>
<v t="tom.20211207214759.1"><vh>Windowing</vh>
<v t="tom.20211207165051.124"><vh>h_super_gaussian</vh></v>
<v t="tom.20211207165051.125"><vh>gaussian_window</vh></v>
<v t="tom.20211207165051.126"><vh>super_gaussian</vh></v>
<v t="tom.20211207165051.127"><vh>h_cosine</vh></v>
<v t="tom.20211207165051.128"><vh>full_cosine</vh></v>
</v>
<v t="tom.20220402084339.1"><vh>Misc</vh>
<v t="tom.20211207165051.109"><vh>sliding_var</vh></v>
<v t="tom.20211207165051.129"><vh>var_ratio</vh></v>
<v t="tom.20211207165051.130"><vh>y_vs_y</vh></v>
<v t="tom.20211207165051.131"><vh>addTimehack</vh></v>
<v t="tom.20211207165051.132"><vh>runMacro</vh></v>
<v t="tom.20211207165051.133"><vh>testMacro</vh></v>
<v t="tom.20211207165051.134"><vh>interpret</vh></v>
<v t="tom.20211207165051.135"><vh>hasToplevel</vh></v>
<v t="tom.20211207165051.23"><vh>test_announce</vh></v>
</v>
</v>
<v t="tom.20211207165051.136"><vh>__main__</vh></v>
</v>
<v t="tom.20211211170701.2"><vh>@clean AbstractPlotMgr.py</vh>
<v t="tom.20211211170701.3"><vh>Declarations</vh></v>
<v t="tom.20211211170701.4"><vh>class AbstractPlotManager</vh>
<v t="tom.20220402082631.1"><vh>Setup</vh>
<v t="tom.20211211170701.5"><vh>AbstractPlotManager.__init__</vh></v>
<v t="tom.20211211170701.6"><vh>AbstractPlotManager.quit</vh></v>
<v t="tom.20211211170701.7"><vh>AbstractPlotManager.setupFigure</vh></v>
<v t="tom.20211211170701.8"><vh>AbstractPlotManager.fix_ticks</vh></v>
<v t="tom.20211211170701.9"><vh>AbstractPlotManager.setXlabel</vh></v>
<v t="tom.20211211170701.10"><vh>AbstractPlotManager.setYlabel</vh></v>
<v t="tom.20211211170701.11"><vh>AbstractPlotManager.setFigureTitle</vh></v>
<v t="tom.20211211170701.12"><vh>AbstractPlotManager.setMenus</vh></v>
<v t="tom.20211211170701.13"><vh>AbstractPlotManager.setWindowTitle</vh></v>
</v>
<v t="tom.20220402082428.1"><vh>Plotting Methods</vh>
<v t="tom.20211211170701.14"><vh>AbstractPlotManager.plot</vh></v>
<v t="tom.20211211170701.15"><vh>AbstractPlotManager.overplot</vh></v>
<v t="tom.20211211170701.16"><vh>AbstractPlotManager.overplotbuff</vh></v>
<v t="tom.20211211170701.17"><vh>AbstractPlotManager.plotmain</vh></v>
<v t="tom.20211211170701.18"><vh>AbstractPlotManager.plot_stack_top</vh></v>
<v t="tom.20211211170701.19"><vh>AbstractPlotManager.overplot_stack_top</vh></v>
</v>
<v t="tom.20220402082507.1"><vh>Data and Stack Methods</vh>
<v t="tom.20211211170701.20"><vh>AbstractPlotManager.load_data</vh></v>
<v t="tom.20211211170701.21"><vh>AbstractPlotManager.load_plot_data</vh></v>
<v t="tom.20211211170701.22"><vh>AbstractPlotManager.set_data</vh></v>
<v t="tom.20211211170701.23"><vh>AbstractPlotManager.save_data</vh></v>
<v t="tom.20211211170701.24"><vh>AbstractPlotManager.swap_data</vh></v>
<v t="tom.20211211170701.25"><vh>AbstractPlotManager.push_data</vh></v>
<v t="tom.20211211170701.26"><vh>AbstractPlotManager.pop_data</vh></v>
<v t="tom.20211211170701.27"><vh>AbstractPlotManager.setNum</vh></v>
</v>
</v>
</v>
<v t="tom.20211211170819.2"><vh>@clean BuildCommands.py</vh>
<v t="tom.20211211170819.4"><vh>buildCommands</vh></v>
</v>
<v t="tom.20211211170819.6"><vh>@clean buttondefs.py</vh>
<v t="tom.20211211170819.7"><vh>Declarations (buttondefs.py)</vh></v>
</v>
<v t="tom.20211211170819.23"><vh>@clean colors.py</vh>
<v t="tom.20211211170819.24"><vh>Color Definitions</vh></v>
</v>
<v t="tom.20211211170819.26"><vh>@clean createMenus.py</vh>
<v t="tom.20211211170819.27"><vh>Imports</vh></v>
<v t="tom.20211211170819.28"><vh>setMenus</vh>
<v t="tom.20220401195652.1"><vh>Plot</vh>
<v t="tom.20220401201301.1"><vh>Marker Submenu</vh></v>
<v t="tom.20220401201342.1"><vh>Linestyles Submenu</vh></v>
<v t="tom.20220401201409.1"><vh>Symbol Submenu</vh></v>
<v t="tom.20220401201458.1"><vh>Color Submenu</vh></v>
</v>
<v t="tom.20220401195940.1"><vh>fileSubmenu</vh></v>
<v t="tom.20220401195954.1"><vh>stackSubmenu</vh></v>
<v t="tom.20220401200034.1"><vh>curveSubmenu</vh></v>
<v t="tom.20220401200047.1"><vh>waveformMathSubmenu</vh></v>
<v t="tom.20220401200120.1"><vh>dataProcessingSubmenu </vh></v>
<v t="tom.20220401200152.1"><vh>windowSubmenu </vh></v>
<v t="tom.20220401200202.1"><vh>smoothSubmenu</vh></v>
<v t="tom.20220401200248.1"><vh>generateSubmenu</vh></v>
<v t="tom.20220401200234.1"><vh>statsSubmenu</vh></v>
<v t="tom.20220411201602.1"><vh>helpSubmenu</vh></v>
<v t="tom.20220401200301.1"><vh>mainMenu.add_cascade</vh></v>
<v t="tom.20220401200321.1"><vh>Test Menu</vh></v>
</v>
</v>
<v t="tom.20211211170819.9"><vh>@clean cmdwin.py</vh>
<v t="tom.20211211223207.1"><vh>Imports</vh></v>
<v t="tom.20211211170819.10"><vh>Declarations</vh></v>
<v t="tom.20211211170819.11"><vh>click</vh></v>
<v t="tom.20211211170819.12"><vh>on_enter</vh></v>
<v t="tom.20211211170819.13"><vh>on_leave</vh></v>
<v t="tom.20211211170819.14"><vh>default_command</vh></v>
<v t="tom.20211211170819.15"><vh>play_macro</vh></v>
<v t="tom.20211211170819.16"><vh>clear_macro</vh></v>
<v t="tom.20211211170819.17"><vh>configure_button_list</vh></v>
<v t="tom.20211211170819.18"><vh>configure_horizontal_button_list</vh></v>
<v t="tom.20211211170819.19"><vh>configure_macro_buttons</vh></v>
<v t="tom.20211211170819.20"><vh>create_buttons_pack</vh>
<v t="tom.20220402001046.1"><vh>&lt;&lt; Make new Tk font &gt;&gt;</vh></v>
<v t="tom.20220402001212.1"><vh>&lt;&lt; Set window  geometry &gt;&gt;</vh></v>
<v t="tom.20220402001714.1"><vh>&lt;&lt; Create Button Containers &gt;&gt;</vh></v>
</v>
<v t="tom.20211211170819.21"><vh>cmdwindow</vh></v>
</v>
<v t="tom.20211211170820.45"><vh>@clean editDialog.py</vh>
<v t="tom.20211211170820.46"><vh>Imports</vh></v>
<v t="tom.20211211170820.47"><vh>class editDialog(Tk.Toplevel)</vh>
<v t="tom.20211211170820.48"><vh>editDialog.__init__</vh></v>
<v t="tom.20211211170820.49"><vh>editDialog.accept</vh></v>
<v t="tom.20211211170820.50"><vh>editDialog.cancel</vh></v>
</v>
<v t="tom.20211211170820.51"><vh>if __name__ == '__main__':</vh></v>
</v>
<v t="tom.20211211170819.30"><vh>@clean curve_generators.py</vh>
<v t="tom.20211211170819.31"><vh>Imports</vh></v>
<v t="tom.20211211170819.32"><vh>generateSine</vh></v>
<v t="tom.20211211170819.33"><vh>generateSquarewave</vh></v>
<v t="tom.20211211170819.34"><vh>generateDampedSine</vh></v>
<v t="tom.20211211170819.35"><vh>generateExponential</vh></v>
<v t="tom.20211211170819.36"><vh>generateRectangle</vh></v>
<v t="tom.20211211170819.38"><vh>generateGaussian</vh></v>
<v t="tom.20211211170819.39"><vh>generateGaussianCdf</vh></v>
<v t="tom.20211211170819.37"><vh>generateRamp</vh></v>
</v>
<v t="tom.20211211170820.2"><vh>@clean Dataset.py</vh>
<v t="tom.20211211170820.3"><vh>Imports</vh></v>
<v t="tom.20211211170820.4"><vh>class Dataset</vh>
<v t="tom.20211211170820.6"><vh>Dataset.__init__</vh></v>
<v t="tom.20211211170820.5"><vh>Dataset.__len__</vh></v>
<v t="tom.20211211170820.7"><vh>Dataset.copy</vh></v>
<v t="tom.20211211170820.8"><vh>Dataset.clearErrorBands</vh></v>
<v t="tom.20211211170820.9"><vh>Dataset.normalize</vh></v>
<v t="tom.20211211170820.10"><vh>Dataset.setAsciiData</vh>
<v t="tom.20220401205037.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="tom.20220401205124.1"><vh>&lt;&lt; init  &gt;&gt;</vh></v>
<v t="tom.20220401205417.1"><vh>&lt;&lt; process lines &gt;&gt;</vh>
<v t="tom.20220401205645.1"><vh>&lt;&lt; handle special comments &gt;&gt;</vh></v>
<v t="tom.20220401205749.1"><vh>&lt;&lt; get numeric data &gt;&gt;</vh></v>
</v>
</v>
<v t="tom.20211211170820.11"><vh>Dataset.dedup</vh></v>
<v t="tom.20211211170820.12"><vh>Dataset.data2String</vh></v>
<v t="tom.20211211170820.13"><vh>Dataset.writeAsciiData</vh></v>
<v t="tom.20211211170820.14"><vh>Dataset.isNumpyArray</vh></v>
<v t="tom.20211211170820.15"><vh>Dataset.pad_truncate</vh></v>
<v t="tom.20211211170820.16"><vh>Dataset.shift</vh></v>
<v t="tom.20211211170820.17"><vh>Dataset.transpose</vh></v>
<v t="tom.20211211170820.18"><vh>Dataset.sortX</vh></v>
<v t="tom.20211211170820.19"><vh>Dataset.scale</vh></v>
<v t="tom.20211211170820.20"><vh>Dataset.addConstant</vh></v>
<v t="tom.20211211170820.21"><vh>Dataset.differentiate2</vh></v>
<v t="tom.20211211170820.22"><vh>Dataset.differentiate</vh></v>
<v t="tom.20211211170820.23"><vh>Dataset.integrate</vh></v>
<v t="tom.20211211170820.24"><vh>Dataset.square</vh></v>
<v t="tom.20211211170820.25"><vh>Dataset.absolute</vh></v>
<v t="tom.20211211170820.26"><vh>Dataset.log</vh></v>
<v t="tom.20211211170820.27"><vh>Dataset.log10</vh></v>
<v t="tom.20211211170820.28"><vh>Dataset.multiply</vh></v>
<v t="tom.20211211170820.29"><vh>Dataset.divide</vh></v>
<v t="tom.20211211170820.30"><vh>Dataset.rfft</vh></v>
<v t="tom.20211211170820.31"><vh>Dataset.halfSupergaussian</vh></v>
<v t="tom.20211211170820.32"><vh>Dataset.fullSuperGaussian</vh></v>
<v t="tom.20211211170820.33"><vh>Dataset.halfCosine</vh></v>
<v t="tom.20211211170820.34"><vh>Dataset.fullCosine</vh></v>
<v t="tom.20211211170820.35"><vh>Dataset.convolve</vh></v>
<v t="tom.20211211170820.36"><vh>Dataset.correlate</vh></v>
<v t="tom.20211211170820.37"><vh>Dataset.lopass</vh></v>
<v t="tom.20211211170820.38"><vh>Dataset.hipass</vh></v>
<v t="tom.20211211170820.39"><vh>Dataset.var_ratio</vh></v>
<v t="tom.20211211170820.40"><vh>Dataset.var_ratio2</vh></v>
<v t="tom.20211211170820.41"><vh>Dataset.sliding_var</vh></v>
<v t="tom.20211211170820.42"><vh>Dataset.thin</vh></v>
</v>
<v t="tom.20211211170820.43"><vh>Organizer: if __name__ == '__main__': (Dataset.py)</vh></v>
</v>
<v t="tom.20211211171304.2"><vh>@clean entry.py</vh>
<v t="tom.20211211171304.3"><vh>Imports</vh></v>
<v t="tom.20211211171304.4"><vh>class Dialog(Tk.Toplevel)</vh>
<v t="tom.20211211171304.5"><vh>Dialog.__init__</vh></v>
<v t="tom.20211211171304.6"><vh>Dialog.body</vh></v>
<v t="tom.20211211171304.7"><vh>Dialog.buttonbox</vh></v>
<v t="tom.20211211171304.8"><vh>Dialog.ok</vh></v>
<v t="tom.20211211171304.9"><vh>Dialog.cancel</vh></v>
<v t="tom.20211211171304.10"><vh>Dialog.validate</vh></v>
<v t="tom.20211211171304.11"><vh>Dialog.apply</vh></v>
<v t="tom.20211211171304.12"><vh>Dialog.fade</vh></v>
</v>
<v t="tom.20211211171304.13"><vh>class TwoLineInput(Dialog)</vh>
<v t="tom.20211211171304.14"><vh>TwoLineInput.__init__</vh></v>
<v t="tom.20211211171304.15"><vh>TwoLineInput.body</vh></v>
<v t="tom.20211211171304.16"><vh>TwoLineInput.validate</vh></v>
<v t="tom.20211211171304.17"><vh>TwoLineInput.apply</vh></v>
</v>
<v t="tom.20211211171304.18"><vh>class GetSingleInt(Dialog)</vh>
<v t="tom.20211211171304.19"><vh>GetSingleInt(Dialog).__init__</vh></v>
<v t="tom.20211211171304.20"><vh>GetSingleInt(Dialog).body</vh></v>
<v t="tom.20211211171304.21"><vh>GetSingleInt(Dialog).validate</vh></v>
</v>
<v t="tom.20211211171304.22"><vh>class GetSingleFloat(GetSingleInt)</vh>
<v t="tom.20211211171304.23"><vh>GetSingleFloat(GetSingleInt).__init__</vh></v>
<v t="tom.20211211171304.24"><vh>GetSingleFloat(GetSingleInt).validate</vh></v>
</v>
<v t="tom.20211211171304.25"><vh>class GetTwoFloats(TwoLineInput)</vh>
<v t="tom.20211211171304.26"><vh>GetTwoFloats(TwoLineInput).__init__</vh></v>
<v t="tom.20211211171304.27"><vh>GetTwoFloats(TwoLineInput).body</vh></v>
<v t="tom.20211211171304.28"><vh>GetTwoFloats(TwoLineInput).validate</vh></v>
</v>
<v t="tom.20211211171304.29"><vh>class GetTwoInts(TwoLineInput)</vh>
<v t="tom.20211211171304.30"><vh>GetTwoInts(TwoLineInput).__init__</vh></v>
<v t="tom.20211211171304.31"><vh>GetTwoInts(TwoLineInput).body</vh></v>
<v t="tom.20211211171304.32"><vh>GetTwoInts(TwoLineInput).validate</vh></v>
</v>
<v t="tom.20211211171304.33"><vh>class GetTwoNumbers(TwoLineInput)</vh>
<v t="tom.20211211171304.34"><vh>GetTwoNumbers(TwoLineInput).__init__</vh></v>
<v t="tom.20211211171304.35"><vh>GetTwoNumbers(TwoLineInput).body</vh></v>
<v t="tom.20211211171304.36"><vh>GetTwoNumbers(TwoLineInput).validate</vh></v>
</v>
<v t="tom.20211211171304.37"><vh>class TextFade(Tk.Text)</vh>
<v t="tom.20211211171304.38"><vh>TextFade(Tk.Text).incr_in_range</vh></v>
<v t="tom.20211211171304.39"><vh>TextFade(Tk.Text).colr_str</vh></v>
<v t="tom.20211211171304.40"><vh>TextFade(Tk.Text).fade</vh></v>
<v t="tom.20211211171304.41"><vh>TextFade(Tk.Text).flash</vh></v>
</v>
<v t="tom.20211211171304.42"><vh>if __name__ == '__main__'</vh>
<v t="tom.20220402080844.1"><vh>&lt;&lt; test defs &gt;&gt;</vh></v>
</v>
</v>
<v t="tom.20211211171304.44"><vh>@clean fail.py</vh>
<v t="tom.20211211171304.45"><vh>Imports</vh></v>
<v t="tom.20211211171304.46"><vh>class PlotManager</vh>
<v t="tom.20211211171304.47"><vh>PlotManager.__init__</vh></v>
<v t="tom.20211211171304.48"><vh>PlotManager.setupFigure</vh></v>
</v>
<v t="tom.20211211171304.49"><vh>if __name__ == '__main__': (fail.py)</vh></v>
</v>
<v t="tom.20211211181438.12"><vh>@clean fits.py</vh>
<v t="tom.20211211181438.13"><vh>Imports</vh></v>
<v t="tom.20211211181438.14"><vh>piecewiseLinear (fits.py)</vh></v>
</v>
<v t="tom.20211211181438.2"><vh>@clean fit_test.py</vh>
<v t="tom.20211211181438.3"><vh>Organizer: Declarations (fit_test.py)</vh></v>
<v t="tom.20211211181438.4"><vh>null_rss (fit_test.py)</vh></v>
<v t="tom.20211211181438.5"><vh>null_T (fit_test.py)</vh></v>
<v t="tom.20211211181438.6"><vh>permuted_T (fit_test.py)</vh></v>
<v t="tom.20211211181438.7"><vh>permuted_lstsqr (fit_test.py)</vh></v>
<v t="tom.20211211181438.8"><vh>pnull (fit_test.py)</vh></v>
<v t="tom.20211211181438.9"><vh>dist (fit_test.py)</vh></v>
<v t="tom.20211211181438.10"><vh>readfile (fit_test.py)</vh></v>
</v>
<v t="tom.20220411202149.1"><vh>@clean help.py</vh>
<v t="tom.20220411210428.1"><vh>imports</vh></v>
<v t="tom.20220411202245.1"><vh>tutorial</vh></v>
<v t="tom.20220411210306.1"><vh>msg_window</vh></v>
<v t="tom.20220411201434.1"><vh>about</vh>
<v t="tom.20220412003223.1"><vh>About and Data Format</vh></v>
<v t="tom.20220412003352.1"><vh>The Waveform Stack</vh></v>
<v t="tom.20220412003444.1"><vh>Data Input</vh></v>
<v t="tom.20220412003456.1"><vh>Data Output</vh></v>
<v t="tom.20220412003510.1"><vh>Plotting Data</vh></v>
</v>
</v>
<v t="tom.20211211171304.51"><vh>@clean Linestyle.py</vh>
<v t="tom.20211211171304.52"><vh>Organizer: Declarations (Linestyle.py)</vh></v>
<v t="tom.20211211171304.53"><vh>class Linestyle</vh>
<v t="tom.20211211171304.54"><vh>Linestyle.__init__</vh></v>
<v t="tom.20211211171304.55"><vh>Linestyle.set_linewidth</vh></v>
<v t="tom.20211211171304.56"><vh>Linestyle.set_sym_style</vh></v>
<v t="tom.20211211171304.57"><vh>Linestyle.set_sym_color</vh></v>
<v t="tom.20211211171304.58"><vh>Linestyle.set_linecolor</vh></v>
<v t="tom.20211211171304.59"><vh>Linestyle.get_vals</vh></v>
</v>
</v>
<v t="tom.20211211171304.61"><vh>@clean logger.py</vh>
<v t="tom.20211211171304.62"><vh>Organizer: Declarations (logger.py)</vh></v>
<v t="tom.20211211171304.63"><vh>logit (logger.py)</vh></v>
</v>
<v t="tom.20211211171304.65"><vh>@clean MakeWaveforms.py</vh>
<v t="tom.20211211171304.66"><vh>Imports</vh></v>
<v t="tom.20211211171304.67"><vh>makeExponential</vh></v>
<v t="tom.20211211171304.68"><vh>makeSine</vh></v>
<v t="tom.20211211171304.69"><vh>makeDampedSine</vh></v>
<v t="tom.20211211171304.70"><vh>makeStep</vh></v>
<v t="tom.20211211171304.71"><vh>makeDelta</vh></v>
<v t="tom.20211211171304.72"><vh>makeRamp</vh></v>
<v t="tom.20211211171304.73"><vh>makeSquarewave</vh></v>
<v t="tom.20211211171304.74"><vh>makeRandomNoise</vh></v>
<v t="tom.20211211171304.75"><vh>makeUniformNoise</vh></v>
<v t="tom.20211211171304.76"><vh>makeGaussianNoise</vh></v>
<v t="tom.20211211171304.77"><vh>pdfGaussian</vh></v>
<v t="tom.20211211171304.78"><vh>cdfGaussian</vh></v>
</v>
<v t="tom.20211211171913.2"><vh>@clean Plot.py</vh>
<v t="tom.20211211171913.3"><vh>Imports</vh></v>
<v t="tom.20211211171913.4"><vh>plot (Plot.py)</vh>
<v t="tom.20220115175642.1"><vh>&lt;&lt; get axes &gt;&gt;</vh></v>
<v t="tom.20220115175032.1"><vh>&lt;&lt; bail if no data &gt;&gt;</vh></v>
<v t="tom.20220115175205.1"><vh>&lt;&lt; setup labels &gt;&gt;</vh></v>
<v t="tom.20220401210413.1"><vh>&lt;&lt; set axes appearance &gt;&gt;</vh></v>
<v t="tom.20220115175458.1"><vh>&lt;&lt; set linestyles &gt;&gt;</vh></v>
<v t="tom.20220115175337.1"><vh>&lt;&lt; set log or linear &gt;&gt;</vh></v>
<v t="tom.20220115175943.1"><vh>&lt;&lt; set max-min &gt;&gt;</vh></v>
</v>
</v>
<v t="tom.20211211171913.6"><vh>@clean randnum.py</vh>
<v t="tom.20211211171913.7"><vh>Imports</vh></v>
<v t="tom.20211211171913.8"><vh>rand_vals</vh></v>
<v t="tom.20211211171913.9"><vh>uniform_vals</vh></v>
<v t="tom.20211211171913.10"><vh>gaussian_vals</vh></v>
</v>
<v t="tom.20211211171913.12"></v>
<v t="tom.20211211171913.40"><vh>@clean stats.py</vh>
<v t="tom.20211211171913.41"><vh>Imports</vh></v>
<v t="tom.20211211171913.42"><vh>cdf</vh></v>
<v t="tom.20211211171913.43"><vh>histogram</vh></v>
<v t="tom.20211211171913.44"><vh>meanstd</vh></v>
<v t="tom.20211211171913.45"><vh>fitNormalToCdf</vh></v>
<v t="tom.20211211171913.46"><vh>calcNormalForCdf</vh></v>
<v t="tom.20211211171913.47"><vh>fitNormalToCdfAdaptive</vh></v>
<v t="tom.20211211171913.48"><vh>spearman</vh></v>
<v t="tom.20211211171913.49"><vh>pearson</vh></v>
<v t="tom.20211212001620.1"><vh>__main__</vh></v>
</v>
<v t="tom.20211211171913.51"><vh>@clean Timehack.py</vh>
<v t="tom.20211211171913.52"><vh>Imports</vh></v>
<v t="tom.20211211171913.53"><vh>timehack (Timehack.py)</vh></v>
</v>
<v t="tom.20211211171913.55"><vh>@clean trend.py</vh>
<v t="tom.20211211171913.56"><vh>Imports and Declarations</vh></v>
<v t="tom.20211211171913.57"><vh>mann_kendall (trend.py)</vh>
<v t="tom.20220402002421.1"><vh>&lt;&lt;docstring &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="tom.20220412075521.1"><vh>Docs</vh>
<v t="tom.20220412082324.1"><vh>@path doc</vh>
<v t="tom.20220412080203.1"><vh>@button Build HTML</vh></v>
<v t="tom.20220412080628.1"><vh>@rst GF4_Users_Guide</vh>
<v t="tom.20220412080711.1"><vh>What Is GF4?</vh>
<v t="tom.20220412191239.1"><vh>Typical Screen Shot</vh></v>
<v t="tom.20220412183611.1"><vh>A Historical Note</vh></v>
<v t="tom.20220412095053.1"><vh>Some Typical Uses</vh></v>
<v t="tom.20220412214305.1"><vh>What GF4 Is Not</vh></v>
</v>
<v t="tom.20220412085319.1"><vh>Quick Start</vh>
<v t="tom.20220412231039.1"><vh>The "Noisy Ramp" Example</vh>
<v t="tom.20220412233838.1"><vh>Create And Plot The Noisy Line</vh></v>
<v t="tom.20220412234039.1"><vh>Fit and Plot The Noisy Line</vh></v>
</v>
<v t="tom.20220413002412.1"><vh>Encouraging Remarks</vh></v>
</v>
<v t="tom.20220412085326.1"><vh>Data Format</vh></v>
<v t="tom.20220412085521.1"><vh>The Waveform Stack</vh></v>
<v t="tom.20220412085726.1"><vh>Plotting Curves</vh>
<v t="tom.20220412091943.1"><vh>Changing Colors, Symbols, and Line Styles</vh></v>
</v>
<v t="tom.20220412085648.1"><vh>Using the Waveform Stack</vh></v>
<v t="tom.20220412085541.1"><vh>Reading And Saving Data</vh></v>
<v t="tom.20220412085559.1"><vh>Operations On One Waveform</vh></v>
<v t="tom.20220412085615.1"><vh>Operations On Two Waveforms</vh></v>
<v t="tom.20220412085756.1"><vh>The Waveform Generators</vh></v>
<v t="tom.20220412091831.1"><vh>Curve Fitting</vh></v>
<v t="tom.20220412091839.1"><vh>Curve Smoothing</vh></v>
<v t="tom.20220412091853.1"><vh>Windowing and FFTs</vh></v>
<v t="tom.20220412171300.1"><vh>Using Macros</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="tom.20211206195731.2">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211206195731.3">@language python

if __name__ == '__main__':

    INTERNAL_DATA = False
    if len(sys.argv) == 1: 
        INTERNAL_DATA = True
        #print('No file on command line')
        #sys.exit(0)

    if not INTERNAL_DATA:
        basename = 'dat.txt'   
        if len(sys.argv) &gt; 2:
            ofilenames  = [sys.argv[2] + '_%s.txt' % (s) for s in SRANGE]
        else:
            ofilenames  = (basename + '_%s.txt' % (s) for s in SRANGE)

        fname = sys.argv[1]
        with open(fname) as f:
            lines = f.readlines()
        if not lines: sys.exit(0)
    else:
        lines = DATA

    x = []
    y = []
    for line in lines:
        line = line.strip()
        if not line: continue
        if line[0] == ';': continue
        splits = line.split()
        try:
            x.append(float(splits[0]))
            y.append(float(splits[1]))
        except Exception as e:
            print(e)
            continue

    if INTERNAL_DATA:
        output = f';; FIGURELABEL: LOWESS Test, Span = {SPAN}\n'
        xi, yi = smoother.lowess(x,y,SPAN)
        output += '\n'.join(['%s  %s' % (xi[n], yi[n]) for n in range(len(xi))])
        pyperclip.copy(output)
    else:
        for i, _ in enumerate(SRANGE):
            s = SRANGE[i]
            xi, yi = smoother.lowess(x,y,s)
            result = ['%s  %s\n' % (xi[n], yi[n]) for n in range(len(xi))]

            oname = ofilenames[i]
            header = ';;FIGURELABEL: %s\n' % oname
            with open(oname, 'w') as of:
                of.write(header)
                of.write(''.join(result)) 
</t>
<t tx="tom.20211206200219.1">@language python
DATA = [f'{i}   0' for i in range(10)]
DATA.extend([f'{i}   1' for i in range(10, 100)])

SPAN = 10
SRANGE = (5,10,15,20,30)
</t>
<t tx="tom.20211206205420.2">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211206210622.1">@language python
import sys
import pyperclip
try:
    import smoother
except ImportError:
    path = r'C:/Tom/devel/matplotlib/gf4'
    sys.path.append(path)
</t>
<t tx="tom.20211207165011.1"></t>
<t tx="tom.20211207165051.10">def open_editDialog(self):
    editDialog()

</t>
<t tx="tom.20211207165051.100">@REQUIRE_MAIN
def cubicSpline(self):
    _ds = self.stack[MAIN]
    _x = _ds.xdata
    _y = _ds.ydata
    _ds.xdata, _ds.ydata = smoother.cspline(_x, _y)
    self.plot()
</t>
<t tx="tom.20211207165051.101">@REQUIRE_MAIN
def lowess(self):
    _ds = self.stack[MAIN]
    if _ds.isNumpyArray(_ds.xdata):
        _x = _ds.xdata.tolist()
    else:
        _x = _ds.xdata
    if _ds.isNumpyArray(_ds.ydata):
        _y = _ds.ydata.tolist()
    else:
        _y = _ds.ydata

    _id = 'lowess'
    lastparm = self.parmsaver.get(_id, 6)

    dia = GetSingleInt(self.root, 'Smoothing Width', 'Enter Integer',
                       lastparm)
    if dia.result is None: return

    self.parmsaver[_id] = dia.result
    self.stack[MAIN].parms['smoothwidth'] = '%s' % (dia.result)

    x, newy, rms, upperlimit, lowerlimit = smoother.lowess2(_x, _y,
                                                            dia.result)
    _ds.ydata = newy

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'LOWESS Smooth of %s' % (lab)
    else:
        lab = 'LOWESS Smooth'
    self.stack[MAIN].figurelabel = lab

    lower = Dataset()
    lower.ydata = lowerlimit
    lower.xdata = _x  # not a copy

    upper = Dataset()
    upper.ydata = upperlimit
    upper.xdata = _x  # not a copy

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    # correlation coefficient
    r = smoother.correlationCoeff(_y, newy)

    self.plot()

    n = float(len(_x))
    msg = f'RMS deviation = {rms:.3f}, r = {r:.3f}'
    self.announce(msg)
</t>
<t tx="tom.20211207165051.102">@REQUIRE_MAIN
def lowess2Quad(self):
    _ds = self.stack[MAIN]
    if _ds.isNumpyArray(_ds.xdata):
        _x = _ds.xdata.tolist()
    else:
        _x = _ds.xdata
    if _ds.isNumpyArray(_ds.ydata):
        _y = _ds.ydata.tolist()
    else:
        _y = _ds.ydata

    _id = 'lowess2Quad'
    lastparm = self.parmsaver.get(_id, 6)

    dia = GetSingleInt(self.root, 'Smoothing Width', 'Enter Integer',
                       lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    x, newy, rms, upperlimit, lowerlimit = smoother.lowess2Quad(_x, _y,
                                                                dia.result)
    _ds.ydata = newy

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'LOWESS Quadratic Smooth of %s' % (lab)
    else:
        lab = 'LOWESS Quadratic Smooth'
    self.stack[MAIN].figurelabel = lab

    lower = Dataset()
    lower.ydata = lowerlimit
    lower.xdata = _x

    upper = Dataset()
    upper.ydata = upperlimit
    upper.xdata = _x

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    # correlation coefficient
    r = smoother.correlationCoeff(_y, newy)

    self.plot()

    self.announce('RMS Deviation: %0.3f, r=%0.3f' % (rms, r))
</t>
<t tx="tom.20211207165051.103">@REQUIRE_MAIN
def lowess_adaptive(self):
    _ds = self.stack[MAIN]
    if _ds.isNumpyArray(_ds.xdata):
        _x = _ds.xdata.tolist()
    else:
        _x = _ds.xdata
    if _ds.isNumpyArray(_ds.ydata):
        _y = _ds.ydata.tolist()
    else:
        _y = _ds.ydata

    _id = 'lowess_adaptive'
    lastparm = self.parmsaver.get(_id, 1.0)

    dia = GetSingleFloat(self.root, 'Smoothness Weight',
                         'Enter Number', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    x, newy, span, rms, upperlimit, lowerlimit = \
        smoother.lowessAdaptive(_x, _y, dia.result)
    _ds.ydata = newy

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'Adaptive LOWESS Smooth of %s' % (lab)
    else:
        lab = 'Adaptive LOWESS Smooth'
    self.stack[MAIN].figurelabel = lab

    lower = Dataset()
    lower.ydata = lowerlimit
    lower.xdata = _x

    upper = Dataset()
    upper.ydata = upperlimit
    upper.xdata = _x

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    # correlation coefficient
    r = smoother.correlationCoeff(_y, newy)

    self.plot()
    msg = f'Span: {span}, RMS deviation = {rms:.3f}, r = {r:.3f}'
    self.announce(msg)
</t>
<t tx="tom.20211207165051.104">@REQUIRE_MAIN
def lowess_adaptive_ac(self):
    _ds = self.stack[MAIN]
    if _ds.isNumpyArray(_ds.xdata):
        _x = _ds.xdata.tolist()
    else:
        _x = _ds.xdata
    if _ds.isNumpyArray(_ds.ydata):
        _y = _ds.ydata.tolist()
    else:
        _y = _ds.ydata

    x, newy, span, rms, ac, upperlimit, lowerlimit = \
        smoother.lowessAdaptiveAC(_x, _y)
    _ds.ydata = newy

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'Adaptive LOWESS Autocorrelation Smooth of %s' % (lab)
    else:
        lab = 'Adaptive LOWESS Autocorrelation Smooth'
    self.stack[MAIN].figurelabel = lab

    lower = Dataset()
    lower.ydata = lowerlimit
    lower.xdata = _x

    upper = Dataset()
    upper.ydata = upperlimit
    upper.xdata = _x

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    # correlation coefficient
    r = smoother.correlationCoeff(_y, newy)

    self.plot()
    self.announce('Span: %s; ac = %0.3f; RMS deviation = %0.3f, '
                  'r=%0.3f' % (span, ac, rms, r))
</t>
<t tx="tom.20211207165051.105">@REQUIRE_MAIN
def correlationCoeff(self):
    '''Calculate correlation coefficient between MAIN and BUFFER,
    and display the result.  MAIN should be fitted to data in BUFFER,
    e.g., by least squares.   Both sequences must have the same length.
    '''

    fitted = self.stack[MAIN].ydata
    data = self.stack[BUFFER].ydata

    if len(fitted) != len(data):
        self.announce('Both curves must have same number of points: '
                      'fitted: %s, data: %s'
                      % (len(fitted), len(data)))
        self.flashit()
        return

    r = smoother.correlationCoeff(data, fitted)
    if r == -1:
        self.announce('Too much variation in BUFFER, or '
                      'no variation in MAIN')
        self.flashit()
    else:
        self.announce('r=%0.3f' % r)
</t>
<t tx="tom.20211207165051.106">@REQUIRE_MAIN
def poissonSmooth(self):
    _ds = self.stack[MAIN]
    if _ds.isNumpyArray(_ds.xdata):
        _x = _ds.xdata.tolist()
    else:
        _x = _ds.xdata
    if _ds.isNumpyArray(_ds.ydata):
        _y = _ds.ydata.tolist()
    else:
        _y = _ds.ydata

    _id = 'poissonSmooth'
    lastparm = self.parmsaver.get(_id, 6)

    dia = GetSingleInt(self.root, 'Smoothing Width', 'Enter Integer',
                       lastparm)
    if dia.result is None: return

    self.parmsaver[_id] = dia.result
    self.stack[MAIN].parms['smoothwidth'] = '%s' % (dia.result)

    try:
        x, newy, rms = smoother.poissonSmooth(_x, _y, dia.result)
    except ValueError as e:
        self.announce(e)
        self.flashit()
        return

    _ds.ydata = newy
    _ds.xdata = x  # may have been sorted, so use the return values

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'Poisson Smooth of %s' % (lab)
    else:
        lab = 'Poisson Smooth'
    self.stack[MAIN].figurelabel = lab

    # correlation coefficient
    r = smoother.correlationCoeff(_y, newy)

    self.plot()

    self.announce('RMS Deviation: %0.3f, r=%0.3f' % (rms, r))
</t>
<t tx="tom.20211207165051.107">@REQUIRE_MAIN
def spearman(self):
    '''Calculate the Spearman rank correlation coefficient of
    data sequences in MAIN and BUFFER.  The data remains unchanged.'''

    _y = self.stack[MAIN].ydata
    _x = self.stack[BUFFER].ydata

    if _x == _y:
        self.announce("Both data sets are the same")
        self.flashit()
        return

    if len(_x) != len(_y):
        self.announce('Both curves must have same number of points: '
                      'fitted: %s, data: %s'
                      % (len(_x), len(_y)))
        self.flashit()
        return

    r, p = spearmanr(_y, _x)

    self.announce('Spearman Rank Correlation Coefficient='
                  '%0.3f, p = %0.3f'
                  % (r, p))

</t>
<t tx="tom.20211207165051.108">@REQUIRE_MAIN
def pearson(self):
    '''Calculate the Spearman rank correlation coefficient of
    data sequences in MAIN and BUFFER.  The data remains unchanged.'''

    _y = self.stack[MAIN].ydata
    _x = self.stack[BUFFER].ydata

    if len(_x) != len(_y):
        self.announce('Both curves must have same number of points: '
                      'fitted: %s, data: %s'
                      % (len(_x), len(_y)))
        self.flashit()
        return

    r = stats.pearson(_y, _x)

    if r is None:
        self.announce("Failed: data lengths don't match")
        self.flashit()
    else:
        self.announce("Pearson's Correlation Coefficient=%0.3f" % (r))

</t>
<t tx="tom.20211207165051.109">@REQUIRE_MAIN
def sliding_var(self):
    '''Calculate the standard deviations in a window that slides across the
    MAIN data set. The result replaces the MAIN data set.
    '''

    _ds = self.stack[MAIN]
    if not (_ds and len(_ds)):
        self.announce("No data to work with")
        self.flashit()
        return

    _id = 'sliding_var'
    lastparm = self.parmsaver.get(_id, 10)

    dia = GetSingleInt(self.root, 'Sliding Window', 'Number Of Points',
                       lastparm)
    if not dia.result: return
    self.parmsaver[_id] = dia.result

    _newx, _stds, sigma = _ds.sliding_var(dia.result)

    _ds.xdata = _newx
    _ds.ydata = _stds

    self.plot()
    self.announce('Overall Standard Deviation = %0.3f' % sigma)

</t>
<t tx="tom.20211207165051.11">def setWindowTitle(self, title=''):
    if self.root:
        self.root.wm_title(title)

</t>
<t tx="tom.20211207165051.110">@REQUIRE_MAIN
def leastsqr(self):
    _ds = self.stack[MAIN]
    _x = _ds.xdata
    _y = _ds.ydata

    newy, mean, rms, r, upperbound, lowerbound = smoother.leastsqr(_x, _y)
    _ds.ydata = newy

    lower = Dataset()
    lower.ydata = lowerbound
    lower.xdata = _x

    upper = Dataset()
    upper.ydata = upperbound
    upper.xdata = _x

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    if _ds.figurelabel:
        _ds.figurelabel = 'Least Squares Fit to %s' % (_ds.figurelabel)
    else:
        _ds.figurelabel = 'Least Squares Fit'

    self.plot()
    self.announce('Mean=%0.3f, rms = %0.3f, r=%0.3f' % (mean, rms, r))
</t>
<t tx="tom.20211207165051.111">@REQUIRE_MAIN
def leastsqr_quad(self):
    _ds = self.stack[MAIN]

    _x = _ds.xdata
    _y = _ds.ydata

    newy, mean, rms, r, upperbound, lowerbound = \
        smoother.leastsqr(_x, _y, 2)
    _ds.ydata = newy

    lower = Dataset()
    lower.ydata = lowerbound
    lower.xdata = _x

    upper = Dataset()
    upper.ydata = upperbound
    upper.xdata = _x

    # Subgraphs get stored in the errorBands list
    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    if _ds.figurelabel:
        _ds.figurelabel = 'Least Squares Quadratic Fit to %s' \
            % (_ds.figurelabel)
    else:
        _ds.figurelabel = 'Least Squares Quadratic Fit'

    self.plot()
    self.announce('Mean=%0.3f, rms=%0.3f, r=%0.3f' % (mean, rms, r))
</t>
<t tx="tom.20211207165051.112">@REQUIRE_MAIN
def thiel(self):
    _ds = self.stack[MAIN]
    _x = _ds.xdata
    _y = _ds.ydata

    fitted, slope, intercept, sd_slope = smoother.thiel_sen(_x, _y)
    _ds.ydata = fitted

    if _ds.figurelabel:
        _ds.figurelabel = 'Thiel-Sen Fit to %s' % (_ds.figurelabel)
    else:
        _ds.figurelabel = 'Thiel-Sen Least Squares Fit'

    self.plot()

    slope_str = 'Slope = %0.2g, ' % (slope)
    int_str = 'Intercept = %0.3g, ' % (intercept)
    sd_str = 'Estimated S.D. of slope: %0.3g, ' % (sd_slope)
    self.announce(slope_str + int_str + sd_str)
</t>
<t tx="tom.20211207165051.113">@REQUIRE_MAIN_BUFF
def make_phasespace(self):
    '''Replace the X axis data of the MAIN ds by replacing the x axis
       data with the ydata shifted left by one step.  That is,
       x[i] = y[i-1]. The non-overlapping ends are trimmed.
       Plot the new data set.
    '''

    _ds = self.stack[MAIN]
    _y = _ds.ydata

    _temp = []
    _num = len(_ds)
    for i in range(1, _num):
        _temp.append(_y[i - 1])

    _ds.xdata = _temp
    _ds.ydata = _ds.ydata[1:]
    _ds.figurelabel = 'Phase Space for %s' % (_ds.figurelabel)
    _ds.xaxislabel = 'Y(t1)'
    _ds.yaxislabel = 'Y(t+1)'
    self.plot()
</t>
<t tx="tom.20211207165051.114">@REQUIRE_MAIN
def YvsX(self):
    '''Replace the x axis of the data in X with its y data.
    Replace the y axis of the x data with the y data of
    the data in Y.  Plot the result.  The effect is to
    plot Y vs X.  For this to make sense, both data sets
    must have data for the same x-axis values (e.g., time).

    A check is made to make sure the two curves have the same
    number of points.

    The result is sorted on the x axis.
    '''

    _X = self.stack[MAIN]
    _Y = self.stack[BUFFER]
    _x = _X.ydata[:]
    _y = _Y.ydata[:]

    if not len(_x) == len(_y):
        self.announce('X and Y data must have the same number of points')
        self.flashit()
        return

    _X.xdata = _x
    _X.ydata = _y
    _X.figurelabel = '%s vs %s' % (_X.figurelabel, _Y.figurelabel)
    _X.xaxislabel = _X.yaxislabel
    _X.yaxislabel = _Y.yaxislabel

    self.sortX()
</t>
<t tx="tom.20211207165051.115">@REQUIRE_MAIN
def spline_smooth(self):
    _ds = self.stack[MAIN]
    _id = 'spline_smooth'
    lastparm = self.parmsaver.get(_id, 0.3)

    _x = _ds.xdata
    _y = _ds.ydata
    dia = GetSingleFloat(self.root, 'Smoothing Width',
                         'Enter Number Between 0 and 1', lastparm)
    if not dia.result:
        return
    self.parmsaver[_id] = dia.result

    x, newy = smoother.splineSmooth(_x, _y, dia.result)
    _ds.ydata = newy

    lab = _ds.figurelabel or ''
    if lab:
        lab = ' Spline Smooth of %s' % (lab)
    else:
        lab = ' Spline Smooth'
    _ds.figurelabel = lab

    self.plot()
</t>
<t tx="tom.20211207165051.116">@REQUIRE_MAIN
def cdf(self):
    _ds = self.stack[MAIN]
    ydata = _ds.ydata
    newx, newy, upperbounds, lowerbounds = stats.cdf(ydata)
    _ds.xdata = newx
    _ds.ydata = newy
    _lab = 'CDF'
    if _ds.figurelabel:
        _lab = _lab + ' of %s' % (_ds.figurelabel)
    _ds.figurelabel = _lab
    _ds.yaxislabel = 'P'
    _ds.xaxislabel = 'Value'

    lower = Dataset()
    lower.ydata = lowerbounds
    lower.xdata = newx

    upper = Dataset()
    upper.ydata = upperbounds
    upper.xdata = newx

    _ds.errorBands = []
    _ds.errorBands.append(upper)
    _ds.errorBands.append(lower)

    self.plot()

</t>
<t tx="tom.20211207165051.117">@REQUIRE_MAIN
def trend_mann_kendall(self):
    _ds = self.stack[MAIN]
    s, z, h, p = mann_kendall(_ds.ydata)
    self.announce('s: %s, z: %0.3f, trend? %s, p: %0.3f'
                  % (s, z, YESNO[h], p))

</t>
<t tx="tom.20211207165051.118">@REQUIRE_MAIN
def fitCdfWithNormal(self):
    _ds = self.stack[MAIN]
    _newx, _newy, mean, sigma = \
        stats.fitNormalToCdf(_ds.xdata, _ds.ydata, self.num)
    _ds.xdata = _newx
    _ds.ydata = _newy
    if _ds.figurelabel:
        _lab = 'CDF Fitted to %s' % (_ds.figurelabel)
    else:
        _lab = 'Fitted CDF'
    _ds.figurelabel = _lab
    self.plot()
    self.announce('mean: %0.3f,sigma: %0.3f'
                  % (mean, sigma))
</t>
<t tx="tom.20211207165051.119">@REQUIRE_MAIN
def fitCdfNormalAdaptive(self):
    _ds = self.stack[MAIN]
    values = _ds.xdata
    probs = _ds.ydata
    _newx, _newy, mean, sigma, correl = \
        stats.fitNormalToCdfAdaptive(values, probs, 0.001)
    _ds.xdata = _newx
    _ds.ydata = _newy

    if _ds.figurelabel:
        _lab = 'Adaptive Normal Fit to %s' % (_ds.figurelabel)
    else:
        _lab = 'Adaptive Normal Fit to CDF'
    _ds.figurelabel = _lab
    self.plot()
    self.announce('mean: %0.3f,sigma: %0.3f, correlation coeff: %0.3f'
                  % (mean, sigma, correl))

</t>
<t tx="tom.20211207165051.12">def label_select_all(self, event):
    '''Select all text in an edit widget (Tk.Entry) when &lt;CNTRL-A&gt;
    is pressed. It seems that the default key is &lt;CTRL-/&gt;
    (standard for linux) and this overrides that.  The
    "return 'break'" is essential, otherwise this gets ignored.
    '''

    event.widget.selection_range(0, Tk.END)
    return 'break'

</t>
<t tx="tom.20211207165051.120">@REQUIRE_MAIN
def histogram(self):
    _id = 'histogram'
    lastparm = self.parmsaver.get(_id, 10)

    dia = GetSingleInt(self.root, ' Histogram', 'Number Of Bins', lastparm)
    if not dia.result:
        return
    self.parmsaver[_id] = dia.result
    bins = dia.result

    _ds = self.stack[MAIN]
    ydata = _ds.ydata
    if bins &gt;= len(ydata):
        self.announce(
            'Too many bins - must be less than number of points'
            '(%s)' % (len(ydata)))
        self.flashit()
        return

    newx, newy = stats.histogram(ydata, bins)

    _ds = Dataset()
    _ds.xdata = newx
    _ds.ydata = newy
    _ds.figurelabel = 'Histogram'
    _ds.yaxislabel = 'P'
    _ds.xaxislabel = 'Data Value'
    self.stack[MAIN] = _ds
    self.plot()

    self.announce('Total counts: %s' % (len(ydata)))

</t>
<t tx="tom.20211207165051.121">@REQUIRE_MAIN
def mean_std(self):
    ydata = self.stack[MAIN].ydata
    mean, std = stats.meanstd(ydata)
    _max = max(ydata)

    # Check ydata type because it might not be a list
    # pylint: disable = unidiomatic-typecheck
    if type(ydata) == type(ndarray(1)):
        _ydata_list = ydata.tolist()
        _maxy_index = _ydata_list.index(_max)
        _maxy_index = _ydata_list.index(_max)
    else:
        _maxy_index = ydata.index(_max)
        _maxy_index = ydata.index(_max)
    _max_x_coord = self.stack[MAIN].xdata[_maxy_index]

    # Lag-1 autocorrelation
    sum_resid = sum([y**2 for y in ydata])
    sum_lag = 0
    for i in range(1, len(ydata)):
        sum_lag += ydata[i] * ydata[i - 1]

    rho = sum_lag / sum_resid

    _temp = self.stack[MAIN].copy()
    _temp.integrate()
    area = _temp.ydata[-1]
    span = abs(max(ydata) - min(ydata))

    msg = 'Max: %0.3f at x=%0.3f  Mean: %0.4f  Span: %0.4f, Std Dev: %0.4f  '\
          'Area: %.2e  rho: %0.3f N = %s' %\
          (_max, _max_x_coord, mean, span, std, area, rho, len(ydata))
    self.announce(msg)

</t>
<t tx="tom.20211207165051.122">@REQUIRE_MAIN
def normalize(self):
    ''' Normalize the X data to 1.0.  Replot.
    '''
    self.stack[MAIN].normalize()
    self.plot()
</t>
<t tx="tom.20211207165051.123">@REQUIRE_MAIN
def fft(self):
    self.stack[MAIN].rfft()
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = 'FFT of %s' % (lab)
    self.stack[MAIN].xaxislabel = 'Frequency'
    self.stack[MAIN].yaxislabel = 'Relative Amplitude'
    self.plot()
</t>
<t tx="tom.20211207165051.124">@REQUIRE_MAIN
def h_super_gaussian(self):
    self.stack[MAIN].halfSupergaussian()
    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = 'Windowed %s' % (lab)

    self.plot()

</t>
<t tx="tom.20211207165051.125">@REQUIRE_MAIN
def gaussian_window(self):
    self.stack[MAIN].fullSuperGaussian(2)
    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = ' Gaussian Windowed %s' % (lab)

    self.plot()

</t>
<t tx="tom.20211207165051.126">@REQUIRE_MAIN
def super_gaussian(self):
    self.stack[MAIN].fullSuperGaussian()
    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = ' SuperGaussian Windowed %s' % (lab)

    self.plot()

</t>
<t tx="tom.20211207165051.127">@REQUIRE_MAIN
def h_cosine(self):
    self.stack[MAIN].halfCosine()
    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = ' Windowed %s' % (lab)

    self.plot()

</t>
<t tx="tom.20211207165051.128">@REQUIRE_MAIN
def full_cosine(self):
    self.stack[MAIN].fullCosine()
    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = ' Windowed %s' % (lab)

    self.plot()

</t>
<t tx="tom.20211207165051.129">@REQUIRE_MAIN
def var_ratio(self):
    _id = 'var_ratio'
    lastparm = self.parmsaver.get(_id, 40)

    dia = GetSingleInt(self.root, 'Variance Ratio',
                       'Window Width', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    lab = self.stack[MAIN].figurelabel
    if lab and lab != 'Figure Label':
        self.stack[MAIN].figurelabel = 'Variance Ratio for %s' % (lab)

    self.stack[MAIN].var_ratio(dia.result)
    self.plot()

</t>
<t tx="tom.20211207165051.13">def setupFigure(self, title='GF4'):
    root = Tk.Tk()
    root.option_add('*tearOff', False)  # Tk specific menu option

    root.bind('&lt;Alt-F4&gt;', self.quit)

    f = Figure(figsize=(9, 6), dpi=100, facecolor=LIGHTGRAY)
    ax = None  # f.add_subplot(111, axisbg='0.3')

    canvas = FigureCanvasTkAgg(f, master=root)
    canvas.get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)

    self._sv = Tk.StringVar()
    self._sv.set('')
    self.editWidget = Tk.Entry(root, textvariable=self._sv, width=80)
    self.editWidget.bind('&lt;Return&gt;', self.doneEditLabel)
    self.editWidget.bind('&lt;Escape&gt;', self.doneEditLabel)
    self.editWidget.bind('&lt;Control-a&gt;', self.label_select_all)

    self.root = root
    self.axes = ax
    self.figure = f
    self.canvas = canvas
    self.fix_ticks()
    self.setWindowTitle(title)

    canvas.mpl_connect('button_press_event', self.edit_label)

    self.toolbar = NavigationToolbar2Tk(canvas, root)
    self.toolbar.update()

    _ann = TextFade(root, height=1, font='size 12',
                    width=100, bd=0, pady=5, bg='LightBlue')
    _ann.insert(1.0, '')
    _ann.config(state=Tk.DISABLED)
    _ann.pack()

    self.announcer = _ann

    self.set_editable_labels()
    self.currentLabelEditing = None

</t>
<t tx="tom.20211207165051.130">@REQUIRE_MAIN_BUFF
def y_vs_y(self):
    '''Plot y values from BUFFER against y values from MAIN,
    The previous data in MAIN is overrwritten.
    '''

    if len(self.stack[MAIN]) != len(self.stack[BUFFER]):
        self.announce('MAIN and BUFFER must be the same length')
        self.flashit()
        return

    self.stack[MAIN].xdata = self.stack[MAIN].ydata[:]
    self.stack[MAIN].ydata = self.stack[BUFFER].ydata[:]

    self.plot()

</t>
<t tx="tom.20211207165051.131">def addTimehack(self):
    if not self.stack[MAIN]:
        self.announce('No data')
        self.flashit()
        return

    _id = 'timehack'
    lastparm = self.parmsaver.get(_id, 118)
    dia = GetSingleFloat(self.root, 'X-value Marker',
                         'X Position', lastparm)
    if dia.result is None: return

    self.parmsaver[_id] = dia.result
    self.timehack(dia.result)

</t>
<t tx="tom.20211207165051.132">def runMacro(self, cmdlist=''):
    '''Given a string of commands, one per line, execute the commands
    in order.  First check to make sure all commands are valid;
    execute the sequence of commands if they are.  Lines whose first
    non-whitespace character is ';' or '#' are ignored as comment lines.

    Return nothing.

    ARGUMENT
    cmdlist --  a string of line-separated command names.

    RETURNS
    nothing
    '''

    if not cmdlist:
        self.announce('No command list to run')
        self.flashit()
        return

    cmds = cmdlist.splitlines()
    cmds = [c.strip() for c in cmds if c.strip()]
    cmds = [c for c in cmds if c[0] not in COMMENTS]
    unknowns = []

    for cmd in cmds:
        if not self.commands.get(cmd):
            unknowns.append(cmd)

    if unknowns:
        msg = 'unknown commands: %s' % (' '.join(unknowns))
        self.announce(msg)
        self.flashit()
        return

    for cmd in cmds:
        self.interpret(cmd)

</t>
<t tx="tom.20211207165051.133">def testMacro(self):
    self.runMacro('''dsin
                    copy2buff
                    sqr
                    plot
                    ; comment
                    overplotbuf
                    # another comment
                    ''')

</t>
<t tx="tom.20211207165051.134">def interpret(self, command=''):
    '''Given a string alias for a command, find and execute the command.
    If no such command is found, announce an error.

    ARGUMENT
    command -- a string.

    RETURNS
    nothing.
    '''

    if not command:
        self.announce('No command to execute')
        self.flashit()
        self.fadeit()
        return

    if not self.commands.get(command, None):
        self.announce('Unknown command: "%s"' % (command))
        self.flashit()
        self.fadeit()
        return

    self.commands[command]()

</t>
<t tx="tom.20211207165051.135">def hasToplevel(self):
    for c in self.root.winfo_children():
        if c.winfo_class() == 'Toplevel':
            return True
    return False

</t>
<t tx="tom.20211207165051.136">if __name__ == '__main__':
    matplotlib.rcParams['xtick.direction'] = 'out'
    matplotlib.rcParams['ytick.direction'] = 'out'

    plotmgr = PlotManager()
    plotmgr.root.update_idletasks()

    fname = ''

    # Overplot all files listed on the command line
    _first = True
    for fname in sys.argv[1:]:
        try:
            if _first:
                plotmgr.load_plot_data(fname)
                _first = False
            else:
                plotmgr.load_plot_data(fname, True)
        except Exception as e:
            print (e)

    cmdwindow(plotmgr)
    plotmgr.announce('Using: %s' % (sys.executable))
    plotmgr.fadeit()

    Tk.mainloop()
</t>
<t tx="tom.20211207165051.14">def fadeit(self, widget=None):
    '''For TextFade widgets and similar with a fade() method.'''
    if widget and 'fade' not in dir(widget): return
    if not widget:
        widget = self.announcer
    widget.fade()

</t>
<t tx="tom.20211207165051.15">def flashit(self, color='yellow', widget=None):
    '''For TextFade widgets and similar with a flash() method.'''
    if widget and 'flash' not in dir(widget): return
    if not widget:
        widget = self.announcer
    widget.flash(color)
    widget.after(1000)
    self.fadeit(widget)

</t>
<t tx="tom.20211207165051.16">def announce(self, msg='This is a test'):
    '''Show an message in the announcement area.'''
    _ann = self.announcer
    _ann.config(state=Tk.NORMAL)
    _ann.delete(1.0, Tk.END)
    _ann.insert(1.0, msg)
    _ann.config(state=Tk.DISABLED)

</t>
<t tx="tom.20211207165051.17">def set_editable_labels(self):
    '''Create a list of those labels that can be edited with the standard
    single-line edit widget.  Return nothing.
    '''
    if not self.axes: return

    self.editableLabels.extend([
        self.axes.get_xaxis().get_label(),
        self.axes.get_yaxis().get_label()]
    )

</t>
<t tx="tom.20211207165051.18">def edit_label(self, event):
    '''Respond to a mouse-press event.  Check all the editable labels,
    plus other Text items in the figure, to see if the event belongs to
    one of them.  If so, display the label edit widget over the label.

    ARGUMENT
    event - a mathplotlib event;  MouseEvent is expected.

    RETURNS
    nothing.
    '''
    if not self.axes: return

    _labels = [item for item in self.axes.get_children()
               if isinstance(item, matplotlib.text.Text)]
    _labels.extend(self.editableLabels)

    lab = None
    for _lab in _labels:
        if _lab.contains(event)[0]:
            lab = _lab
            break

    if lab is None:
        self.currentLabelEditing = None
        return

    self.currentLabelEditing = lab
    ew = self.editWidget
    self._sv.set(lab.get_text())

    &lt;&lt; configure editwidget &gt;&gt;
    ew.place(x=ulx, y=canv_uly - lry)
    ew.selection_clear()
    ew.focus_set()
    ew.lift()

</t>
<t tx="tom.20211207165051.19">def doneEditLabel(self, event):
    """Receive &lt;Return&gt; and &lt;Escape&gt; events.  For &lt;Escape&gt;, leave.
    For &lt;Return&gt;, also change the label's text, and set the Dataset's
    corresponding label, if any.
    """

    if not self.currentLabelEditing: return

    if event.keysym == 'Return':
        _newtext = event.widget.get()
        self.currentLabelEditing.set_text(_newtext)
        self.canvas.draw()

        if self.currentLabelEditing is self.axes.get_xaxis().get_label():
            self.stack[MAIN].xaxislabel = _newtext
        elif self.currentLabelEditing is self.axes.get_yaxis().get_label():
            self.stack[MAIN].yaxislabel = _newtext
        elif _newtext == self.axes.get_title():
            self.stack[MAIN].figurelabel = _newtext
    elif event.keysym == 'Escape':
        self.canvas.draw()

    event.widget.lower()
    event.widget.selection_clear()
    self.currentLabelEditing = None

</t>
<t tx="tom.20211207165051.2"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211207165051.20">def setYMin(self, val):
    if not self.axes: return
    axis = self.axes
    axis.set_ybound(self.stack[MAIN].ymin)

</t>
<t tx="tom.20211207165051.21">def fix_ticks(self):
    '''Make tick marks point out of the figure's frame rather than the
    default of inwards.
    '''
    if not self.axes: return

    # tick mark adjustments adapted from
    # http://osdir.com/ml/python.matplotlib.general/2005-01/msg00076.html
    axis = self.axes
    xticks = axis.get_xticklines()
    for tick in xticks:
        tick.set_markersize(6)

    yticks = axis.get_yticklines()
    for tick in yticks:
        tick.set_markersize(6)

    xlabels = axis.get_xticklabels()
    for label in xlabels:
        label.set_y(-0.02)
        label.set_size('small')

    ylabels = axis.get_yticklabels()
    for label in ylabels:
        label.set_x(-0.02)
        label.set_size('small')

</t>
<t tx="tom.20211207165051.22">def setMenus(self):
    mainMenu = createMenus.setMenus(self)
    self.root.config(menu=mainMenu)

</t>
<t tx="tom.20211207165051.23">def test_announce(self):
    self.announce('testing the Announcer')

</t>
<t tx="tom.20211207165051.24">def set_axis_bg(self):
    self.axes.set_facecolor('yellow')
# =============================================================

</t>
<t tx="tom.20211207165051.25">def setSemilogY(self):
    self.semilogY = True
    self.semilogX = False
    self.plot()

</t>
<t tx="tom.20211207165051.26">def setSemilogX(self):
    self.semilogY = False
    self.semilogX = True
    self.plot()

</t>
<t tx="tom.20211207165051.27">def setLogLog(self):
    self.semilogY = True
    self.semilogX = True
    self.plot()

</t>
<t tx="tom.20211207165051.28">def setLinLin(self):
    self.semilogY = False
    self.semilogX = False
    self.plot()

</t>
<t tx="tom.20211207165051.29">def overplotbuff(self):
    self.overplot(BUFFER)

</t>
<t tx="tom.20211207165051.3">from __future__ import print_function

import os.path
import sys

import tkinter as Tk
import tkinter.font as tkFont
from tkinter import filedialog as fd

import matplotlib
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
from matplotlib.figure import Figure

from numpy import ndarray
from scipy.stats import spearmanr

#from randnum import *
from AbstractPlotMgr import AbstractPlotManager
from AbstractPlotMgr import MAIN, BUFFER, STACKDEPTH, ERRBAND_HI, ERRBAND_LO

import createMenus
from colors import (BLACK, CYAN, GRAY, LIGHTGRAY, DEFAULTGRIDCOLOR,
                    ColorBgPairs)

from Dataset import Dataset
from Linestyle import (Linestyle, LINETHIN, LINEMED)
#from Linestyle import (CIRCLE, HEXAGON, DIAMOND, SQUARE, TRIANGLE,
#                       SYM_NONE, LINE_NONE, LINE_SOLID, LINETHICK)
import smoother
from fits import piecewiseLinear
import stats

from entry import TextFade, GetSingleInt, GetSingleFloat #, GetTwoFloats
from entry import GetTwoNumbers #, GetTwoInts
from editDialog import editDialog
from trend import mann_kendall, YESNO

from cmdwin import cmdwindow

matplotlib.use('TkAgg')

</t>
<t tx="tom.20211207165051.30">def overplot_errorbands(self, stackposition=MAIN):
    if not self.stack[stackposition].errorBands:
        self.announce('No errorband data to plot')
        self.flashit()
        return

    _ds = self.stack[stackposition]

    # Overplot error bands
    upper = _ds.errorBands[ERRBAND_HI]
    lower = _ds.errorBands[ERRBAND_LO]

    del self.stack[STACKDEPTH:]
    self.stack.append(upper)
    self.stack.append(lower)

    self.axes.fill_between(self.stack[MAIN].xdata,
            self.stack[STACKDEPTH + ERRBAND_HI].ydata,
            self.stack[STACKDEPTH + ERRBAND_LO].ydata,
            facecolor='lightgrey', alpha=0.1)

    for g in [STACKDEPTH + ERRBAND_HI, STACKDEPTH + ERRBAND_LO]:
        self.overplot(g)

</t>
<t tx="tom.20211207165051.31">def overplot(self, stackposition=MAIN):
    self.plot(stackposition, False)

</t>
<t tx="tom.20211207165051.32">def copyToBuffer(self):
    if not self.stack[MAIN]:
        self.announce("No waveform to copy")
        self.flashit()
        return

    self.stack[BUFFER] = self.stack[MAIN].copy()

</t>
<t tx="tom.20211207165051.33">def swap_data(self):
    if not self.stack[MAIN] or not self.stack[BUFFER]:
        self.announce("Missing one or both waveforms  - nothing to swap")
        self.flashit()
        return

    _temp = self.stack[BUFFER].copy()
    self.stack[BUFFER] = self.stack[MAIN].copy()
    self.stack[MAIN] = _temp

</t>
<t tx="tom.20211207165051.34">def paste_data(self):
    if not self.stack[BUFFER]:
        self.announce("No waveform to paste")
        self.flashit()
        return

    self.stack[MAIN] = self.stack[BUFFER].copy()

</t>
<t tx="tom.20211207165051.35">def drop_stack(self):
    '''Drop stack of datasets, leave top one unchanged.'''
    for i in range(STACKDEPTH - 1):
        self.stack[i] = self.stack[i + 1].copy()

</t>
<t tx="tom.20211207165051.36">def push_with_copy(self):
    '''Push dataset stack up, duplicate duplicate bottom:
        top-1 -&gt; top        -2 -&gt; -1
        ...
        1 -&gt; 2
        0 -&gt; 1
        0 stays unchanged
    '''

    for i in range(STACKDEPTH - 1, 0, -1):
        self.stack[i] = self.stack[i - 1].copy()

</t>
<t tx="tom.20211207165051.37">def rotate_stack_up(self):
    '''Rotate dataset stack up:
        1 -&gt; 2
        2 -&gt; 3
        ...
        top -&gt; 1
    '''

    temp = self.stack[STACKDEPTH - 1].copy()
    self.push_with_copy()
    self.stack[0] = temp

</t>
<t tx="tom.20211207165051.38">def rotate_stack_down(self):
    '''Rotate stack downwards:
            top -&gt; top-1
            ...
            2 -&gt; 1
            1 -&gt; top
    '''
    temp = self.stack[0].copy()
    self.drop_stack()
    self.stack[STACKDEPTH - 1] = temp

</t>
<t tx="tom.20211207165051.39">def copy_to_top(self):
    '''Copy active dataset to top of stack.'''
    self.stack[STACKDEPTH - 1] = self.stack[MAIN].copy()

</t>
<t tx="tom.20211207165051.4">class PlotManager(AbstractPlotManager):

    # pylint: disable = import-outside-toplevel
    # pylint: disable = too-many-public-methods

    # Putting these imports at the top of the module doesn't work
    # Because they expect to be called as methods with a "self" param.
    from Plot import plot
    from Timehack import timehack
    from BuildCommands import buildCommands
    from MakeWaveforms import (
        makeExponential, makeSine, makeDampedSine,
        makeStep, makeDelta, makeRamp,
        makeSquarewave, makeRandomNoise,
        makeUniformNoise, makeGaussianNoise,
        pdfGaussian, cdfGaussian)

    @others

</t>
<t tx="tom.20211207165051.40">def copy_from_top(self):
    '''Copy top dataset to bottom of stack ("main").'''
    self.stack[MAIN] = self.stack[STACKDEPTH - 1].copy()

</t>
<t tx="tom.20211207165051.41">def setPlotLineWidth(self, position, width):
    self.linestyles[position].set_linewidth(width)

</t>
<t tx="tom.20211207165051.42">def setLineColor(self, stackpos):
    '''Called only though a menu selection, so that self.x_line_color
    is set before this method is called.
    '''

    if stackpos == MAIN:
        _color = self.main_line_color.get()
    else:
        _color = self.buffer_line_color.get()
    self.linestyles[stackpos].set_linecolor(_color)

</t>
<t tx="tom.20211207165051.43">def setLineColorMain(self):
    self.setLineColor(MAIN)

</t>
<t tx="tom.20211207165051.44">def setLineColorBuffer(self):
    self.setLineColor(BUFFER)

</t>
<t tx="tom.20211207165051.45">def setSymColor(self, stackpos):
    '''Called only though a menu selection, so that self.x_symbol_color
    is set before this method is called.
    '''

    if stackpos == MAIN:
        _color = self.main_symbol_color.get()
    else:
        _color = self.buffer_symbol_color.get()
    self.linestyles[stackpos].set_sym_color(_color)

</t>
<t tx="tom.20211207165051.46">def setSymColorMain(self):
    self.setSymColor(MAIN)

</t>
<t tx="tom.20211207165051.47">def setSymColorBuffer(self):
    self.setSymColor(BUFFER)

</t>
<t tx="tom.20211207165051.48">def setBgColor(self):
    _color = self.graph_bg_color.get()
    self.axes.set_facecolor(_color)
    _gridcolor = ColorBgPairs.get(_color, DEFAULTGRIDCOLOR)
    self.gridcolor = _gridcolor

</t>
<t tx="tom.20211207165051.49">def setMainLineWidth(self):
    _width = float(self.radio_main_linestyle.get())
    self.setPlotLineWidth(MAIN, _width)

</t>
<t tx="tom.20211207165051.5">def doErrorBands(method):
    '''A decorator method to process error bands in the same way that
    the y data is processed.  The original method call must return
    the Dataset it is being applied to, and the method it applies.
    '''
    # pylint: disable = no-self-argument
    # pylint: disable = not-callable
    def new_method(*args):
        # args[0] will be the calling instance (i.e., self)
        # Call original method
        _ds, func = method(args[0])

        if _ds and _ds.errorBands:
            func(_ds.errorBands[0])
            func(_ds.errorBands[1])

    return new_method

</t>
<t tx="tom.20211207165051.50">def setBufferLineWidth(self):
    _width = float(self.radio_buffer_linestyle.get())
    self.setPlotLineWidth(BUFFER, _width)

</t>
<t tx="tom.20211207165051.51">def setMarkerStyle(self, stackpos):
    # pylint: disable = no-member
    if stackpos == MAIN:
        _ms = self.main_marker_style
    else:
        _ms = self.buffer_marker_style
    _style = int(_ms.get())
    _ls = self.linestyles[stackpos]
    if _style == 1:
        _ls.useLine = True
        _ls.useSym = False
    elif _style == 2:
        _ls.useLine = False
        _ls.useSym = True
    else:
        _ls.useLine = True
        _ls.useSym = True

</t>
<t tx="tom.20211207165051.52">def setMainMarkerStyle(self):
    self.setMarkerStyle(MAIN)

</t>
<t tx="tom.20211207165051.53">def setBufferMarkerStyle(self):
    self.setMarkerStyle(BUFFER)

</t>
<t tx="tom.20211207165051.54">def setSymShape(self, stackpos):
    if stackpos == MAIN:
        _shp = self.main_symbol_shape
    else:
        _shp = self.buffer_symbol_shape
    _shape = _shp.get()
    _ls = self.linestyles[stackpos]
    _ls.set_sym_style(_shape)

</t>
<t tx="tom.20211207165051.55">def setSymShapeMain(self):
    self.setSymShape(MAIN)

</t>
<t tx="tom.20211207165051.56">def setSymShapeBuffer(self):
    self.setSymShape(BUFFER)

</t>
<t tx="tom.20211207165051.57">def setXlabel(self, label=''):
    self.axes.set_xlabel(label)

</t>
<t tx="tom.20211207165051.58">def setYlabel(self, label=''):
    self.axes.set_ylabel(label)

</t>
<t tx="tom.20211207165051.59">def setFigureTitle(self, title=''):
    #self.axes.set_title(title, size='x-large', y=1.025)
    self.axes.set_title(title, size='large', y=1.025)

</t>
<t tx="tom.20211207165051.6">def REQUIRE_MAIN(procedure):
    """A decorator method to check if there is data in the MAIN slot.

    If not, exit procedure with error message.  Otherwise,
    execute the procedure.

    ARGUMENT
    procedure -- an instance method that takes no parameters.
    """
    # pylint: disable = no-self-argument
    # pylint: disable = not-callable
    def new_proc(*args):
        # args[0] will be the calling instance (i.e., self)
        self = args[0]
        _main = self.stack[MAIN]
        if not (_main and len(_main.xdata)):
            msg = 'Missing Waveform'
            self.announce(msg)
            self.flashit()
            return
        procedure(*args)
    return new_proc

</t>
<t tx="tom.20211207165051.60">def set_data(self, dataset, stackpos=MAIN):
    self.stack[stackpos] = dataset.copy()

</t>
<t tx="tom.20211207165051.61">def save_data(self, saveas=True):
    '''Write x,y data in MAIN to an ASCII file.  Labels and other meta data
    are also written.

    ARGUMENT
    saveas -- if True, use Save As dialog.  Otherwise, use original
              filename if one exists, and use Save As instead.

    RETURNS
    nothing
    '''

    opt = {}

    if self.stack[MAIN].orig_filename:
        opt['initialfile'] = self.stack[MAIN].orig_filename
    if self.initpath:
        opt['initialdir'] = self.initpath

    if saveas:
        fname = fd.asksaveasfilename(**opt)
    else:
        fname = self.stack[MAIN].orig_filename or \
                fd.asksaveasfilename(**opt)

    self.stack[MAIN].writeAsciiData(fname)
    self.stack[MAIN].orig_filename = fname

</t>
<t tx="tom.20211207165051.62">def load_data(self, stackpos=MAIN):
    '''Open a file dialog for reading, and remember its directory and filename.
    Use that last stored directory or file as the initial directory when
    opening the file dialog.  Load the data from the selected file into
    the specified Dataset. Assumes data is in ASCII format.  Plot
    the data if no other data has yet been plotted.

    The data set may be divided into parts by the special
    comment string ';;ENDDATASET'.  If so, load each such delineated
    part into stack positions MAIN, BUFFER, and the top-most
    position, if there are enough data parts.

    ARGUMENT
    stackpos -- integer specifying the stack position to load
                the data into.

    RETURNS
    Nothing.
    '''

    if not self.current_path:
        f = fd.askopenfile(mode='r', initialdir=self.initpath)
    else:
        f = fd.askopenfile(mode='r', initialfile=self.current_path)
    if not f:
        return

    fname = f.name
    data = f.read()
    f.close()

    self.initpath = os.path.dirname(fname)
    self.current_path = fname

    blocks = data.split(ENDDATASET)
    numblocks = len(blocks)
    if numblocks &lt; 1:
        self.announce('No data found')
        return

    for n in range(min(len(blocks), STACKDEPTH)):
        block = blocks[n]
        if not block.split():
            continue

        lines = block.split('\n')
        _data = Dataset()
        _data.orig_filename = fname
        err = _data.setAsciiData(lines)
        if err:
            self.announce(f'No data in block {n}')
            self.flashit()
            self.announce(f'No data in block {n}')
            return

        if n &lt;= BUFFER:
            self.set_data(_data, n)
        elif n == BUFFER + 1:
            self.set_data(_data, STACKDEPTH - 1)

    if not self.axes:
        self.plot()

</t>
<t tx="tom.20211207165051.63">def load_plot_data(self, fname, overplot=False):
    '''Load the data from the specified file into the specified Dataset.
    Load the dataset into the MAIN stack buffer position.
    Assumes data is in ASCII format.  Plot the data if no other
    data has yet been plotted, otherwise plot or overplot it
    according to the value of the overplot parameter.

    ARGUMENT
    fname -- path to a file
    overplot -- Boolean

    RETURNS
    Nothing.
    '''

    with open(fname, encoding = ENCODING) as f:
        data = f.read()

    self.initpath = os.path.dirname(fname)

    blocks = data.split(ENDDATASET)
    numblocks = len(blocks)
    if numblocks &lt; 1:
        self.announce('No data found')
        return

    for n in range(min(len(blocks), STACKDEPTH)):
        block = blocks[n]
        lines = block.split('\n')
        _data = Dataset()
        _data.orig_filename = fname
        err = _data.setAsciiData(lines)
        if err:
            self.announce('%s' % err)
            self.flashit()
            self.announce('%s' % err)
            return

        if n &lt;= BUFFER:
            self.set_data(_data, n)
        elif n == BUFFER + 1:
            self.set_data(_data, STACKDEPTH - 1)

    if not self.axes:
        self.plot()
    else:
        if overplot: self.overplot()
        else: self.plot()

</t>
<t tx="tom.20211207165051.64">def copy_data_to_clipboard(self):
    '''Copy data from MAIN stack buffer position into the clipboad.
    Do not copy any error bands.

    ARGUMENTS
    none

    RETURNS
    nothing
    '''

    _ds = self.stack[MAIN]
    if not (_ds) or not _ds.xdata:
        self.announce("No data to work with")
        self.flashit()
        return

    _data = _ds.data2String()

    try:
        self.root.clipboard_clear()
        self.root.clipboard_append(_data)
    except Exception as e:
        self.announce("Error wwriting to clipboard: %s" % (e))
        self.flashit()

</t>
<t tx="tom.20211207165051.65">def load_data_from_popup(self):
    '''Pop up an editor dialog that returns a string of data lines.
    The data set may be divided into parts by the special
    comment string ';; ENDDATASET'.  If so,load  each such delineated
    part into stack positions MAIN, BUFFER, and the top-most
    position, if there are enough data parts.

    Assumes the data is in ASCII format.  Plot the MAIN data if no
    other data has yet been plotted.

    ARGUMENTS
    none

    RETURNS
    nothing
    '''

    data = editDialog(self.root, 'Enter Data').result
    if not data.strip(): return

    blocks = data.split(ENDDATASET)
    numblocks = len(blocks)
    if numblocks &lt; 1:
        self.announce('No data found')
        return

    for n in range(min(len(blocks), STACKDEPTH)):
        block = blocks[n]
        lines = block.split('\n')
        _data = Dataset()
        err = _data.setAsciiData(lines)
        if err:
            self.announce('%s' % err)
            self.flashit()
            self.announce('%s' % err)
        else:
            if n &lt;= BUFFER:
                self.set_data(_data, n)
            elif n == BUFFER + 1:
                self.set_data(_data, STACKDEPTH - 1)

    if not self.axes:
        self.plot()
</t>
<t tx="tom.20211207165051.66">def store1(self):
    """Store X dataset in a special location outside the stack."""
    _ds = self.stack[MAIN].copy()
    self.storage = _ds

</t>
<t tx="tom.20211207165051.67">def recall1(self):
    """Recall stored dataset to X."""
    if self.storage:
        self.stack[MAIN] = self.storage.copy()
    else:
        self.announce("No stored data to recall")
        self.flashit()

</t>
<t tx="tom.20211207165051.68">def setNumPoints(self):
    current = self.num
    dia = GetSingleInt(self.root, 'Set Number Of Points',
                       'Number', current)
    if dia.result is None: return
    self.setNum(dia.result)

</t>
<t tx="tom.20211207165051.69">def replaceX(self):
    '''Replace X axis values.  New values will be uniformly spaced.
    If there are any error bands, replace their axes too.  If either
    the new start value or new delta cannot be an integer, then both
    will be taken to be floating point numbers.
    '''

    _ds = self.stack[MAIN]
    if not _ds or not _ds.xdata:
        self.announce("No data to work with")
        self.flashit()
        return

    _xdata = _ds.xdata

    _id = 'replaceX'
    current = (_xdata[0], _xdata[1] - _xdata[0])
    _start, _delta = self.parmsaver.get(_id, current)
    dia = GetTwoNumbers(self.root, 'Set New X Axis', 'Start',
                        'Increment', _start, _delta)
    if dia.result is None: return

    new_start, new_delta = dia.result
    _ds.xdata = [new_start + 1.0 * n * new_delta for n in
                 range(0, len(_ds.xdata))]

    if _ds.errorBands:
        for eb in _ds.errorBands:
            eb.xdata = _ds.xdata

    self.plot()

    self.parmsaver[_id] = (new_start, new_delta)
</t>
<t tx="tom.20211207165051.7">def REQUIRE_MAIN_BUFF(procedure):
    """A decorator method to check if there is data in the MAIN
    and BUFFER slots.

    If not, exit procedure with error message.  Otherwise,
    execute the procedure.

    ARGUMENT
    procedure -- an instance method that takes no parameters.
    """
    # pylint: disable = no-self-argument
    # pylint: disable = not-callable

    def new_proc(*args):
        # args[0] will be the calling instance (i.e., self)
        self = args[0]
        _main = self.stack[MAIN]
        _buff = self.stack[BUFFER]
        if not (_main and len(_main.xdata) and
                _buff and len(_buff.xdata)):
            self.announce("Missing one or both waveforms")
            self.flashit()
            return
        procedure(self)
    return new_proc

</t>
<t tx="tom.20211207165051.70">@REQUIRE_MAIN
def dedup(self):
    self.stack[MAIN].dedup()

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = '%s De-duplicated' % (lab)
    else:
        lab = 'De-duplicated Points'
    self.stack[MAIN].figurelabel = lab

    self.plot()

</t>
<t tx="tom.20211207165051.71">@REQUIRE_MAIN
def pad_truncate(self):
    _ds = self.stack[MAIN]
    num = len(_ds.xdata)

    dia = GetSingleInt(self.root, 'Pad or Truncate Data',
                       'New Number of Points', num)
    if dia.result is None: return

    _ds.pad_truncate(dia.result)
    self.plot()
</t>
<t tx="tom.20211207165051.72">@REQUIRE_MAIN
def fit_piecewise(self):
    _ds = self.stack[MAIN]
    _id = 'fit_piecewise'
    lastparm = self.parmsaver.get(_id, 2)

    dia = GetSingleInt(self.root, 'Piecewise Linear Fit',
                       'Number of Segments to Use', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    _fitted = piecewiseLinear(_ds.xdata, _ds.ydata, dia.result)
    _ds.ydata = _fitted

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'Piecewise Linear Fit to %s' % (lab)
    else:
        lab = 'Piecewise Linear Fit'
    self.stack[MAIN].figurelabel = lab

    self.plot()
</t>
<t tx="tom.20211207165051.73">@REQUIRE_MAIN
def shift(self):
    _id = 'shift'
    lastparm = self.parmsaver.get(_id, 0)

    dia = GetSingleInt(self.root, 'Shift Horizontally',
                       'Distance', lastparm)
    if dia.result is None: return

    self.parmsaver[_id] = dia.result

    self.stack[MAIN].shift(dia.result)
    self.plot()
</t>
<t tx="tom.20211207165051.74">@REQUIRE_MAIN
def transpose(self):
    if not self.stack[MAIN]:
        self.announce("No data to work with")
        self.flashit()
        return None, None

    _ds = self.stack[MAIN]
    _ds.transpose()
    self.plot()

    return _ds, Dataset.transpose
</t>
<t tx="tom.20211207165051.75">@REQUIRE_MAIN
def sortX(self):
    self.stack[MAIN].sortX()
    self.plot()
</t>
<t tx="tom.20211207165051.76">@REQUIRE_MAIN
def scale(self):
    _id = 'scale'
    lastparm = self.parmsaver.get(_id, 1.0)
    dia = GetSingleFloat(self.root, 'Scale Y Data',
                         'Scaling Factor', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    _ds = self.stack[MAIN]
    _ds.scale(dia.result)

    if _ds.errorBands:
        _ds.errorBands[0].scale(dia.result)
        _ds.errorBands[1].scale(dia.result)

    self.plot()
</t>
<t tx="tom.20211207165051.77">@REQUIRE_MAIN
def add_constant(self):
    _ds = self.stack[MAIN]

    _id = 'add_constant'
    lastparm = self.parmsaver.get(_id, 0.0)
    dia = GetSingleFloat(self.root,
                         'Add Constant To Y Data', 'Constant',
                         lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    _ds.addConstant(dia.result)

    if _ds.errorBands:
        _ds.errorBands[0].addConstant(dia.result)
        _ds.errorBands[1].addConstant(dia.result)

    self.plot()
</t>
<t tx="tom.20211207165051.78">@REQUIRE_MAIN
def differentiate(self):
    self.stack[MAIN].differentiate()
    self.stack[MAIN].figurelabel = ' Derivative of %s' % \
        (self.stack[MAIN].figurelabel)
    self.plot()
</t>
<t tx="tom.20211207165051.79">@REQUIRE_MAIN
def differentiate2(self):
    self.stack[MAIN].differentiate2()
    self.stack[MAIN].figurelabel = ' Derivative of %s' % \
        (self.stack[MAIN].figurelabel)
    self.plot()
</t>
<t tx="tom.20211207165051.8">def __init__(self, root=None):
    super().__init__(root)
    self.toolbar = None

    self.linestyles = [Linestyle() for i in range(self.stackdepth)]
    self.linestyles[MAIN].linecolor = BLACK
    self.linestyles[MAIN].sym_mec = BLACK
    self.linestyles[MAIN].linewidth = LINEMED
    self.linestyles[BUFFER].linecolor = CYAN
    self.linestyles[BUFFER].sym_mec = BLACK
    self.linestyles[BUFFER].sym_mfc = CYAN
    self.linestyles[BUFFER].linewidth = LINEMED

    self.errorbar_linestyles = Linestyle()
    self.errorbar_linestyles.linecolor = GRAY
    self.errorbar_linestyles.linewidth = LINETHIN

    self.main_symbol_color = Tk.StringVar()
    self.buffer_symbol_color = Tk.StringVar()
    self.main_line_color = Tk.StringVar()
    self.buffer_line_color = Tk.StringVar()
    self.radio_main_linestyle = Tk.StringVar()
    self.radio_buffer_linestyle = Tk.StringVar()
    self.main_symbol_shape = Tk.StringVar()
    self.buffer_symbol_shape = Tk.StringVar()
    self.graph_bg_color = Tk.StringVar()

    self.initpath = '.'  # for File Dialog directory
    self.current_path = ''
    self.buildCommands()
    self.setMenus()

</t>
<t tx="tom.20211207165051.80">@REQUIRE_MAIN
def integrate(self):
    self.stack[MAIN].integrate()
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = ' Integral of %s' % (lab)
    self.plot()
</t>
<t tx="tom.20211207165051.81">@REQUIRE_MAIN
def absolute(self):
    self.stack[MAIN].absolute()
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = ' Absolute Value of %s' % (lab)
    self.plot()
</t>
<t tx="tom.20211207165051.82">@REQUIRE_MAIN
def square(self):
    self.stack[MAIN].square()
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = ' Square of %s' % (lab)
    self.plot()
</t>
<t tx="tom.20211207165051.83">@REQUIRE_MAIN
def rectify(self):
    self.stack[MAIN].ydata = [abs(y) for y in self.stack[MAIN].ydata]
    lab = self.stack[MAIN].figurelabel or ''
    lab += ' Rectified'
    self.stack[MAIN].figurelabel += lab
    self.plot()
</t>
<t tx="tom.20211207165051.84">@REQUIRE_MAIN
def half_rectify(self):
    self.stack[MAIN].ydata = [max(y, 0.) for y in self.stack[MAIN].ydata]
    lab = self.stack[MAIN].figurelabel or ''
    lab += ' Half Wave Rectified'
    self.stack[MAIN].figurelabel += lab
    self.plot()
</t>
<t tx="tom.20211207165051.85">@REQUIRE_MAIN
def clip(self):
    _id = 'clip'
    lastparm = self.parmsaver.get(_id, 1.0)
    dia = GetSingleFloat(self.root, 'Clipping Level',
                         'Clip', lastparm)
    if dia.result is None: return

    self.parmsaver[_id] = abs(dia.result)
    clip = abs(dia.result)
    _y = []
    for y in self.stack[MAIN].ydata:
        if y &gt;= 0:
            _y.append(min(y, clip))
        else:
            _y.append(-min(-y, clip))
    self.stack[MAIN].ydata = _y
    lab = self.stack[MAIN].figurelabel or ''
    lab += ' Clipped'
    self.stack[MAIN].figurelabel += lab
    self.plot()
</t>
<t tx="tom.20211207165051.86">@REQUIRE_MAIN
def decimate(self):
    _id = 'decimate'
    current = 12
    delta = self.parmsaver.get(_id, current)
    dia = GetSingleInt(self.root, 'Thin X Axis', 'Keep 1 in ', delta)
    if dia.result is None: return

    delta = dia.result
    self.parmsaver[_id] = delta

    _ds = self.stack[MAIN]
    lab = self.stack[MAIN].figurelabel or ''
    lab = '%s Thinned To One in %s' % (lab, delta)

    self.stack[MAIN] = _ds.thin(delta)
    self.stack[MAIN].figurelabel = lab

    self.plot()
</t>
<t tx="tom.20211207165051.87">@REQUIRE_MAIN
def trim(self):
    _id = 'trim'
    default = 0
    N = self.parmsaver.get(_id, default)
    dia = GetSingleInt(self.root, 'Trim Data', 'Integer # to Remove', N)
    N = dia.result or 0
    self.parmsaver[_id] = N

    _ds = self.stack[MAIN]
    if N &gt; 0:
        _ds.xdata = _ds.xdata[:-N]
        _ds.ydata = _ds.ydata[:-N]
    elif N &lt; 0:
        _ds.xdata = _ds.xdata[-N:]
        _ds.ydata = _ds.ydata[-N:]

    lab = self.stack[MAIN].figurelabel or ''
    lab = '%s Trimmed by %s' % (lab, N)
    self.stack[MAIN].figurelabel = lab

    self.plot()
</t>
<t tx="tom.20211207165051.88">@REQUIRE_MAIN
def log(self):
    success = self.stack[MAIN].log()
    if not success:
        self.announce("Data contains 0 or negative values - can't take its log")
        self.flashit()
        return
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = 'Natural Log of %s' % (lab)
    self.plot()
</t>
<t tx="tom.20211207165051.89">@REQUIRE_MAIN
def log10(self):
    success = self.stack[MAIN].log10()
    if not success:
        self.announce("Data contains 0 or negative values - can't take its log")
        self.flashit()
        return
    lab = self.stack[MAIN].figurelabel
    if lab:
        self.stack[MAIN].figurelabel = 'Log base 10 of %s' % (lab)
    self.plot()
</t>
<t tx="tom.20211207165051.9">def openAuxWin(self):
    if not self.hasToplevel():
        cmdwindow(self)

</t>
<t tx="tom.20211207165051.90">@REQUIRE_MAIN_BUFF
def mulBuffer(self):
    success = self.stack[MAIN].multiply(self.stack[BUFFER])
    if not success:
        self.announce("Number of data points differs (main: %s, buff: %s)"
                      "- can't multiply"
                      % (len(self.stack[MAIN].xdata),
                         len(self.stack[BUFFER].xdata)))
        self.flashit()
        return

    lab = self.stack[MAIN].figurelabel or ''
    lab1 = self.stack[BUFFER].figurelabel or ''
    if lab and lab1:
        self.stack[MAIN].figurelabel = '%s * %s' % (lab, lab1)
    else:
        self.stack[MAIN].figurelabel = 'Product'

    self.plot()
</t>
<t tx="tom.20211207165051.91">@REQUIRE_MAIN_BUFF
def divBuffer(self):
    '''Divide BUFFER by MAIN, pointwise. Return result in MAIN,
    and plot MAIN'''

    success = self.stack[MAIN].divide(self.stack[BUFFER])
    if not success:
        self.announce(
            "Zero in denominator or Number of data points differs"
            " (main: %s, buff: %s)- can't divide"
            % (len(self.stack[MAIN].xdata), len(self.stack[BUFFER].xdata)))
        self.flashit()
        return

    mainlab = self.stack[MAIN].figurelabel or ''
    bufflab = self.stack[BUFFER].figurelabel or ''
    if mainlab and bufflab:
        self.stack[MAIN].figurelabel = '%s / %s' % (bufflab, mainlab)
    else:
        self.stack[MAIN].figurelabel = 'Quotient'

    self.plot()
    if self.stack[MAIN].xdata != self.stack[BUFFER].xdata:
        self.announce('WARNING: The two data sets had different'
                      ' X-axis values')
        self.flashit()
</t>
<t tx="tom.20211207165051.92">@REQUIRE_MAIN_BUFF
def addBuffer(self):
    '''Add y data in the buffer to y data in the main data set,
    point by point. store the result in MAIN.  Plot the result.

    Assumes that the x values are the same for both sequences.
    The only check made is whether the length of both arrays is the same.
    If not, write a message and return without doing anything.
    '''

    _m = self.stack[MAIN]
    _b = self.stack[BUFFER]

    if len(_m) != len(_b):
        self.announce(
            'MAIN and BUFFER must have the same number of points '
            '(main: %s, buff: %s)'
            % (len(self.stack[MAIN].xdata),
               len(self.stack[BUFFER].xdata)))
        self.flashit()
        return

    if _m.isNumpyArray(_m.ydata):
        _my = _m.ydata.tolist()
    else:
        _my = _m.ydata

    if _b.isNumpyArray(_b.ydata):
        _by = _b.ydata.tolist()
    else:
        _by = _b.ydata

    result = []
    for n, _ in enumerate(_my):
        result.append(_my[n] + _by[n])

    _m.ydata = result

    lab = self.stack[MAIN].figurelabel or ''
    lab1 = self.stack[BUFFER].figurelabel or ''
    if lab and lab1:
        self.stack[MAIN].figurelabel = '%s + %s' % (lab, lab1)
    else:
        self.stack[MAIN].figurelabel = 'Sum'

    self.plot()
</t>
<t tx="tom.20211207165051.93">@REQUIRE_MAIN_BUFF
def subFromBuffer(self):
    '''subtract y data in the main data set from y data in thebuffer,
    point by point. store the result in MAIN.  Plot the result.

    Assumes that the x values are the same for both sequences.
    The only check made is whether the length of both arrays is the same.
    If not, write a message and return without doing anything.
    '''

    _m = self.stack[MAIN]
    _b = self.stack[BUFFER]

    if len(_m) != len(_b):
        self.announce(
            'MAIN and BUFFER must have the same number of points '
            '(main: %s, buff: %s)'
            % (len(self.stack[MAIN].xdata),
               len(self.stack[BUFFER].xdata)))
        self.flashit()
        return

    if _m.isNumpyArray(_m.ydata):
        _my = _m.ydata.tolist()
    else:
        _my = _m.ydata

    if _b.isNumpyArray(_b.ydata):
        _by = _b.ydata.tolist()
    else:
        _by = _b.ydata

    _m.ydata = [y - x for x, y in zip(_my, _by)]

    lab = self.stack[MAIN].figurelabel or ''
    lab1 = self.stack[BUFFER].figurelabel or ''
    if lab and lab1:
        self.stack[MAIN].figurelabel = '%s - %s' % (lab1, lab)
    else:
        self.stack[MAIN].figurelabel = 'Difference'

    self.plot()

    # return _m, suby
</t>
<t tx="tom.20211207165051.94">@REQUIRE_MAIN
def convolveWithBuffer(self):
    self.stack[MAIN].convolve(self.stack[BUFFER])

    lab = self.stack[MAIN].figurelabel or ''
    lab1 = self.stack[BUFFER].figurelabel or ''
    if lab:
        self.stack[MAIN].figurelabel = 'Convolution of %s' % (lab)
        if lab1:
            self.stack[MAIN].figurelabel += ' with %s' % (lab1)
    else:
        self.stack[MAIN].figurelabel = 'Convolution'

    self.plot()
</t>
<t tx="tom.20211207165051.95">@REQUIRE_MAIN
def correlateWithBuffer(self):
    self.stack[MAIN].correlate(self.stack[BUFFER])

    lab = self.stack[MAIN].figurelabel or ''
    lab1 = self.stack[BUFFER].figurelabel or ''
    if lab:
        self.stack[MAIN].figurelabel = 'Correlation of %s' % (lab)
        if lab1:
            self.stack[MAIN].figurelabel += ' with %s' % (lab1)
    else:
        self.stack[MAIN].figurelabel = 'Correlation'

    self.plot()
</t>
<t tx="tom.20211207165051.96">@REQUIRE_MAIN
def autocorrelate(self):
    self.stack[MAIN].correlate(self.stack[MAIN])

    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        self.stack[MAIN].figurelabel = 'Autocorrelation of %s' % (lab)
    else:
        self.stack[MAIN].figurelabel = 'Autocorrelation'

    self.plot()
</t>
<t tx="tom.20211207165051.97">@REQUIRE_MAIN
def lopass(self):
    _id = 'lopass'
    lastparm = self.parmsaver.get(_id, 5.0)

    dia = GetSingleFloat(self.root, 'Time constant in units of dt',
                         'Tau', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    if self.stack[MAIN].lopass(dia.result):
        lab = self.stack[MAIN].figurelabel or ''
        if lab:
            lab = 'Low Pass Filter of %s' % (lab)
        else:
            lab = 'Low Pass Filter'
        self.stack[MAIN].figurelabel = lab

        self.plot()
    else:
        self.announce('tau  &lt;= 0.0 or no data')
        self.flashit()
</t>
<t tx="tom.20211207165051.98">@REQUIRE_MAIN
def hipass(self):
    _id = 'hipass'
    lastparm = self.parmsaver.get(_id, 5.0)
    _LIMIT = 0.1

    dia = GetSingleFloat(self.root, 'Time constant in units of dt',
                         'Tau', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    if self.stack[MAIN].hipass(dia.result, _LIMIT):
        lab = self.stack[MAIN].figurelabel or ''
        if lab:
            lab = 'High Pass Filter of %s' % (lab)
        else:
            lab = 'High Pass Filter'
        self.stack[MAIN].figurelabel = lab

        self.plot()
    else:
        self.announce('tau  &lt;= %s or no data' % _LIMIT)
        self.flashit()
</t>
<t tx="tom.20211207165051.99">@REQUIRE_MAIN
def moving_median(self):
    _id = 'moving_median'
    lastparm = self.parmsaver.get(_id, 5)

    dia = GetSingleInt(self.root, 'Window Width (odd)',
                         'Width', lastparm)
    if dia.result is None: return
    self.parmsaver[_id] = dia.result

    _x = self.stack[MAIN].xdata
    _y = self.stack[MAIN].ydata

    self.stack[MAIN].xdata, self.stack[MAIN].ydata = \
        smoother.moving_median(_x, _y, dia.result)
    lab = self.stack[MAIN].figurelabel or ''
    if lab:
        lab = 'Moving Median of %s' % (lab)
    else:
        lab = 'Moving Median'
    self.stack[MAIN].figurelabel = lab

    self.plot()
</t>
<t tx="tom.20211207171026.1">COMMENTS = (';', '#')

ENCODING = 'utf-8'
# Special data import keyword
ENDDATASET = 'ENDDATASET'

</t>
<t tx="tom.20211207211642.1"></t>
<t tx="tom.20211207211739.1"></t>
<t tx="tom.20211207211946.1"></t>
<t tx="tom.20211207212159.1"></t>
<t tx="tom.20211207212931.1"></t>
<t tx="tom.20211207213410.1"></t>
<t tx="tom.20211207213522.1"></t>
<t tx="tom.20211207213812.1"></t>
<t tx="tom.20211207213827.1"></t>
<t tx="tom.20211207214009.1"></t>
<t tx="tom.20211207214046.1"></t>
<t tx="tom.20211207214310.1"></t>
<t tx="tom.20211207214759.1"></t>
<t tx="tom.20211210160855.10">def test_lowess_adaptive_ac(func=None):
    '''Test Lowess Autocorrelation Adaptive Fit - lowessAdaptiveAC()'''

    N = 200
    if not func:
        func = lambda z: math.sin(z)*math.exp(-.2*z)
    x = [0.05*i for i in range(0, N)]
    y = [func(z) + 0.25*random.uniform(-.5, .5) for z in x]
    true_y = [func(z) for z in x]

    xi, yi, span, rms, ac, upperbound, lowerbound = lowessAdaptiveAC(x, y)

    rcParams['figure.figsize'] = 12, 8

    plt.plot(x, true_y, 'black', linewidth=2)
    plt.plot(x, y, 'co', mfc='white')
    plt.plot(xi, yi, 'black', linewidth=1)
    plt.title('LOWESS Autocorrelation Adaptive - smoothing parameter = %s, rms error = %0.3f'
        % (span, rms))
    plt.plot(xi, upperbound, 'red')
    plt.plot(xi, lowerbound, 'red')

    plt.title('LOWESS Autocorrelation Adaptive  span %s, autocorr %0.3f, rms %0.3f'
        % (span, ac, rms))

    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('+500+25')
    figure.set_size_inches((8, 6))
    figure.canvas.manager.set_window_title('Adaptive LOWESS with residual autocorrelation')
    plt.show()


@self_printer
</t>
<t tx="tom.20211210160855.11">def lstsqr():
    'Test Linear Least Squares'
    # pylint: disable = too-many-locals
    x = range(30)
    y_truth = x[:]

    REPS = 50
    SIGMA = 10.

    rcParams['figure.figsize'] = 14, 12
    eps_avg = []

    for rep in range(REPS):
        y = [yt + random.uniform(-SIGMA, SIGMA) for yt in y_truth]
        yf, mean, rms, r, upper, lower = leastsqr(x, y)
        plt.plot(x, yf, 'gray', linewidth=1, alpha=0.3)
        eps = [_upper - _fit for _upper, _fit in zip(upper, yf)]
        if not eps_avg:
            eps_avg = eps
        else:
            _temp = []
            for _prev, _eps in zip(eps_avg, eps):
                _temp.append(_prev + _eps)
            eps_avg = _temp

    eps2_avg = [_eps/REPS for _eps in eps_avg]
    upper_avg = [_y + _eps2 for _y, _eps2 in zip(y_truth, eps2_avg)]
    lower_avg = [_y - _eps2 for _y, _eps2 in zip(y_truth, eps2_avg)]

    plt.plot(x, upper_avg, 'gray', linewidth=1)
    plt.plot(x, lower_avg, 'gray', linewidth=1)
    plt.plot(x, y_truth, linewidth=3, label='Truth', color='black')

    plt.plot(x, y, 'ro', label='Data for Fitting Example')
    plt.plot(x, yf, 'blue', linewidth=2, label='Example Fitted Line')

    factor = 2*SIGMA / (REPS-2)**.5
    sig_upper = [_y + factor for _y in y_truth]
    sig_lower = [_y - factor for _y in y_truth]
    plt.plot(x, sig_upper, 'black', linewidth=2.5)
    plt.plot(x, sig_lower, 'black', linewidth=2.5)

    plt.title('Least Squares Fit,  r=%0.3f' % r)
    plt.legend()

    axes = gca()
    axes.fill_between(x, upper_avg, lower_avg, facecolor='gray', alpha=0.2)

    figure = gcf()
    figure.canvas.manager.window.wm_geometry('+600+50')
    figure.canvas.manager.set_window_title('Linear Least Squares')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.12">def lowess2_mse(func=None):
    """Test LOWESS Adaptive Smoother: MSE with Roughness Penalty"""
    # pylint: disable = too-many-locals

    N = 200
    if not func:
        func = lambda z: math.sin(z)*math.exp(-.2*z) + \
            0.25*random.uniform(-.5, .5)
    x = [0.05*i for i in range(0, N)]
    y = [func(z) for z in x]

    smooth = (3, 5, 10, 15, 20, 25, 30, 40, 60, 80)
    mse = []
    rough = []
    for s in (s1 for s1 in smooth if s1 &lt;= N):
        xi, yi, r, upperbound, lowerbound = lowess2(x, y, s, True)
        mse.append(r)

        xp, dy = deriv(xi, yi)
        xpp, ddy = deriv(xp, dy)
        roughness = 0
        delx = (max(xpp) - min(xpp)) / len(xpp) # mean spacing
        for i in range(len(xpp)):
            roughness += delx * sqr(ddy[i])
        rough.append(roughness)

    mean_rough = 0
    for i in rough:
        mean_rough += i
    mean_rough = mean_rough / len(rough)

    mean_mse = 0
    for i in mse:
        mean_mse += i
    mean_mse = mean_mse / len(mse)

    rough_scale_factor = mean_mse / mean_rough

    penalty = []
    weight = .1
    for i, _ in enumerate(mse):
        penalty.append(mse[i] + rough[i] * rough_scale_factor * weight)

    print ('Span\tMSE\tRough\tPenalty')
    for i, _ in enumerate(smooth):
        #print ('%0.3f\t%0.3f\t%0.2f\t%0.3f' \)
            #% (smooth[i], mse[i], rough[i], penalty[i])
        print ('{:.3f}\t{:.3f}\t{:.2f}\t{:.3f}'.format(smooth[i], mse[i], rough[i], penalty[i]))

    bestindex = penalty.index( min(penalty))
    best = smooth[bestindex]
    print ( '\nBest:')
    print ( 'Span\tMSE\tRough\tPenalty')
    print ( '%s\t%0.3f\t%0.3f\t%0.3f' % \
        (best, mse[bestindex], rough[bestindex], penalty[bestindex]))
    print()

    xi, yi = lowess(x, y, best, False)

    rcParams['figure.figsize'] = 12, 10
    plt.subplot(2, 1, 2)
    plt.plot(xi, y, 'bo')
    plt.plot(xi, yi, 'b')
    plt.title('LOWESS Adaptive Smooth For Least Roughness - Span %s, MSE %0.3f' % \
                (best, mse[bestindex]))

    figure = gcf()
    figure.canvas.manager.window.wm_geometry('+600+50')
    figure.canvas.manager.set_window_title('LOWESS Adaptive Smooth using Lowess/MSE')

    plt.show()


@self_printer
</t>
<t tx="tom.20211210160855.13">def test_adaptive_lowess(w):
    'Test lowessAdaptive()'
    N = 200
    func = lambda z: math.sin(z)*math.exp(-.2*z)
    x = [0.05*i for i in range(0, N)]
    true_y = [func(z) for z in x]
    y = [_y + 0.25*random.uniform(-.5, .5) for _y in true_y]

    weight = float(w)
    xf, yf, span, mse, upperbound, lowerbound = lowessAdaptive(x, y, weight)
    print ('Best Span: %s, weight param: %s' % (span, w))

    rcParams['figure.figsize'] = 12, 8
    rcParams['figure.facecolor']= 'lightgrey'

    plt.plot(x, true_y, 'black', linewidth=2)
    plt.plot(x, y, 'co', mfc='white')
    plt.plot(xf, yf, 'black', linewidth=1)
    plt.title('LOWESS Autocorrelation Adaptive - smoothing span = %s, rms error = %0.3f'
        % (span, mse**0.5))
    plt.plot(xf, upperbound, 'red')
    plt.plot(xf, lowerbound, 'red')

    ax = gca()
    ax.fill_between(xf, upperbound, lowerbound, facecolor='red', alpha=0.1)


    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('+500+25')
    figure.canvas.manager.set_window_title('LOWESS Linear Adaptive Smoothing')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.14">def lowess_smooth_quad():
    'Test LOWESS Quadratic Smoother'

    N = 200
    x = [0.05*i for i in range(0, N)]
    true_y = [math.sin(z)*math.exp(-.2*z) for z in x]
    y = [_y + random.gauss(0, .2) for _y in true_y]

    rcParams['figure.figsize'] = 12, 9
    plt.style.use(STYLE)

    smooths = 10, 15, 20, 30, 45, 60
    for s in smooths:
        xs, ys, mse, upperbound, lowerbound = lowess2Quad(x, y, s)
        plt.plot(x, ys, 'blue', linewidth=1)

    plt.title('Smoothing with LOWESS Quadratic - smoothing parameter = %s, mse = %0.3f'
            % (s, mse), fontsize=13)
    plt.plot(x, y, 'wo', mew=.2, mec='black')
    plt.plot(x, true_y, 'black', linewidth=2)
    plt.plot(x, upperbound, 'gray', linewidth=1)
    plt.plot(x, lowerbound, 'gray', linewidth=1)
    ax = gca()
    ax.fill_between(x, upperbound, lowerbound, facecolor='blue', alpha=0.1)

    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('+500+25')
    figure.set_size_inches((8, 6))
    figure.canvas.manager.set_window_title('LOWESS Quadratic Smoothing')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.15">def slope_var():
    """Calculate mean and standard deviation of least-square slope."""
    # pylint: disable = too-many-locals

    SLOPE = 1.0
    SAMPLES = 100
    SIGMA = 1.0
    N = 100 # number of points in any one data set

    A = []  # Holds slope values

    # x will range from 0 to 1
    # y data will be the gaussian noise added to a ramp
    # with slope SLOPE

    for i in range(SAMPLES):
        _xdata, _ydata = gaussian_vals(0.0, SIGMA, N)
        _xdata = [1.0*x/N for x in _xdata]
        _ydata = [_ydata[i] + SLOPE*_xdata[i] for i in range(len(_xdata))]

        Sx = 0.0 # sum of x
        Sy = 0.0 # sum of y
        Sxy = 0.0 # sum of xy
        Sxx = 0.0 # sum of xx
        Syy = 0.0 # sum of yy

        for j, _ in enumerate(_xdata):
            xtemp = _xdata[j]
            ytemp = _ydata[j]
            Sx = Sx + xtemp
            Sy = Sy + ytemp
            Sxy = Sxy + xtemp * ytemp
            Sxx = Sxx + xtemp**2
            Syy = Syy + ytemp**2

        # y = ax + b for linear fit
        a = (N * Sxy - Sx*Sy)/(N * Sxx - sqr(Sx))
        #b = (Sy - a*Sx)/N
        A.append(a)

    a_mean = sum(A) / SAMPLES
    a_var = sum([(z - a_mean)**2 for z in A]) / (SAMPLES-1)
    a_sig = a_var ** 0.5

    # Wikipedia formula for variance of slope
    # https://en.wikipedia.org/wiki/Simple_linear_regression#Numerical_properties
    # var = var(y) / sum((x - xmean)^2)
    xmean = sum(_xdata) / N
    xsqr = sum([(z - xmean)**2 for z in _xdata])
    var_wiki = SIGMA**2 / xsqr
    sig_wiki = var_wiki ** 0.5

    if a_sig &lt; 0.01:
        sd_str = '%0.2e' % a_sig
    else:
        sd_str = '%0.3f' % a_sig
    print ('mean: %0.3f   s.d.: %s    wikipedia formula s.d.: %0.3f' % (a_mean, sd_str, sig_wiki))

    for k, _ in enumerate(A):
        a = A[k]
        plt.plot(k+1, a, 'bo')
    plt.plot([0,SAMPLES], [a_mean, a_mean], 'black', linewidth=2)
    plt.plot([0, SAMPLES], [a_mean+a_sig, a_mean+a_sig], 'gray')
    plt.plot([0, SAMPLES], [a_mean-a_sig, a_mean-a_sig], 'gray')
    plt.title('Fitted Slope for Data Sigma = %0.2f, Data Length = %s' % (SIGMA, N))

    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('+600+50')
    figure.set_size_inches((8, 6))
    figure.canvas.manager.set_window_title('Least Squares Slopes')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.16">def test_thiel():
    N = 50
    DELTA = 1.
    MU = 0
    SIGMA = 2

    XDATA = [x*DELTA for x in range(0,N)]
    YDATA = [x + gauss(MU, SIGMA) for x in XDATA]
    x1 = int(N//4)
    x2 = int(N - x1)
    YDATA[x1] = YDATA[x1] + 10*SIGMA
    YDATA[x2] = YDATA[x2] + 15*SIGMA

    fitted, slope, intercept, sd = thiel_sen(XDATA, YDATA)

    plt.plot(XDATA, YDATA, 'gray')
    plt.plot(XDATA, fitted)
    plt.title('Thiel-Sen Robust Fitted Line')
    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.17">def test_lowess_devs():
    N = 50
    DELTA = 1.
    MU = 0
    SIGMA = 2
    SMOOTHZONE=10

    XDATA = [x*DELTA for x in range(0,N)]
    YBASE = [N*(x/N)**2 for x in XDATA]
    YDATA = [y + gauss(MU, SIGMA) for y in YBASE]

    xi, fitted, mse, upperbound, lowerbound = lowess2(XDATA, YDATA, SMOOTHZONE, False)

    var = sum([(_y - _yfit)**2 for _y, _yfit in zip(YDATA,YBASE)]) / (N-1)
    sd = var**0.5
    print ('routine-estimated mse: %0.3g   actual sd : %0.3g' \
            % (mse, sd))

    err_bounds_width = 0.5*sum([_upper - _lower for \
            _upper, _lower in zip(upperbound, lowerbound)]) / N
    print ('mean half-width of error band: %0.3g' % (err_bounds_width))

    plt.plot(XDATA, YDATA, 'gray')
    plt.plot(XDATA, fitted, 'blue')
    plt.plot(XDATA, YBASE, 'black', linewidth=2)
    plt.plot(XDATA, upperbound, 'lightgrey')
    plt.plot(XDATA, lowerbound, 'lightgrey')

    axes = gca()
    axes.fill_between(XDATA, upperbound, lowerbound, facecolor='lightgrey', alpha=0.2)

    plt.title('Lowess2 Smooth')
    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.18">def stdErrOfFit():
    """Test the standard error of a lowess fit.
  Estimated SE -- Standard error of fitted point relative to average
                  of the fitted points at mid-span.
  Actual SE --    Standard error calculated using reported fitted points
                  and the actual (before noise) data point at mid-span.
  avg reported se -- Average of standard error as returned by LOWESS.
  """
    # pylint: disable = too-many-locals

    N = 150
    DELTA = 1.
    MU = 0
    SIGMA = 30
    SMOOTHZONE=13

    XDATA = [x*DELTA for x in range(0,N)]
    YBASE = [N*(x/N)**3 for x in XDATA]

    REPS = 50
    fits = []
    reported_se = []
    # Fitted value in center of span
    fit_index = N/2
    for rep in range(REPS):
        YDATA = [y + gauss(MU, SIGMA) for y in YBASE]
        xi, fitted, mse, upperbound, lowerbound = lowess2(XDATA, YDATA, SMOOTHZONE, False)

        yfit = fitted[fit_index]
        fits.append(yfit)
        reported_se.append(mse)
        plt.plot(XDATA, fitted, 'gray', alpha=0.3)

    mean_fitted = sum(fits) / REPS
    _actual = YBASE[fit_index]
    var_fitted_est = sum([(_fitted - mean_fitted)**2 for _fitted in fits]) / (REPS - 1)
    var_fitted_true = sum([(_fitted - _actual)**2
            for _fitted in fits]) / (REPS - 1)
    se_est = var_fitted_est**0.5
    se_true = var_fitted_true**0.5
    avg_reported_se = sum(reported_se) / REPS

    print ('Estimated SE: {:.3g}  Actual SE: %{:3g}   avg reported se: {:.3g}'.format(se_est, se_true, avg_reported_se))

    se_bounds_upper = [_y + 2*avg_reported_se for _y in YBASE]
    se_bounds_lower = [_y - 2*avg_reported_se for _y in YBASE]

    plt.plot(XDATA, YBASE, 'black', linewidth=3, label='Ground Truth')
    plt.plot(XDATA, se_bounds_upper, 'black', label='2-sigma s.e. error bounds')
    plt.plot(XDATA, se_bounds_lower, 'black')
    plt.plot(XDATA, YDATA, 'red', label='Data for Smoothing Example')
    plt.plot(XDATA, fitted, 'blue', linewidth=1.7, label='One Example of a LOWESS Smooth')

    axes = gca()
    axes.fill_between(XDATA, se_bounds_upper, se_bounds_lower, facecolor='lightgrey', alpha=0.2)

    legend = plt.legend(loc='upper left', title='Plots')
    legend.get_title().set_fontsize('x-large')

    plt.title('Standard Error of LOWESS Fit for Smoothing Width = %s, Noise Sigma = %s'\
                % (SMOOTHZONE, SIGMA))
    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.19">def test_moving_median():
    """Test moving median smoothing."""

    N = 50
    DELTA = 1.
    MU = 0
    SIGMA = 2
    SMOOTHZONE= 7

    XDATA = [x*DELTA for x in range(0,N)]
    YBASE = [N*(x/N)**2 for x in XDATA]
    YDATA = [y + 2. * gauss(MU, SIGMA) for y in YBASE]

    xdata, smoothed = moving_median(XDATA, YDATA, SMOOTHZONE)

    assert len(xdata) == len(smoothed), f'{len(xdata)} != {len(smoothed)}'

    plt.plot(XDATA, YDATA, 'gray')
    plt.plot(xdata, smoothed)
    plt.title('Moving Median Smoothing')
    plt.show()
    
# ========================================================
Tests = (#lstsqr,
         #cspline_fit,
         #spline_smooth,
         lowess_smooth,
         #lowess2_smooth,
         lowess1_autocorr,
         #lowess2_mse,
         #lowess_smooth_quad,
         #lambda w=.5: test_adaptive_lowess(w),
         #test_lowess_adaptive_ac,
         #slope_var,
         #test_thiel,
         #test_lowess_devs,
         #stdErrOfFit,
         #test_moving_median,
        )

if __name__ == '__main__':
    for t in Tests:
        t()
</t>
<t tx="tom.20211210160855.3">import sys
import random
#from random import random as rand
from random import gauss
import math
import matplotlib.pyplot as plt

from pylab import rcParams, gcf, gca

try:
    from smoother import deriv
except ImportError:
    path = r'C:/Tom/devel/matplotlib/gf4'
    sys.path.append(path)
    from smoother import deriv

from smoother import sqr, lowess, lowess2Quad, thiel_sen
from smoother import lowess2, moving_median, cspline, splineSmooth, lowess1
from smoother import lowessAdaptiveAC, leastsqr, lowessAdaptive
from randnum import gaussian_vals


STYLE = 'ggplot'

plt.rcParams['figure.figsize'] = (12,9)
plt.rcParams['axes.grid'] = True
plt.rcParams['ytick.direction'] = 'out'
plt.rcParams['xtick.direction'] = 'out'

</t>
<t tx="tom.20211210160855.4">def self_printer(f):
    def new_f(*args):
        print()
        print ('Test:', f.__name__)
        if f.__doc__: print (f.__doc__)
        f(*args)
    return new_f

@self_printer
</t>
<t tx="tom.20211210160855.5">def cspline_fit():
    'Test Cubic Spline Fit'
    x = [0, 1, 2, 3, 4, 5, 6]
    y = [0, 2, 3, 1, 5, 6, 8]

    r, s = cspline(x, y)

    plt.plot(r,s,'black')
    plt.plot(x,y,'ro')
    plt.title('Cubic Spline Fit')
    figure = gcf()
    figure.canvas.manager.set_window_title('Cubic Spline Smooth')
    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.6">def spline_smooth():
    '''Test Spline Smoother'''

    N = 200
    x = [0.05*i for i in range(0, N)]
    true_y = [math.sin(z)*math.exp(-.2*z) for z in x]
    y = [_y + random.uniform(-.5, .5) for _y in true_y]

    rcParams['figure.figsize'] = 12, 10

    smooths =   (.01, .1, .5, .9)
    for p, s in enumerate(smooths):
        xi, yi = splineSmooth(x, y, s)
        plt.subplot(len(smooths), 1, p + 1)
        plt.plot(x, y, 'o', color='gray',)
        plt.plot(x, yi, 'black')
        plt.plot(x, true_y, 'gray', linewidth=2)
        plt.title(
            'Smoothing with spline - smoothing parameter = %s' \
            % (s))

    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('1200x900+600+50')
    #figure.canvas.manager.window.wm_geometry('+600+50')
    figure.canvas.manager.set_window_title('Spline Smooth')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.7">def lowess_smooth():
    'Test LOWESS Smoother lowess()'

    N = 200
    x = [0.05*i for i in range(0, N)]
    y = [math.sin(z)*math.exp(-.2*z) + random.uniform(-.5, .5) for z in x]

    rcParams['figure.figsize'] = 12, 12
    plt.style.use(STYLE)

    smooth = (10, 15, 20, 25, 30)
    for s, _ in enumerate(smooth):
        xi, yi = lowess(x, y, smooth[s])

        plt.subplot(len(smooth), 1, s+1)
        plt.plot(x, y, 'bo')
        plt.plot(xi, yi, 'g')
        plt.title('Smoothing with LOWESS - smoothing parameter = %s'
            % (smooth[s]))

    figure = gcf()
    #figure.canvas.manager.window.wm_geometry('+600+50')
    figure.canvas.manager.set_window_title('LOWESS Smooth')

    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.8">def lowess2_smooth():
    'Test LOWESS2 Smoother'

    N = 200
    x = [0.05*i for i in range(0, N)]
    true_y = [math.sin(z)*math.exp(-.2*z) for z in x]
    y = [_y + random.gauss(0, .2) for _y in true_y]

    rcParams['figure.figsize'] = 8, 6
    plt.style.use(STYLE)
    #ax = plt.gca()
    ax = gca()

    smooths = 10, 15, 20, 30, 45, 60
    for s in smooths:
        xs, ys, mse, upperbound, lowerbound = lowess2(x, y, s)
        plt.plot(x, ys, 'blue', linewidth=1)

    plt.plot(x, upperbound, 'gray', linewidth=1)
    plt.plot(x, lowerbound, 'gray', linewidth=1)
    ax.fill_between(x, upperbound, lowerbound, facecolor='blue', alpha=0.1)
    plt.title('Smoothing with LOWESS Linear - smoothing parameter = %s, mse = %0.3g'
        % (s, mse), fontsize = 13)

    plt.plot(x, true_y, 'black', linewidth=3)
    plt.plot(x, y, 'wo', mew=.2, mec='black')

    figure = gcf()
    figure.canvas.manager.set_window_title('LOWESS Smooth')
    plt.show()

@self_printer
</t>
<t tx="tom.20211210160855.9">def lowess1_autocorr(func=None):
    'Test LOWESS Adaptive Smoothing Using Residual Autocorrelations'

    N = 200
    if not func:
        func = lambda z: math.sin(z)*math.exp(-.2*z)

    x = [0.05*i for i in range(0, N)]
    y = [func(z) + 0.25*random.uniform(-.5, .5) for z in x]
    true_y = [func(z) for z in x]

    smooth = (5, 10, 15, 20, 25, 30, 40, 50, 60)
    param = []
    print( 'Span\tAutocorr')
    for s, _ in enumerate(smooth):
        xi, yi, r = lowess1(x, y, smooth[s])
        param.append((abs(r), smooth[s]))
        #print '%s\t%0.3f' % (smooth[s], r)
        print ('{}\t{:.3f}'.format(smooth[s], r))

    param.sort()
    rmin, sbest = param[0]

    print ( 'Best:')
    print ( 'Span\tAutocorr.')
    print ( '%(sbest)s \t%(rmin)0.3f' % (locals()))

    xi, yi, rms, upperbound, lowerbound = lowess2(x, y, sbest)

    #figure = gcf()
    #figure.set_size_inches(12, 8)
    rcParams['figure.figsize'] = 9, 7

    plt.plot(x, true_y, 'black', linewidth=2)
    plt.plot(x, y, 'co', mfc='white')
    plt.plot(xi, yi, 'black', linewidth=1)
    plt.title('LOWESS Autocorrelation Adaptive - smoothing parameter = %s, rms error = %0.3f'
        % (sbest, rms))
    plt.plot(xi, upperbound, 'red')
    plt.plot(xi, lowerbound, 'red')

    #figure.canvas.manager.set_window_title('LOWESS with residual autocorrelation')
    plt.show()

@self_printer
</t>
<t tx="tom.20211211170510.1"></t>
<t tx="tom.20211211170532.1"></t>
<t tx="tom.20211211170701.10">def setYlabel(self, label=''): raise NotImplementedError
</t>
<t tx="tom.20211211170701.11">def setFigureTitle(self, title=''): raise NotImplementedError
</t>
<t tx="tom.20211211170701.12">def setMenus(self): raise NotImplementedError
# can only call this after window has been defined
</t>
<t tx="tom.20211211170701.13">def setWindowTitle(self, title=''): raise NotImplementedError
</t>
<t tx="tom.20211211170701.14">def plot(self, stackposition=MAIN, clearFirst=True):
    raise NotImplementedError
</t>
<t tx="tom.20211211170701.15">def overplot(self, stackposition=MAIN): raise NotImplementedError
</t>
<t tx="tom.20211211170701.16">def overplotbuff(self): self.overplot(BUFFER)
</t>
<t tx="tom.20211211170701.17">def plotmain(self): self.plot(MAIN)
</t>
<t tx="tom.20211211170701.18">def plot_stack_top(self): self.plot(STACKDEPTH - 1)
</t>
<t tx="tom.20211211170701.19">def overplot_stack_top(self): self.overplot(STACKDEPTH - 1)
</t>
<t tx="tom.20211211170701.2"># pylint: disable = consider-using-f-string, undefined-variable
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170701.20">def load_data(self, stackpos=MAIN): raise NotImplementedError
</t>
<t tx="tom.20211211170701.21">def load_plot_data(self, fname, overplot=False):  raise NotImplementedError
</t>
<t tx="tom.20211211170701.22">def set_data(self, dataset, stackpos=MAIN):  raise NotImplementedError
</t>
<t tx="tom.20211211170701.23">def save_data(self, saveas=True): raise NotImplementedError
</t>
<t tx="tom.20211211170701.24">def swap_data(self): raise NotImplementedError
</t>
<t tx="tom.20211211170701.25">def push_data(self, dataset):
    for n in range(len(self.stack)-1, 0, -1):
        self.stack[n] = self.stack[n-1]
    self.stack[0] = dataset
</t>
<t tx="tom.20211211170701.26">def pop_data(self):
    for n in range(1,len(self.stack)):
        self.stack[n-1] = self.stack[n]
</t>
<t tx="tom.20211211170701.27">def setNum(self, n):
    self.num = int(n)
</t>
<t tx="tom.20211211170701.3">"""Base class for a PlotManager."""


from colors import *
from Dataset import Dataset

MAIN = 0; BUFFER = 1
STACKDEPTH = 3
ERRBAND_HI = 0; ERRBAND_LO = 1

</t>
<t tx="tom.20211211170701.4">class AbstractPlotManager:
    """AbstractPlotManager is defined to provide a concise definition of the
    interface for PlotManager.

    Typical usage for a concrete PlotManager -

    plotmgr = PlotManager()
    #...
    Tk.mainloop()
    """

    @others
</t>
<t tx="tom.20211211170701.5">def __init__(self, root=None):
    self.root = root
    self.axes = None
    self.figure = None
    self.canvas = None
    self.semilogY = False
    self.semilogX = False
    self.bgcolor = WHITE
    self.gridcolor=DEFAULTGRIDCOLOR
    self.stackdepth = STACKDEPTH
    # List of Dataset objects:
    self.stack = [Dataset() for i in range(self.stackdepth)]
    # Storage for one Dataset:
    self.storage = None
    # Default number of points for generated curves (integer):
    self.num = 256
    # Will hold a Tk Entry widget for single-line edits
    self.editWidget = None
    self.editableLabels = []
    self.parmsaver = {}
    self.commands = {}

    self.setupFigure()

</t>
<t tx="tom.20211211170701.6">def quit(self, event=None):
    self.root.destroy()

</t>
<t tx="tom.20211211170701.7">def setupFigure(self, title=''): raise NotImplementedError
</t>
<t tx="tom.20211211170701.8">def fix_ticks(self): raise NotImplementedError
</t>
<t tx="tom.20211211170701.9">def setXlabel(self, label=''): raise NotImplementedError
</t>
<t tx="tom.20211211170819.10">COLS = 6
BUTTONWIDTH = 9
BUTTON_BG = 'white'
BUTTON_HORIZ_BG = 'lightcyan'
BUTTON_RECORD_COLOR = 'RosyBrown3'

MACRO_TEXT = 'Record'
MACRO_FULLTEXT = 'Record Macro'

entry = None
is_recording = False
macro = ''
NEWFONT = None</t>
<t tx="tom.20211211170819.11">def click(event): 
    global is_recording, macro
    w = event.widget
    bg = w.cget('bg')
    w.config(relief='sunken', bg='cyan')
    w.flash()
    w.config(relief='raised', bg=bg)
    if w.cget('text') == MACRO_TEXT:
        if is_recording:
            is_recording = False
            w.config(bg = BUTTON_BG)
        else:
            w.config(bg=BUTTON_RECORD_COLOR)
            is_recording = True
            macro = ''

</t>
<t tx="tom.20211211170819.12">def on_enter(event):
    global entry
    global is_recording

    w = event.widget
    try:
        t = w.fulltext
        w.old_bg = w.cget('bg')
        entry.configure(text=t)
        if w.cget('text') != MACRO_TEXT:
            w.configure(bg='yellow')
        elif not is_recording:
            w.configure(bg='yellow')

    except Exception:
        pass

</t>
<t tx="tom.20211211170819.13">def on_leave(event):
    global entry
    global is_recording

    w = event.widget
    _bg = w.old_bg
    entry.configure(text='')
    if w.cget('text') != MACRO_TEXT:
        w.configure(bg=_bg)
    else:
        if not is_recording:
            w.configure(bg=BUTTON_BG)

</t>
<t tx="tom.20211211170819.14">def default_command(cmd, plotmgr=None):
    global is_recording, macro
    if is_recording:
        macro += '\n' + cmd
    if plotmgr:
        plotmgr.interpret(cmd)
    else:
        print (cmd)

</t>
<t tx="tom.20211211170819.15">def play_macro(plotmgr):
    global macro
    if plotmgr:
        plotmgr.runMacro(macro)
    else:
        print ('Run Macro:')
        print (macro)

</t>
<t tx="tom.20211211170819.16">def clear_macro():
    global macro
    macro = ''

</t>
<t tx="tom.20211211170819.17">def configure_button_list(parent, button_list, plotmgr):
    global NEWFONT
    for b in button_list:
        if b is SPACER:
            #Tk.Frame(parent, height=2, relief='sunken',  bg='black').pack(fill=Tk.BOTH)
            ttk.Separator(parent, style='gf.TSeparator').pack(fill=Tk.BOTH)
        else:
            text, cmd, fulltext = b
            _b = Tk.Button(parent, text=text, relief='raised', width=BUTTONWIDTH, bg=BUTTON_BG,
                    font=NEWFONT, padx=2, 
                    command=lambda x=cmd: default_command(x, plotmgr))
            _b.pack(fill=Tk.X)
            _b.bind('&lt;Button-1&gt;', click)
            _b.bind('&lt;Enter&gt;', on_enter)
            _b.bind('&lt;Leave&gt;', on_leave)
            _b.fulltext = fulltext
            _b.cmd = cmd

</t>
<t tx="tom.20211211170819.18">def configure_horizontal_button_list(parent, button_list, plotmgr):
    global NEWFONT
    cols = 0
    for b in button_list:
        if cols % COLS == 0:
            _frame = Tk.Frame(parent, bd=1, relief='groove')
            _frame.pack(fill=Tk.BOTH)
        text, cmd, fulltext = b
        but = Tk.Button(_frame, text=text, width=BUTTONWIDTH+1, bg=BUTTON_HORIZ_BG,
                font=NEWFONT, 
                command=lambda x=cmd: default_command(x, plotmgr))
        but.pack(side='left')
        but.bind('&lt;Button-1&gt;', click)
        but.bind('&lt;Enter&gt;', on_enter)
        but.bind('&lt;Leave&gt;', on_leave)
        but.fulltext = fulltext
        but.cmd = cmd

        cols += 1

</t>
<t tx="tom.20211211170819.19">def configure_macro_buttons(parent, plotmgr):
    global NEWFONT
    global macro

    _frame = Tk.LabelFrame(parent, text='Macro', bd=3, bg='lightgrey')
    _frame.pack(fill=Tk.BOTH)

    but_record = Tk.Button(_frame, text=MACRO_TEXT, width=BUTTONWIDTH+1, 
                    bg=BUTTON_BG, font=NEWFONT)
    but_record.pack(side='left')
    but_record.bind('&lt;Button-1&gt;', click)
    but_record.bind('&lt;Enter&gt;', on_enter)
    but_record.bind('&lt;Leave&gt;', on_leave)
    but_record.fulltext = MACRO_FULLTEXT

    but_play = Tk.Button(_frame, text='Play', width=BUTTONWIDTH+1, 
                command=lambda x=plotmgr:play_macro(x), bg=BUTTON_BG, font=NEWFONT)
    but_play.pack(side='left')
    but_play.bind('&lt;Enter&gt;', on_enter)
    but_play.bind('&lt;Leave&gt;', on_leave)
    but_play.fulltext = 'Play Back Macro'

    but_clear = Tk.Button(_frame, text='Clear', width=BUTTONWIDTH+1, 
                    command=clear_macro, bg=BUTTON_BG, font=NEWFONT)
    but_clear.pack(side='left')
    but_clear.bind('&lt;Enter&gt;', on_enter)
    but_clear.bind('&lt;Leave&gt;', on_leave)
    but_clear.fulltext = 'Clear Macro'

</t>
<t tx="tom.20211211170819.2"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170819.20">def create_buttons_pack(host, plotmgr):
    # pylint: disable = too-many-locals
    # Custom font for smaller button font size
    global entry, NEWFONT

    &lt;&lt; Make new Tk font &gt;&gt;
    &lt;&lt; Set window  geometry &gt;&gt;
    &lt;&lt; Create Button Containers &gt;&gt;

    # Create Button Groups
    but_frame_1 = Tk.LabelFrame(cmd_frame, text='Plot', bd=3, bg='lightgrey')
    but_frame_1.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_1, PLOT_BUTTONS, plotmgr)

    but_frame_load = Tk.LabelFrame(but_frame_1, text='Load/Save', bd=3, bg='lightgrey')
    but_frame_load.pack(fill=Tk.BOTH)
    configure_button_list(but_frame_load, LOAD_BUTTONS, plotmgr)

    but_frame_2 = Tk.LabelFrame(cmd_frame,text='Stack', bd=3, bg='lightgrey')
    but_frame_2.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_2, STACK_BUTTONS, plotmgr)

    but_frame_curve = Tk.LabelFrame(cmd_frame, text='Curve', bd=3, bg='lightgrey')
    but_frame_curve.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_curve, CURVE_BUTTONS, plotmgr)

    but_frame_math = Tk.LabelFrame(cmd_frame, text='Math', bd=3, bg='lightgrey')
    but_frame_math.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_math, MATH_BUTTONS, plotmgr)

    but_frame_dp = Tk.LabelFrame(cmd_frame, text='Data Processing', bd=3, bg='lightgrey')
    but_frame_dp.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_dp, DATA_PROCESSING_BUTTONS, plotmgr)

    but_frame_win = Tk.LabelFrame(but_frame_dp, text='Windowing', bd=3, bg='lightgrey')
    but_frame_win.pack(fill=Tk.BOTH)
    configure_button_list(but_frame_win, WINDOW_BUTTONS, plotmgr)

    but_frame_trend = Tk.LabelFrame(but_frame_dp, text='Trend', bd=3, bg='lightgrey')
    but_frame_trend.pack(fill=Tk.BOTH)
    configure_button_list(but_frame_trend, TREND_BUTTONS, plotmgr)

    but_frame_fit = Tk.LabelFrame(cmd_frame, text='Fit', bd=3,  bg='lightgrey')
    but_frame_fit.pack(side=Tk.LEFT, fill=Tk.BOTH)
    configure_button_list(but_frame_fit, CURVE_FIT_BUTTONS, plotmgr)

    but_frame_smooth = Tk.LabelFrame(but_frame_fit, text='Smooth', bd=3, bg='lightgrey')
    but_frame_smooth.pack(fill=Tk.BOTH)
    configure_button_list(but_frame_smooth, SMOOTHER_FIT_BUTTONS, plotmgr)

    but_frame_stats = Tk.LabelFrame(but_frame_fit, text='Statistics', bd=3, bg='lightgrey')
    but_frame_stats.pack(fill=Tk.BOTH)
    configure_button_list(but_frame_stats, STATS_BUTTONS, plotmgr)

</t>
<t tx="tom.20211211170819.21">def cmdwindow(plotmgr=None):
    _geom = ''
    if plotmgr:
        win = Tk.Toplevel(plotmgr.root)
        win.transient(plotmgr.root)
        _geom = plotmgr.root.geometry()
    else:
        win = Tk.Tk()

    win.title("GF4 Commands")

    create_buttons_pack(win, plotmgr)
    win.update_idletasks()
    if plotmgr:
        plotmgr.root.update_idletasks()

    # Set initial window position in screen
    #win.geometry('+1250+100')

    if _geom:
        #902x670+182+182
        root_dims, root_xoffset, root_yoffset = _geom.split('+')
        root_width, root_height = root_dims.split('x')
        xoffset = int(root_xoffset) + int(root_width) + 5
        yoffset = int(root_yoffset)
        win.geometry(f'600x{root_height}')
        win.geometry('+%s+%s' %(xoffset, yoffset))
    else:
        win.geometry('600x700')

if __name__ == '__main__':
    cmdwindow(None)

#    not_dunder = lambda b: b[:2] != '__'

#    for b in dir(buttondefs):
#        if not_dunder(b) and b != 'SPACER':
#            #print b
#            for x in buttondefs.__dict__.get(b, None):
#                if x is not SPACER:
#                    pass #print '   ', '%s: %s' % (x[1], x[2])
#            #print 

    Tk.mainloop()
</t>
<t tx="tom.20211211170819.23">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170819.24">"""Color definitions for gf4."""

NEARBLACK = '0.2'; BLACK = 'black'; LIGHTGRAY = '0.95'; WHITE = 'white'
CYAN = 'cyan'; GRAY = 'gray'; MEDGRAY='0.6'; LIGHTBLUE = 'lightblue'
DEFAULTGRIDCOLOR = 'lightgrey'; CORNFLOWERBLUE = 'CornFlowerBlue'
DEEPSKYBLUE = 'deepskyblue'

# Grid color to use for various background colors
ColorBgPairs = {
    CORNFLOWERBLUE:  (0.529,  0.376,  0.376),
    DEEPSKYBLUE: (0.529,  0.376,  0.376),
    LIGHTBLUE: MEDGRAY,
    BLACK: LIGHTGRAY,
    WHITE: DEFAULTGRIDCOLOR
}
</t>
<t tx="tom.20211211170819.26"># pylint: disable = consider-using-f-string, undefined-variable
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170819.27">try:
    import Tkinter as Tk
except:
    import tkinter as Tk

from Linestyle import (LINETHIN, LINEMED, LINETHICK, CIRCLE, DIAMOND,
                       HEXAGON, SQUARE, TRIANGLE, TRIANGLE_LEFT)
from colors import (WHITE, BLACK, LIGHTBLUE, DEEPSKYBLUE, CORNFLOWERBLUE,
                    MEDGRAY)

from help import about, tutorial

</t>
<t tx="tom.20211211170819.28">def setMenus(self):
    """Create the menus for gf4.

    This code was moved here from the main gf4.pyw file.  Since there is no 
    class involved here, the use of "self" seems strange.  But the calling
    object uses its own "self" value for the call.  Perhaps I should 
    have changed the name of the parameter, but this was easier since
    nothing needed to be changed in the code.
    
    ARGUMENT
    self -- the "self" variable of the calling object.

    RETURNS
    the menu structure.
    """
    # pylint: disable = too-many-locals
    # pylint: disable = too-many-statements
    # Create a toplevel menu
    mainMenu = Tk.Menu(self.root)

    @others

    return mainMenu
</t>
<t tx="tom.20211211170819.30"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170819.31">from __future__ import print_function

import math
import numpy as np
from scipy.stats import norm

</t>
<t tx="tom.20211211170819.32">def generateSine(n=256, cycles=5):
    '''Compute a sine wave with evenly spaced abscissa points.  
    Return a tuple of two arrays (xdata, ydata).

    ARGUMENTS
    n -- number of points to return
    cycles -- number of cycles across the n points

    RETURNS
    a tuple (xdata, ydata)
    '''

    delta = (2.0*cycles*math.pi)/(n-1)
    _x = []
    _y = []

    for i in range(n):
        _x.append(i)
        _y.append(math.sin(i*delta))

    return (_x, _y)

</t>
<t tx="tom.20211211170819.33">def generateSquarewave(n=256, cycles=5):
    '''Compute a square wave with evenly spaced abscissa points. 
    The waveform has an amplitude of 1, and is centered on 0.
    Return a tuple of two arrays (xdata, ydata).

    ARGUMENTS
    n -- number of points to return
    cycles -- number of cycles to return

    RETURNS
    a tuple (xdata, ydata)
    '''

    upper = 0.5
    lower = -0.5
    halfcycle = 0.5*n/cycles

    _x = []
    _y = []

    c = 0
    for i in range(n):
        _x.append(i)
        if c &lt; halfcycle:
            y = upper
        else:
            y = lower
        _y.append(y)

        c += 1
        if c &gt;= 2 * halfcycle:
            c = 0

    return (_x, _y)

</t>
<t tx="tom.20211211170819.34">def generateDampedSine(N=256, cycles = 5, decay=3.0):
    '''Compute a damped sine wave with evenly spaced abscissa points.  
    Return a tuple of two arrays (xdata, ydata).

    ARGUMENTS
    N -- number of points to return.
    cycles -- number of complete cycles.
    decay -- number of decay time constants across the entire curve

    RETURNS
    a tuple (xdata, ydata)
    '''

    _x, _y = generateSine(N, cycles)
    _expon = -decay /(N-1)

    _yd = [_y[n] * math.exp(_expon * n) for n in range(N)]
    
    return (_x, _yd)

</t>
<t tx="tom.20211211170819.35">def generateExponential(N=256, decay=3.0):
    '''Compute an exponential curve with evenly spaced abscissa points. 
    A positive decay parameter specifies decay, negative specifies 
    increase. Return a tuple of two arrays (xdata, ydata).

    ARGUMENTS
    N -- number of points to return.
    decay -- number of decay time constants across the entire curve

    RETURNS
    a tuple (xdata, ydata)
    '''

    _expon = -decay /(N-1)
    _x = []
    _y = []

    for i in range(N):
        _x.append(i)
        _y.append(math.exp(_expon * i))

    return (_x, _y)


</t>
<t tx="tom.20211211170819.36">def generateRectangle(N=256):
    '''Compute a rectangular waveform with evenly spaced points.
    Return a tuple of two arrays (xdata, ydata).

    ARGUMENT
    N -- number of points to return.

    RETURNS
    a tuple (xdata, ydata)
    '''

    _x = range(N)
    _y = [1.0 for i in range(N)]
    _y[0] = 0

    return (_x, _y)

</t>
<t tx="tom.20211211170819.37">def generateRamp(N=256):
    '''Compute a linear ramp with evenly spaced points. Maximum
    amplitude is 1.0. Return a tuple of two arrays (xdata, ydata).

    ARGUMENT
    N -- number of points to return.

    RETURNS
    a tuple (xdata, ydata)
    '''

    _ydelta = 1.0 / (N - 1)
    _y0 = 0.0
    _x = range(N)
    _y = [_y0 + _ydelta * i for i in range(N)]

    return (_x, _y)
</t>
<t tx="tom.20211211170819.38">def generateGaussian(N=256, m=0.0, sigma=128): 
    '''Compute a Gaussian probability curve.  Return a tuple of two arrays
    (xdata, ydata).

    ARGUMENTS
    N -- number of points.  If not odd, the curve won't be exactly symmetrical
         around the mean.
    m -- mean of the distribution.
    sigma -- the standard deviation value of the distribution.

    RETURNS
    a tuple of lists (xdata, ydata)
    '''

    _half = N / 2
    lower = -_half + m
    upper = _half + m
    if N % 2 == 1:
        upper += 1

    _range = np.arange(lower, upper, 1)
    #_sig = _half / sigma
    _gauss = norm.pdf(_range, m, sigma)

    _ydata = _gauss.tolist()
    _xdata =_range.tolist()

    return _xdata,_ydata

</t>
<t tx="tom.20211211170819.39">def generateGaussianCdf(N=256, m=0.0, sigma=128): 
    '''Compute a Gaussian probability curve.  Return a tuple of two arrays
    (xdata, ydata).

    ARGUMENTS
    N -- number of points.  If not odd, the curve won't be exactly symmetrical
         around the mean.
    m -- mean of the distribution.
    sigma -- the standard deviation value of the distribution.

    RETURNS
    a tuple of lists (xdata, ydata)
    '''

    _half = N / 2
    lower = -_half + m
    upper = _half + m
    if N % 2 == 1:
        upper += 1

    _range = np.arange(lower, upper, 1)
    #_sig = _half / sigma
    _gauss = norm.cdf(_range, m, sigma)

    _ydata = _gauss.tolist()
    _xdata =_range.tolist()

    return _xdata,_ydata

if __name__ == '__main__':
    import matplotlib.pyplot as plt

    def testGauss():
        N = 101
        m = 0.0
        sigma = 20.0
        x,y = generateGaussian(N, m, sigma)
        print ('data length:', len(x))
        plt.plot(x, y, 'g')
        plt.title('Gaussian Showing Mean, Sigma = %s, %s' % (m, sigma))
        plt.show()

    def testGaussCdf():
        N = 101
        m = 0.0
        sigma = 20.0
        x, y = generateGaussianCdf(N, m, sigma)
        print ('data length:', len(x))
        plt.plot(x, y, 'g')
        plt.title('Gaussian CDF Showing Mean, Sigma = %s, %s' % (m, sigma))
        plt.show()

    def runtests(testlist):
        for t in testlist:
            print ('Testing %s' % t.func_name)
            t()
            print()

    Tests = (testGaussCdf,)
    runtests(Tests)
    

</t>
<t tx="tom.20211211170819.4">def buildCommands(self):
    '''Create a dictionary of commands keyed by strings.
    Intended for use in macros and by an auxilary command
    window.
    '''

    self.commands = {
       'sine': self.makeSine,
       'dsin': self.makeDampedSine,
       'expon': self.makeExponential,
       'delta': self.makeDelta,
       'step': self.makeStep,
       'ramp': self.makeRamp,
       'sqw': self.makeSquarewave,

       'pdfgaus': self.pdfGaussian,
       'cdfgaus': self.cdfGaussian,
       'uninoise': self.makeUniformNoise,
       'gausnoise': self.makeGaussianNoise,

       'plot': self.plot,
       'plottop': self.plot_stack_top,
       'overplot': self.overplot,
       'overplotbuf': self.overplotbuff,
       'overplottop': self.overplot_stack_top,
       'overploterr': self.overplot_errorbands,

       'loadclip': self.load_data_from_popup,
       'save2clip': self.copy_data_to_clipboard,
       'stox': self.store1,
       'rclx': self.recall1,

       'linear': self.setLinLin,
       'semilogy': self.setSemilogY,
       'semilogx': self.setSemilogX,
       'loglog': self.setLogLog,

       'copy2buff': self.copyToBuffer,
       'swap': self.swap_data,
       'copyfrom': self.paste_data,
       'copyfromtop': self.copy_from_top,
       'copy2top': self.copy_to_top,
       'push': self.push_with_copy,
       'drop': self.drop_stack,
       'rotateup': self.rotate_stack_up,
       'rotatedn': self.rotate_stack_down,

       'dedup': self.dedup,
       'pad': self.pad_truncate,
       'shift': self.shift,
       'thin': self.decimate,
       'trim': self.trim, 
       'transpose': self.transpose,
       'sortx': self.sortX,
       'phase': self.make_phasespace,
       'YvsX': self.YvsX,
       'numpts': self.setNumPoints,
       'newX': self.replaceX,

       'addbuf': self.addBuffer,
       'subbuf': self.subFromBuffer,
       'mulbuf': self.mulBuffer,
       'divbuf': self.divBuffer,
       'diff': self.differentiate,
       'diff2': self.differentiate2,
       'int': self.integrate,
       'addcnst': self.add_constant,
       'scale': self.scale,
       'log': self.log10,
       'ln': self.log,
       'sqr': self.square,
       'rectify': self.rectify,
       'halfrect': self.half_rectify, 
       'clip': self.clip,
       'normalize': self.normalize,

       'cubicspln': self.cubicSpline,
       'lstsqrlin': self.leastsqr,
       'lstsqrquad': self.leastsqr_quad,
       'lowess': self.lowess,
       'lowessquad': self.lowess2Quad,
       'lowessadapt': self.lowess_adaptive,
       'lowesscorrel': self.lowess_adaptive_ac,
       'splinesmooth': self.spline_smooth,
       'poisson': self.poissonSmooth,
       'thiel_sen': self.thiel,

       'fft': self.fft,
       'convolve': self.convolveWithBuffer,
       'correl': self.correlateWithBuffer,
       'autocor': self.autocorrelate,
       'lopass': self.lopass,
       'hipass': self.hipass,
       'move-median': self.moving_median,

       'halfcoswin': self.h_cosine,
       'coswin': self.full_cosine,
       'halfsupergwin': self.h_super_gaussian,
       'gaussianwin': self.gaussian_window,
       'supergausswin': self.super_gaussian,

       'cdf': self.cdf,
       'fitcdf': self.fitCdfWithNormal,
       'fitcdfadapt': self.fitCdfNormalAdaptive,
       'hist': self.histogram,
       'meanstd': self.mean_std,
       'corrcoeff': self.correlationCoeff,
       'spearman': self.spearman,
       'pearson': self.pearson,
       'sliding_var': self.sliding_var,

       'mann_kendall': self.trend_mann_kendall,
       'piecewise': self.fit_piecewise,
       'timehack': self.addTimehack,
    }
</t>
<t tx="tom.20211211170819.6"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170819.7"># encoding: utf-8
'''Button definitions for GF4.  Format:
    (button label, command string, help message)
    
    The command string is sent to the command interpreter when the
    button is pressed.
    '''

SPACER = (None, None)

PLOT_BUTTONS = (
    ('Plot X', 'plot', 'Plot X'),
    ('Plot T', 'plottop', 'Plot Top'),
    SPACER, SPACER,
    ('Overplot X', 'overplot', 'Overplot X'),
    ('Overplot Y', 'overplotbuf', 'Overplot Y'),
    ('Overplot T', 'overplottop', 'Overplot Top'),
    SPACER, SPACER,
    ('Error Bands', 'overploterr', 'Overplot X Error Bands if any'),
    ('Timehack', 'timehack', 'Vertical Marker At Specified X Position'),
    SPACER, SPACER,
    ('Linear', 'linear', 'Linear Plot'),
    ('Semilog Y', 'semilogy', 'Semilog Plot on Y Axis'),
    ('Semilog X', 'semilogx', 'Semilog Plot on X Axis'),
    ('Loglog', 'loglog', 'Log-log Plot'),
)

LOAD_BUTTONS = (
    ('Load From\nDialog', 'loadclip', 'Load/Edit Data From Clipboard'),
    ('Copy To\nClipboard', 'save2clip', 'Save X Data To Clipboard'),
    ('Store 1', 'stox', 'Store X Dataset'),
    ('Recall 1', 'rclx', 'Recall Stored Data Set to X')
)

STACK_BUTTONS = (
    ('Copy2Y', 'copy2buff', 'Copy X to Y'),
    ('Copy2T', 'copy2top', 'Copy To Top from X'),
    ('Swap', 'swap', 'Swap X, Y'),
    SPACER, SPACER,
    ('Y → X', 'copyfrom', 'Copy From Y to X'),
    ('T → X', 'copyfromtop', 'Copy from Top to X'),
    SPACER, SPACER,
    ('Push', 'push', 'Copy X then Push Stack'),
    ('Drop', 'drop', 'Y -&gt; X'),
    ('Rot Up', 'rotateup', 'Rotate Stack Up'),
    ('Rot Down', 'rotatedn', 'Rotate Stack Down')
)

CURVE_BUTTONS = (
    ('Pad', 'pad', 'Pad or Truncate x Axis'),
    ('Shift', 'shift', 'Shift x Axis Left or Right'),
    ('Dedup', 'dedup', 'Delete Points With Value Equal To Previous Value'),
    ('Thin', 'thin', 'Thin x Axis (Reduce number of points)'),
    ('Trim', 'trim', 'Delete Points From Left Or Right of Data (negative ==&gt; left)'),
    ('Transpose', 'transpose', 'Transpose x and y axes'),
    ('SortX', 'sortx', 'Sort on x Axis'),
    ('PhaseSpc', 'phase', 'Create Phase Space Plot: y(t+1) vs y(t)'),
    ( 'Y vs X', 'YvsX', 'Plot y data of Y vs y data of X'),
    SPACER, SPACER,
    ('NumPts', 'numpts', 'Change/Set Number of Points When Generating Waveforms'),
    ('NewX', 'newX', 'Replace x Axis Values')
)

MATH_BUTTONS = (
    ('Y + X', 'addbuf', 'Add X values to Y: X + Y -&gt; X'),
    ('Y - X', 'subbuf', 'Subtract X values from Y: Y - X -&gt; X'),
    ('Y * X', 'mulbuf', 'Multiply X Values by Y: X*Y -&gt; X'),
    ('Y / X', 'divbuf', 'Divide X Values Into Y: Y / X -&gt; X'),
    SPACER, SPACER,
    ('Diff', 'diff', 'Differentiate X using one-sided differencing'),
    ('Central Diff', 'diff2', 'Differentiate X using central differencing'),
    ('Integrate', 'int', 'Integrate X'),
    SPACER, SPACER,
    ('Add Const', 'addcnst', 'Add Constant To Each Value'),
    ('Scale', 'scale', 'Scale: Multipy Each Value by a Constant'),
    ('Log 10', 'log', 'Replace values with their Logs Base 10'),
    ('Ln', 'ln',  'Replace values with their Natural Logs'),
    SPACER, SPACER,
    ('Square', 'sqr', 'Square Values'),
    ('Full Rectify', 'rectify', 'Full-wave Rectify Values'),
    ('Half Rectify', 'halfrect', 'Half-wave Rectify Values'),
    ('Clip', 'clip', 'Clip Values'),
    ('Normalize', 'normalize', 'Normalize curve values to 1.0')
)

CURVE_FIT_BUTTONS = (
    ('Cubic Spln', 'cubicspln', 'Fit Points with Cubic Spline'),
    ('Lst Sqr Lin', 'lstsqrlin', 'Fit Points with Linear Least Squares'),
    ('Lst Sqr Quad', 'lstsqrquad', 'Fit Points with Quadratic Using Least Squares'),
    ('Thiel-Sen', 'thiel_sen', 'Fit Line Robustly Using Thiel-Sen Method (median slopes)'),
    ('Piecewise', 'piecewise', 'Piecewise Linear Least Squares Fit'),
)

SMOOTHER_FIT_BUTTONS = (
    ('LOWESS Lin', 'lowess', 'Smooth Data with Linear LOWESS Fit'),
    #  ('LOW Quad', 'lowessquad', 'Smooth Data with 2nd Order LOWESS Fit'),
    ('LOW Adapt', 'lowessadapt', 'Smooth Data Adaptively with LOWESS: Find best span for a specified smoothness'),
    ('LOW Correl', 'lowesscorrel', 
        'Minimize Lag-1 Autocorrelation of Residuals: remove highest frequencies'),
    SPACER, SPACER,
    ('Poisson', 'poisson', 'Smooth Data Using Poisson Smooth: Assumes Data Are Poisson-distributed Counts'),
    SPACER, SPACER,
    ('Splin Smooth', 'splinesmooth', 'Smooth Data With Splines')
)

DATA_PROCESSING_BUTTONS = (
    ('FFT', 'fft', 'Calculate FFT of Data.  Data length need not be a power of 2'),
    ('Convolve', 'convolve', 'Convolve X Data with Y.  Y is unchanged'),
    ('Correl', 'correl', 'Correlate X Data with Y.  Y is unchanged'),
    ('Autocorr', 'autocor', 'Autocorrelation of X Data'),
    ('Low Pass', 'lopass', 'Low Pass Filter of X Data.  Time Constant is fraction of x axis'),
    ('Hi Pass', 'hipass','High Pass Filter of X Data.  Time Constant is fraction of x axis'),
    ('Moving Median', 'move-median', 'Moving Median of X Data')
)

WINDOW_BUTTONS = (
    ('Half Cosine', 'halfcoswin', 'Window Data With Half-Cosine Window'),
    ('Cosine', 'coswin', 'Window Data With Full Cosine Window'),
    ('Gaussian', 'gaussianwin', 'Window data with Gaussian'),
    ('Supergaussian', 'supergausswin', 'Window data with 6th order supergaussian'),
    ('Half SuperGauss', 'halfsupergwin', 'Window Data With 6th Order Supergaussian Window'),
)

STATS_BUTTONS = (
    ('CDF', 'cdf', 'Calculate CDF of X data'),
    ('Fit CDF', 'fitcdf', 'Calculate Normal CDF that Fits X Data'),
    ('CDF Adapt', 'fitcdfadapt', 'Fit a CDF in X to a Normal CDF, Adaptively'),
    ('Histogram', 'hist', 'Calculate Histogram of X Data'),
    SPACER, SPACER,
    ('Mean, STD', 'meanstd', 'Display Mean, Sample Standard Deviation, Lag-1 autocorrelation, and Area of X Data'),
    ('Corr Coeff', 'corrcoeff', "Calculate Correlation Coefficient Between X and Y"),
    ('Spearman', 'spearman', 'Calculate the Spearman Rank Correlation Coefficient between X and Y'),
    ('Pearson', 'pearson', "Calculate the Pearson's Correlation Coefficient r between X and Y"),
    SPACER, SPACER,
)

GENERATOR_BUTTONS = (
    ('Sine', 'sine', 'Generate Sine Wave.  Period is in multiples of x-axis length'),
    ('Damp Sin', 'dsin', 'Generate Damped Sine Wave.  Period is in multiples of x-axis length'),
    ('Expon', 'expon', 'Generate Decaying Exponential.  Time constant is in multiples of x-axis length'),
    ('Delta', 'delta', 'Generate Delta Function'),
    ('Step', 'step', 'Generate Rectangular Step'),
    ('Ramp', 'ramp', 'Generate Linear Ramp'),
    ('Square\nWave', 'sqw', 'Generate Square Wave'),
    ('Gaussian\nPDF', 'pdfgaus', 'Generate Gaussian PDF'),
    ('Gaussian\nCDF', 'cdfgaus', 'Generate Gaussian CDF'),
    ('Uniform\nNoise', 'uninoise', 'Generate Uniform Noise'),
    ('Gaussian\nNoise', 'gausnoise', 'Generate Gaussian Noise')
)

TREND_BUTTONS = (
    ('Mann-Kendall', 'mann_kendall', 'Compute Mann-Kendall Trend'),
    ('Windowed Dev', 'sliding_var', 'Standard Deviation In a Sliding Window'),
)
</t>
<t tx="tom.20211211170819.9">"""Auxilliary controller window for gf4."""

# pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170820.10">def setAsciiData(self, lines, filename=''):
    """
    &lt;&lt; docstring &gt;&gt;
    """

    # pylint: disable = too-many-branches
    &lt;&lt; init  &gt;&gt;

    for line in lines:
        &lt;&lt; process lines &gt;&gt;

    if _datalines:
        self.xdata = _x or [0]
        self.ydata = _y or [0]
    else:
        retval = 'Dataset: No data'
    return retval

</t>
<t tx="tom.20211211170820.11">def dedup(self):
    """Remove data point if its value equals the previous value."""
    dedup = []
    last = None
    for i, y in enumerate(self.ydata):
        if y != last:
            last = y
            dedup.append((self.xdata[i], y))
    self.xdata, self.ydata = zip(*dedup)

</t>
<t tx="tom.20211211170820.12">def data2String(self):
    '''Return dataset data as string.'''
    _data = ['%s\t%s' % (self.xdata[i], self.ydata[i]) for i in range(len(self.xdata))]
    _str = '\n'.join(_data)
    _header = ''
    if self.figurelabel:
        _header += ';; FIGURELABEL: %s\n' % (self.figurelabel)
    if self.xaxislabel:
        _header += ';; XLABEL: %s\n' % (self.xaxislabel)
    if self.yaxislabel:
        _header += ';; YLABEL: %s\n' % (self.yaxislabel)

    if self.parms:
        for parm, val in self.parms.items():
            _header += ';;%s: %s\n' % (parm, val)

    return _header + _str


</t>
<t tx="tom.20211211170820.13">def writeAsciiData(self, filename):
    if not filename: return

    try:
        with open(filename, 'w', encoding = ENCODING) as f:
            f.write(self.data2String())
    except Exception as e:
        print (e)

</t>
<t tx="tom.20211211170820.14">def isNumpyArray(self, a):
    return 'shape' in dir(a)

</t>
<t tx="tom.20211211170820.15">def pad_truncate(self, num):
    '''Change number of data points in data to num.  if num is &gt; than
    existing number of points, pad the end with zero for the y 
    values.  The padded values are they same type as the existing 
    ones (int or float).  The x values will be incremented by
    the mean x spacing.  This obviously makes most sense when the
    x values are evenly spaced.
    
    If num is &lt; existing number, then truncate the data.  If num
    is the same, do nothing.

    If num &lt; 1, do nothing

    ARGUMENT
    num -- the new number of points for the data.

    RETURNS
    nothing
    '''

    if num &lt; 1: return

    _len = len(self)
    if num == _len: return

    diff = num - _len
    if self.isNumpyArray(self.xdata):
        _x = self.xdata.tolist()
    else:
        _x = self.xdata[:]

    if self.isNumpyArray(self.ydata):
        _y = self.ydata.tolist()
    else:
        _y = self.ydata[:]

    if diff &gt; 0:
        xdelta = (max(_x) - min(_x)) /(_len - 1)
        nextx = _x[-1]
        if isinstance(_y[0], float):
            zero = 0.0
        else:
            zero = int(0)
        for i in range(diff):
            nextx += xdelta
            _x.append(nextx)
            _y.append(zero)
        self.xdata = _x
        self.ydata = _y
    else:
        self.xdata = _x[0:num]
        self.ydata = _y[0:num]
        
</t>
<t tx="tom.20211211170820.16">def shift(self, dist):
    '''Shift data along the X axis.  For a shift of 0 length, do nothing.

    ARGUMENT
    dist -- number of points to shift.  Positive means shift right.

    RETURNS
    nothing
    '''

    dist = int(dist)
    if dist == 0: return

    N = len(self.xdata)
    _y = [0] * N

    if dist &gt; 0:
        for i in range(dist, N):
            _y[i] = self.ydata[i - dist]
    else:
        for i in range(0, N + dist):
            _y[i] = self.ydata[i - dist]

    self.ydata = _y

</t>
<t tx="tom.20211211170820.17">def transpose(self):
    '''Swap X and Y data.'''
    temp = self.xdata
    self.xdata = self.ydata
    self.ydata = temp
    temp = self.yaxislabel
    self.yaxislabel = self.xaxislabel
    self.xaxislabel = temp

</t>
<t tx="tom.20211211170820.18">def sortX(self):
    '''Sort the data points in order of ascending x-axis values.'''

    temp = list(zip(self.xdata, self.ydata))
    temp.sort()
    self.xdata = [x for x,y in temp]
    self.ydata = [y for x,y in temp]
    self.figurelabel = self.figurelabel + '(sorted)'

</t>
<t tx="tom.20211211170820.19">def scale(self, c):
    '''Scale Y data point by point by a (floating point) constant.

    ARGUMENT
    c -- the constant to scale by

    RETURNS
    nothing
    '''

    self.ydata = [c*y for y in self.ydata]

</t>
<t tx="tom.20211211170820.2"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170820.20">def addConstant(self, c):
    '''Add a (floating point) constant to Y axis data,
    point by point.

    ARGUMENT
    c -- the constant to add

    RETURNS
    nothing
    '''

    self.ydata = [c + y for y in self.ydata]
  
</t>
<t tx="tom.20211211170820.21">def differentiate2(self):
    '''Differentiate the data, using central differencing (except at
    the ends, where we must use one-sided differencing).
    '''

    result = []
    _x = self.xdata
    _y = self.ydata
    N = len(_x)
    for i in range(N):
        if i == 0:
            delx = _x[1] - _x[0]
            dely = _y[1] - _y[0]
        elif i == N - 1:
            delx = _x[i] - _x[i - 1]
            dely = _y[i] - _y[i - 1]
        else:
            dely = float(_y[i + 1] - _y[i - 1])
            delx = float(_x[i + 1] - _x[i - 1])
        result.append(float(dely) / float(delx))

    self.ydata = result

</t>
<t tx="tom.20211211170820.22">def differentiate(self):
    '''Differentiate the data, using one-sided differencing.
    '''

    result = []
    _x = self.xdata
    _y = self.ydata
    N = len(_x)
    for i in range(1, N):
        delx = _x[i] - _x[i - 1]
        dely = _y[i] - _y[i - 1]
        result.append(float(dely) / float(delx))

    self.ydata = result
    self.xdata = _x[1:]


</t>
<t tx="tom.20211211170820.23">def integrate(self):
    '''Integrate the data, using the average of current and next 
    Y values at each step.  Note that we end up with one less point
    than we started with.
    '''

    result = []
    _x = self.xdata
    _y = self.ydata
    N = len(_x)

    sum = 0
    for i in range(N - 1):
        sum += 0.5*(_y[i+1] + _y[i]) * (_x[i+1] - _x[i])
        result.append(sum)
    
    self.ydata = result
    del(self.xdata[N-1])

</t>
<t tx="tom.20211211170820.24">def square(self):
    '''Square the y values of the data sequence.'''

    self.ydata = [y**2 for y in self.ydata]

</t>
<t tx="tom.20211211170820.25">def absolute(self):
    '''Absolute values of the y values of the data sequence.'''

    self.ydata = [abs(y) for y in self.ydata]

</t>
<t tx="tom.20211211170820.26">def log(self):
    '''Take the natural logarithm of the y values of the data sequence.
    If any of the values = 0.0, don't change the data, and return False,
    else change the data and return True.

    RETURNS
    False if any y values are &lt;= 0.0, True otherwise
    '''

    for y in self.ydata:
        if y &lt;= 0.0: return False

    self.ydata = [math.log(y) for y in self.ydata]
    return True

</t>
<t tx="tom.20211211170820.27">def log10(self):
    '''Take the logarithm base 10 of the y values of the data sequence.
    If any of the values = 0.0, don't change the data, and return False,
    else change the data and return True.

    RETURNS
    False if any y values are 0.0, True otherwise
    '''

    for y in self.ydata:
        if y &lt;= 0.0: return False

    self.ydata = [math.log(y, 10) for y in self.ydata]
    return True

</t>
<t tx="tom.20211211170820.28">def multiply(self, ds):
    '''Multiply each Y value by the corresponding Y value in another
    Dataset.  The two Datasets must have the same number of points, but
    the values of the X values are ignored and don't have to be the same.
    Do nothing if the number of points is not the same. Return False
    if the number of points doesn't match, or True otherwise.

    ARGUMENT
    ds -- the data set whose points will be used to multiply the Y data by.

    RETURNS
    False if the two Datasets have different lengths, otherwise True.
    '''

    if len(self.xdata) != len(ds.xdata): return False

    _y = self.ydata
    _y1 = ds.ydata
    self.ydata = [_y[v] * _y1[v] for v in range(len(_y))]
    return True

</t>
<t tx="tom.20211211170820.29">def divide(self, ds):
    '''Divide each Y value into the corresponding Y value in another
    Dataset.  That is, the other dataset will be the numerator.
    The two Datasets must have the same number of points, but
    the values of the X values are ignored and don't have to be the same.
    Do nothing if the number of points is not the same. Return False
    if the number of points doesn't match or if any point in the denominator
    dataset is zero, True otherwise. The denominator dataset has its
    y values changed.

    ARGUMENT
    ds -- the data set whose points will be used as the numerator.

    RETURNS
    False if the two Datasets have different lengths or the denominator
    contains a point with value 0.0, otherwise True.
    '''

    if len(self.xdata) != len(ds.xdata): return False

    _yd = self.ydata[:]
    if 0.0 in _yd: return False

    _yn = ds.ydata[:]
    num = len(self.xdata)
    self.ydata = [1.0 * _yn[v] / _yd[v] for v in range(num)]

    return True

</t>
<t tx="tom.20211211170820.3">from __future__ import print_function

import sys
import math
import copy
import numpy as np

ENCODING = 'utf-8'</t>
<t tx="tom.20211211170820.30">def rfft(self):
    '''Calculate the (amplitude of the) FFT of a real sequence.  The data
    is assumed to be equally spaced on the X axis.  Note that the number
    of points will be changed.'''

    self.ydata = np.abs(np.fft.rfft(self.ydata))
    # The maximum frequency is 0.5  / (delta_x)
    # The minimum frequency step is max / N = 0.5 / (n * delta_x)
    max_f = 0.5 / (self.xdata[1] - self.xdata[0])
    min_f = max_f / len(self.ydata)
    self.xdata = [(1 + i) * min_f for i in range(len(self.ydata))]
    #self.xdata = [i for i in range(len(self.ydata))]

</t>
<t tx="tom.20211211170820.31">def halfSupergaussian(self, order=6):
    '''Apply a half-sided supergaussian window to the ydata.
    The data is smoothly attenuated to the right, and unchanged at 
    the left end.  Return False if there is no data, else return True.

    The supergaussian is defined as exp(-(x/2s)^n),
     where n is the order (n=2 for an ordinary gaussian) (yes, I know,
     the numerical factor should by sqrt(2), but this doesn't change
     anything for our purposes).  The value of the windowing function 
     is here aribrarily defined  as 0.01 at the rightmost data point.

     ARGUMENT
     order -- the exponent for the supergaussian

     RETURNS
     False if no data, True otherwise.
    '''

    if not self.xdata:
        return False

    endstep = 0.01  # height of window at right edge
    numPts = len(self.xdata)

    sigma = 0.5 * (numPts-1) * math.exp(-math.log(-math.log(endstep))/order)
    _y = self.ydata
    self.ydata = [_y[i] * math.exp(-math.pow((0.5*i/sigma), order)) \
        for i in range(0,  numPts)]

    return True

</t>
<t tx="tom.20211211170820.32">def fullSuperGaussian(self, order=6):
    '''Apply a full gaussian window to the ydata.
    Return False if there is no data, else return True.

    The supergaussian is defined as exp(-(x/s*sqrt(2))^n)(yes, I know,
    the numerical factor should by sqrt(2), but this doesn't change
    anything for our purposes). 
    
    The value of the windowing function is here aribrarily defined  
    as 0.01 at the rightmost data point..

     ARGUMENT
     order -- the exponent for the supergaussian

     RETURNS
     False if no data, True otherwise.
    '''

    if not self.xdata:
        return False

    endstep = 0.01  # height of window at left and right edges.
    #sqrt2 = math.sqrt(2)
    numPts = len(self.xdata)
    mid = numPts / 2

    sigma = 0.5 * (numPts-1) * math.exp(-math.log(-math.log(endstep))/order)
    #s = sigma / sqrt2
    _y = self.ydata
    self.ydata = [_y[i] * math.exp(-math.pow(((i-mid)/sigma), order)) \
        for i in range(0,  numPts)]

    return True

</t>
<t tx="tom.20211211170820.33">def halfCosine(self):
    '''Apply a half-sided cosine window to the ydata.
    The data is smoothly attenuated to the right, and unchanged at 
    the left end.  Return False if there is no data, else return True.

     RETURNS
     False if no data, True otherwise.
    '''

    if not self.xdata:
        return False

    # Argument = pi/2 at right hand end of data
    N = len(self.ydata)
    delta = 0.5 * math.pi /(N-1)

    angle = 0.0
    _y = self.ydata
    for i in range(N):
        _y[i] = _y[i] * math.cos(angle)
        angle += delta

    return True

</t>
<t tx="tom.20211211170820.34">def fullCosine(self):
    '''Apply a cosine window to the ydata.
    The data is smoothly attenuated to the left and right, and 
    unchanged at the middle end.  Return False if there is no 
    data, else return True.

     RETURNS
     False if no data, True otherwise.
    '''

    if not self.xdata:
        return False

    # Argument ranges from -pi/2 to pi/2 
    N = len(self.ydata)
    delta = math.pi /(N-1)

    angle = -.5 * math.pi
    _y = self.ydata
    for i in range(N):
        _y[i] = _y[i] * math.cos(angle)
        angle += delta

    return True

</t>
<t tx="tom.20211211170820.35">def convolve(self, ds):
    '''Convolve the Y data with the Ydata of the Dataset passed in.
    Replace the Y data with the convolution values.  The length
    of the result is the longer of the two data sets.  Replace the 
    X data with the X data of the longer of the two data sets.     
    Return False if neither of the data sets has data.

    There can be boundary effects, since there may be areas where
    the two data sets don't overlap properly.

    ARGUMENT
    ds -- the other Dataset to use in the convolution.

    RETURNS
    False if either of the Datasets has no points, True otherwise.
    '''

    if (self.ydata is None or ds.ydata is None
       or len(self.ydata) == 0 or  len(ds.ydata) == 0):
        return False

    self.ydata = np.convolve(self.ydata, ds.ydata, mode='same')
    if len(self.xdata) != len(self.ydata):
        if len(self.xdata) == len(ds.xdata):
            self.xdata = ds.xdata[:]
        else:
            self.xdata = list(range(len(self.ydata)))

    return True

</t>
<t tx="tom.20211211170820.36">def correlate(self, ds):
    '''Correlate the Y data with the Ydata of the Dataset passed in.
    Replace the Y data with the convolution values.  The length
    of the result is the longer of the two data sets.  Replace the 
    X data with the X data of the longer of the two data sets.     
    Return False if neither of the data sets has data.

    Note that this operation is the signal processing kind of
    correlation, not a statistical type.  There can be boundary 
    effects, since there may be areas where the two data sets 
    don't overlap properly.

    ARGUMENT
    ds -- the other Dataset to use in the convolution.

    RETURNS
    False if either of the Datasets has no points, True otherwise.
    '''

    if self.isNumpyArray(self.ydata):
        if not self.ydata.any():
            return False
    elif self.isNumpyArray(ds.ydata):
        if not ds.ydata.any():
            return False
    else:
        if not self.ydata or not ds.ydata:
            return False

    self.ydata = np.correlate(self.ydata, ds.ydata, mode='same')
    if len(self.xdata) != len(self.ydata):
        if len(self.xdata) == len(ds.xdata):
            self.xdata = ds.xdata[:]
        else:
            self.xdata = list(range(len(self.ydata)))

    return True


</t>
<t tx="tom.20211211170820.37">def lopass(self, a):
    '''Perform a single-pole low-pass filter on the Y data of the
    data set. Return True if the value of a is &lt; 1.0 and the dataset
    has some points, False otherwise.
    
    The parameter a is a smoothing parameter, and equals
    t/d where t = the time constant (e.g., the RC time constant), 
    and d = the time step.  So a is the time constant in time steps.

    This filter emulates a simple RC circuit. 

    ARGUMENT
    a -- a smoothing parameter, must be &gt; 0.

    RETURNS
    True if the value of a is &lt; 0 and the dataset
    has some points,, False otherwise.

    '''
    
    if a &lt;= 0.0: return False
    if self.isNumpyArray(self.ydata):
        if not self.ydata.any():
            return False
    else:
        if not self.ydata:
            return False
    
    #aa = a / (1.0 + a)
    aa = math.exp(-1.0 / a)
    b = 1.0 - aa
    lasty = 0
    filtered = []
    for i in range(len(self.ydata[0:])):
        newy = aa * lasty + b * self.ydata[i]
        filtered.append(newy)
        lasty = newy

    self.ydata = filtered

    return True


</t>
<t tx="tom.20211211170820.38">def hipass(self, a, limit=0.1):
    '''Perform a single-pole high-pass filter on the Y data of the
    data set. Return True if the value of a is &lt; 1.0 and the dataset
    has some points, False otherwise.
    
    The parameter a is a smoothing parameter, and equals
    t/d where t = the time constant (e.g., the RC time constant), 
    and d = the time step.  So a is the time constant in time steps.

    This filter emulates a simple RC circuit.

    ARGUMENT
    a -- a smoothing parameter, must be &gt; 1.
    limit -- smallest allowed value for a

    RETURNS
    True if the value of a is &lt; limit and the dataset
    has some points, False otherwise.

    '''

    if a &lt; limit: return False
    if self.isNumpyArray(self.ydata):
        if not self.ydata.any():
            return False
    else:
        if not self.ydata:
            return False

    aa = math.exp(-1.0/a)
    lasty = 0
    lastyo = 0
    filtered = []
    for y in self.ydata:
        newy = aa * lasty + aa * (y - lastyo)
        filtered.append(newy)
        lasty = newy
        lastyo = y

    self.ydata = filtered

    return True

</t>
<t tx="tom.20211211170820.39">def var_ratio(self, w):
    '''Compute ratio of short-term to long-term variance.  Replace
    the Y data of the data set with the variance ratio.

    The long-term variance uses all the data from time t=0 to the 
    current point.  The short-term variance uses only the data from the 
    current point back to w steps earlier.

    ARGUMENT
    w -- width in x steps for the short-term data window.

    RETURNS
    False if the Dataset has no points, or w &lt; 2. True otherwise.
    '''

    if w &lt; 2: return False
    if self.isNumpyArray(self.ydata):
        if not self.ydata.any():
            return False
    elif not self.ydata:
        return False

    sy = 0.0
    syy = 0.0
    varlong = []

    for N, _y in enumerate(self.ydata):
        if N == 0:
            varlong.append(1.0)
            syy = math.pow(self.ydata[0], 2)
            sy = self.ydata[0]
            continue

        syy += _y * _y
        sy += _y
        var = syy / N - math.pow(sy / N, 2)
        varlong.append(max(var, 0.0))

    varshort = []

    for N in range(len(self.ydata)):
        if N == 0:
            varshort.append(1.0)
            continue
        if N &lt;= w:
            _dat = self.ydata[:N+1]
        else:
            _dat = self.ydata[N-w:N+1]
        sumshort = 0.0
        sumsqr_short = 0.0
        for _y in _dat:
            sumshort += _y
            sumsqr_short += math.pow(_y,2)
        _n = len(_dat) - 1
        var = sumsqr_short / _n - math.pow(sumshort / _n, 2)
        varshort.append(var)

    result = []
    for n, varl in enumerate(varlong):
        if varl &gt; 0.0:
            result.append(varshort[n] / varl)
        else:
            result.append(1.0)

    self.ydata = result

    return True

</t>
<t tx="tom.20211211170820.4">class Dataset:
    '''Class to represent a 2D curve.

    ATTRIBUTES
    xdata, ydata -- sequences holding the x or y data sets.  
                    Must be the same length.  May be lists or numpy
                    ndarrays.
    auxDataset -- dictionary of auxiliary data sets (e.g., for holding 
                  statistical information)
    errorBands -- List of Datasets to hold errors
    orig_filename -- file path, if any,  used to load data (before 
                     any transformations have been applied).
    xaxislabel -- label text for the X axis label
    yaxislabel -- label text for the Y axis label
    figurelabel -- label text for the graph of this data
    ymin -- minimum value for Y axis
    ymax -- maximum value for Y axis
    parms -- dictionary of parameters,  Meant to store the current values
             so they can be written to a file.
    '''
    # pylint: disable = too-many-public-methods
    @others
</t>
<t tx="tom.20211211170820.40">def var_ratio2(self, w):
    '''Compute ratio of short-term to long-term variance.  Replace
    the Y data of the data set with the variance ratio.

    The long-term variance uses all the data from time t=0 to the 
    current point.  The short-term variance uses only the data from the 
    current point back to w steps earlier.

    ARGUMENT
    w -- width in x steps for the short-term data window.

    RETURNS
    False if the Dataset has no points, or w &lt; 2. True otherwise.
    '''

    if w &lt; 2: return False
    if self.isNumpyArray(self.ydata):
        if not self.ydata.any():
            return False
    elif not self.ydata:
        return False

    sumlong = 0.0
    sumsqr_long = 0.0
    varlong = []

    for N in range(len(self.ydata)):
        if N == 0:
            varlong.append(1.0)
            continue
        sumlong = 0.0
        sumsqr_long = 0.0
        _dat = self.ydata[:N+1]
        for _y in _dat:
            sumlong += _y
            sumsqr_long += math.pow(_y, 2)
        _n = len(_dat) - 1
        var = sumsqr_long / _n - math.pow(sumlong / _n, 2)
        varlong.append(var)

    varshort = []

    for N in range(len(self.ydata)):
        if N == 0:
            varshort.append(1.0)
            continue
        if N &lt;= w:
            _dat = self.ydata[:N+1]
        else:
            _dat = self.ydata[N-w:N+1]
        sumshort = 0.0
        sumsqr_short = 0.0
        for _y in _dat:
            sumshort += _y
            sumsqr_short += math.pow(_y,2)
        _n = len(_dat) - 1
        var = sumsqr_short / _n - math.pow(sumshort / _n, 2)
        varshort.append(var)

    result = []
    for n, varl in enumerate(varlong):
        if varl &gt; 0.0:
            result.append(varshort[n] / varl)
        else:
            result.append(0.0)

    self.ydata = result

    return True

</t>
<t tx="tom.20211211170820.41">def sliding_var(self, w):
    '''Compute the variance of the y data over a window that slide across the data.
    The x value of the variance is assigned to be the center of the window. Return
    a sequence containing the computed standard deviations, and the s.d. of
    the entire data set.  There will be fewer points than for the original data.

    Assumes that the data points are equally spaced in the x axis.

    ARGUMENT
    w -- the window width in number of data points. Must be &lt; N - 3.

    RETURNS
    (x, s, stddev), where x, vare  sequences where x are the new x values 
    and s are the std devs in the window, or None if w is too large.
    '''

    N = len(self.xdata)
    if w &gt;= N - 3:
        return None

    newx = []
    vars = []
    delta = w * (self.xdata[1] - self.xdata[0]) / 2.0
    factor = 1.0 / (w - 1)

    for i in range(len(self.xdata) - w):
        _y = self.ydata[i:i+w]
        newx.append(self.xdata[i] + delta)
        mean = 1.0* sum(_y) / w
        var = sum([factor * (y - mean)**2 for y in _y]) 
        vars.append(var**0.5)

    mean = 1.0* sum(self.ydata) / N
    var = sum([(1.0 / (N-1)) * (y - mean)**2 for y in self.ydata]) 

    return newx, vars, var**0.5

</t>
<t tx="tom.20211211170820.42">def thin(self, stride=4):
    '''Thin a data set by keeping every nth point. Return the 
    original data set with the x and y data thinned.

    ARGUMENT
    stride -- an integer to thin by.

    RETURNS
    a new thinned data set
    '''

    xdata = self.xdata
    ydata = self.ydata

    new_xdata = []
    new_ydata = []
    for i in range(0, len(xdata), stride):
        new_xdata.append(xdata[i])
        new_ydata.append(ydata[i])

    self.xdata = new_xdata
    self.ydata = new_ydata
    return self
    
</t>
<t tx="tom.20211211170820.43">if __name__ == '__main__':
    import random 
    import matplotlib.pyplot as plt
    #from pylab import rcParams,  gcf

    passfail = {True:'Pass', False:'Fail'}
    base_xdata = [1,2,3,4,5,6,7,8,9,10]
    base_ydata = base_xdata[:]

    def self_printer(f):
        def new_f():
            print (f.func_name)
            print (f.func_doc or '')
            f()
            print()
        return new_f

    def test_pad():
        '''Test padding'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.pad_truncate(13)

        expected = ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0])
        if expected == (ds.xdata, ds.ydata):
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata, ds.xdata)
            print ('====Fail=====')
        print()

    def test_truncate():
        '''Test truncation'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.pad_truncate(3)

        expected = ([1, 2, 3],
                    [1, 2, 3])
        if expected == (ds.xdata, ds.ydata):
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print ((ds.ydata, ds.xdata))
            print ('====Fail=====')
        print()

    def shift_right():
        '''Test shifting right by 3'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.shift(3)

        expected = [0,0,0,1,2,3,4,5,6,7]
        if expected == ds.ydata:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata)
            print ('====Fail=====')
        print()

    def shift_left():
        '''Test shifting left by 3'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.shift(-3)

        expected = [4,5,6,7,8,9,10,0,0,0]
        if expected == ds.ydata:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata)
            print ('====Fail=====')
        print()

    def shift_right_many():
        '''Test shift right by too many points'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.shift(20)

        expected = [0,0,0,0,0,0,0,0,0,0]
        if expected == ds.ydata:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata)
            print ('====Fail=====')
        print()

    def test_scale():
        '''Test Scaling by factor 2'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.scale(2)

        expected = [2,4,6,8,10,12,14,16,18,20]
        if expected == ds.ydata:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata)
            print ('====Fail=====')
        print()

    def test_transpose():
        '''Test Transposing Axes'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.transpose()

        expected = (base_ydata, base_xdata)
        if expected == (ds.ydata, ds.xdata):
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print ((ds.ydata, ds.xdata))
            print ('====Fail=====')
        print()

    def test_add_constant():
        '''Test Adding constant 2.5 to Y axis data'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = base_ydata[:]
        ds.addConstant(2.5)

        expected = [2.5 + y for y in base_ydata]
        if expected == ds.ydata:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (ds.ydata)
            print ('====Fail=====')
        print()

    def test_halfsupergauss():
        '''Test half Supergaussian window of order 6'''
        ds = Dataset()
        _x = []; _y = []
        for i in range(20):
            _x.append(i)
            _y.append(1.0)
        _y[0] = 0.0

        ds.xdata = _x
        ds.ydata = _y

        ds.halfSupergaussian(6)
        print (''.join(['%0.4f\n' % (ds.ydata[i]) for i in range(len(ds.ydata))]))
        print()

    def test_supergauss():
        '''Test Supergaussian window of order 2'''
        ds = Dataset()
        _x = []; _y = []
        for i in range(100):
            _x.append(i)
            _y.append(1.0)
        #_y[0] = 0.0

        ds.xdata = _x
        ds.ydata = _y

        ds.fullSuperGaussian(2)
        print (''.join(['%0.4f\n' % (ds.ydata[i]) for i in range(len(ds.ydata))]))
        print()

    def test_len_method():
        '''Test len() function on Dataset'''

        ds = Dataset()
        passed = False

        ds.xdata = np.array([1,2,3])
        ds.ydata = [4,5,6]

        print ('  ds with data')
        print ('    if ds:', )
        passed = bool(ds)
        print (passfail[passed])
        print()

        ds.xdata = np.array([])
        passed = False
        print ('  Empty data array')
        print ('    if len(ds):', )
        if len(ds): passed = False
        else: passed =  True
        print (passfail[passed])
        print()

        ds = Dataset()
        print ('  New ds' )
        print ('    if ds:',)
        if ds: passed =  False
        else: passed =  True
        print (passfail[passed])
        print()

    def test_lopass():
        '''Test Low-pass filter lopass()'''
        ds = Dataset()
        ds.xdata = base_xdata[:]
        ds.ydata = [0,1,1,1,1,1,1,1,1,1]
        a = 5
        ds.lopass(a)
        results =  ','.join('%0.3f' % (x) for x in ds.ydata)
        expected = ','.join('%0.3f' % (x) for x in (0.000,0.181,
            0.330,0.451,0.551,0.632,0.699,0.753,0.798,0.835))
        if results == expected:
            print ('Pass')
        else:
            print ('Expected:')
            print (expected)
            print ('Actual:')
            print (results)
            print ('====Fail====')
        print()

    @self_printer
    def test_sliding_var():
        '''Sliding variances'''
        ds = Dataset()

        N = 100
        ds.xdata = x = [0.05*i for i in range(0, N)]
        ds.ydata = [random.uniform(-.5, .5) for z in x]

        _newx, stds, sigma = ds.sliding_var(15)

        plt.plot(_newx, stds, 'b')
        plt.plot(ds.xdata, ds.ydata, 'ro')
        plt.plot((ds.xdata[0], ds.xdata[-1]), (sigma, sigma), 'black')
        plt.show()

                                                   
    Tests = [test_halfsupergauss, test_supergauss]#test_sliding_var, test_lopass]
    for f in Tests:
        #print f.__doc__ or ''
        f()
</t>
<t tx="tom.20211211170820.45">"""A dialog with an editing pane, an accept button, and a cancel button.
When closed, returns the text of the editing pane or an empty string.
"""
# pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211170820.46">#import Tkinter as Tk
try:
    import Tkinter as Tk
except:
    import tkinter as Tk

</t>
<t tx="tom.20211211170820.47">class editDialog(Tk.Toplevel):
    # pylint: disable = too-many-ancestors
    @others
</t>
<t tx="tom.20211211170820.48">def __init__(self, parent=None, title = None):
    Tk.Toplevel.__init__(self, parent)

    self.parent = parent
    self.transient(parent)
    self.title(title)
    self.result = ''
    self.geometry('500x600+400+200')
    self.window = self

    scrollbar = Tk.Scrollbar(self)
    scrollbar.pack(side=Tk.RIGHT, fill=Tk.Y)

    editor = Tk.Text(self, wrap=Tk.NONE, yscrollcommand=scrollbar.set)
    editor.pack(padx=20, pady=20)#, side=Tk.LEFT, fill=Tk.BOTH )
    editor.config(height=20)
    self.editor = editor

    scrollbar.config(command=editor.yview)

    frm = Tk.Frame(self, borderwidth=5, relief=Tk.GROOVE,
            width=200, height=150)
    Tk.Button(frm, text="Accept", padx=5, command=self.accept).pack(side=Tk.LEFT)
    Tk.Button(frm, text="Cancel", padx=5, command=self.cancel).pack()
    frm.pack(pady=20)

    editor.focus_set()
    self.wait_window(self)


</t>
<t tx="tom.20211211170820.49">def accept(self, event=None):
    self.result = self.editor.get('1.0', Tk.END)
    if self.parent:
        self.parent.focus_set()
    self.window.destroy()


</t>
<t tx="tom.20211211170820.5">def __len__(self):
    if self.xdata is None:
        return False

    if self.isNumpyArray(self.xdata):
        return len(self.xdata.tolist())

    return len(self.xdata)

</t>
<t tx="tom.20211211170820.50">def cancel(self, event=None):
    # put focus back to the parent window
    self.result = ''
    if self.parent: self.parent.focus_set()
    self.window.destroy()
    return ''

</t>
<t tx="tom.20211211170820.51">if __name__ == '__main__':
    editDialog('Data Input')

    Tk.mainloop()
</t>
<t tx="tom.20211211170820.6">def __init__(self, xdata=None, ydata=None, figurelabel=''):
    self.xdata = xdata
    self.ydata = ydata
    self.subgraphs = []
    self.errorBands = []
    self.auxDataset = {}
    self.orig_filename = ''
    self.xaxislabel = ''
    self.yaxislabel = ''
    self.figurelabel = figurelabel
    self.parms = {}

</t>
<t tx="tom.20211211170820.7">def copy(self):
    return copy.deepcopy(self)

</t>
<t tx="tom.20211211170820.8">def clearErrorBands(self):
    self.errorBands = []

</t>
<t tx="tom.20211211170820.9">def normalize(self):
    '''Rescale to y data to a maximum of 1.0.
    '''
    _max = max(self.ydata)
    if _max == 0.0: return

    self.ydata = [1.0*y/_max for y in self.ydata]

</t>
<t tx="tom.20211211171304.10">def validate(self):
    return 1 # override

</t>
<t tx="tom.20211211171304.11">def apply(self):
    pass # override

</t>
<t tx="tom.20211211171304.12">def fade(self):
    alpha = self.attributes('-alpha')
    while alpha &gt; 0:
        alpha = alpha - 0.05
        self.attributes("-alpha", alpha)
        self.update()
        #time.sleep(0.02)
        self.after(1)
</t>
<t tx="tom.20211211171304.13">class TwoLineInput(Dialog):
    @others
</t>
<t tx="tom.20211211171304.14">def __init__(self, parent, title=''):
    Dialog.__init__(self, parent, title)

</t>
<t tx="tom.20211211171304.15">def body(self, master):

    Tk.Label(master, font='size 12', text="First:").grid(row=0)
    Tk.Label(master, font='size 12', text="Second:").grid(row=1)

    self.e1 = Tk.Entry(master, font='size 12')
    self.e2 = Tk.Entry(master, font='size 12')

    self.e1.grid(row=0, column=1)
    self.e2.grid(row=1, column=1)

    # self.e1.insert(0,'0') # how to preload
    return self.e1 # initial focus

</t>
<t tx="tom.20211211171304.16">def validate(self):
    try:
        first= self.e1.get()
        second = self.e2.get()
        self.result = first, second
        return True
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input",
            "Illegal values, please try again"
        )
        return False

</t>
<t tx="tom.20211211171304.17">def apply(self):
    pass#print self.result

</t>
<t tx="tom.20211211171304.18">class GetSingleInt(Dialog):
    @others
</t>
<t tx="tom.20211211171304.19">def __init__(self, parent, title='', label='Integer', initval=0):
    self.initval = initval
    self.label = label
    Dialog.__init__(self, parent, title)

</t>
<t tx="tom.20211211171304.2"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171304.20">def body(self, master):
    Tk.Label(master, font='size 12', text="%s:" % (self.label)).grid(row=0)
    self.e1 = Tk.Entry(master, font='size 12')
    self.e1.grid(row=0, column=1)

    self.e1.insert(0,str(self.initval)) # preload value
    #self.e1.configure(font='size 10')
    return self.e1 # initial focus

</t>
<t tx="tom.20211211171304.21">def validate(self):
    try:
        first= int(eval(self.e1.get()))  # pylint: disable = eval-used
        self.result = first
        return True
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error',
            "Try again ...%s" % e
        )
        return False

</t>
<t tx="tom.20211211171304.22">class GetSingleFloat(GetSingleInt):
    @others
</t>
<t tx="tom.20211211171304.23">def __init__(self, parent, title='', label='Float', initval=0.0):
    GetSingleInt.__init__(self, parent, title, label, float(initval))  

</t>
<t tx="tom.20211211171304.24">def validate(self):
    try:
        first= float(eval(self.e1.get()))  # pylint: disable = eval-used
        self.result = first
        return True
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error',
            "Try again ...%s" % e
        )
        return False

</t>
<t tx="tom.20211211171304.25">class GetTwoFloats(TwoLineInput):
    @others
</t>
<t tx="tom.20211211171304.26"># pylint: disable = too-many-arguments
def __init__(self, parent, title='', label1='Float', label2='Float', 
        initval1=0.0, initval2=0.0):
    self.initval1 = initval1
    self.initval2 = initval2
    self.label1 = label1
    self.label2 = label2
    TwoLineInput.__init__(self, parent, title)

</t>
<t tx="tom.20211211171304.27">def body(self, master):
    Tk.Label(master, font='size 12', text=self.label1).grid(row=0)
    Tk.Label(master, font='size 12', text=self.label2).grid(row=1)

    self.e1 = Tk.Entry(master, font='size 12')
    self.e2 = Tk.Entry(master, font='size 12')

    self.e1.grid(row=0, column=1)
    self.e2.grid(row=1, column=1)

    self.e1.insert(0,str(self.initval1)) # preload values
    self.e2.insert(0,str(self.initval2)) 

    return self.e1 # initial focus

</t>
<t tx="tom.20211211171304.28">def validate(self):
    self.result = None
    try:
        first= float(eval(self.e1.get()))  # pylint: disable = eval-used
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in first parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in first parameter",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error in first parameter',
            "Try again ...%s" % e
        )
        return False

    try:
        second = float(eval(self.e2.get()))  # pylint: disable = eval-used
        self.result = first, second
        return True
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in second parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in second parameter",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error in second parameter',
            "Try again ...%s" % e
        )
        return False
    
</t>
<t tx="tom.20211211171304.29">class GetTwoInts(TwoLineInput):
    @others
</t>
<t tx="tom.20211211171304.3">'''Various data input dialogs, based on Fred Lundt's examples at

http://effbot.org/tkinterbook/tkinter-dialog-windows.htm
'''

from __future__ import print_function

try:
    import Tkinter as Tk
except:
    import tkinter as Tk
try:
    import tkMessageBox
except:
    from tkinter import messagebox as tkMessageBox

#from math import *


</t>
<t tx="tom.20211211171304.30"># pylint: disable = too-many-arguments
def __init__(self, parent, title='', label1='Integer', label2='Integer', 
        initval1=0, initval2=0):
    self.initval1 = initval1
    self.initval2 = initval2
    self.label1 = label1
    self.label2 = label2
    TwoLineInput.__init__(self, parent, title)

</t>
<t tx="tom.20211211171304.31">def body(self, master):
    Tk.Label(master, font='size 12', text=self.label1).grid(row=0)
    Tk.Label(master, font='size 12', text=self.label2).grid(row=1)

    self.e1 = Tk.Entry(master, font='size 12')
    self.e2 = Tk.Entry(master, font='size 12')

    self.e1.grid(row=0, column=1)
    self.e2.grid(row=1, column=1)

    self.e1.insert(0,str(self.initval1)) # preload values
    self.e2.insert(0,str(self.initval2)) 

    return self.e1 # initial focus

</t>
<t tx="tom.20211211171304.32">def validate(self):
    self.result = None
    try:
        first= int(eval(self.e1.get()))  # pylint: disable = eval-used
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in first parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in first parameter",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error in first parameter',
            "Try again ...%s" % e
        )
        return False

    try:
        second = int(eval(self.e2.get()))  # pylint: disable = eval-used
        self.result = first, second
        return True
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in second parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in second parameter",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error in second parameter',
            "Try again ...%s" % e
        )
        return False

</t>
<t tx="tom.20211211171304.33">class GetTwoNumbers(TwoLineInput):
    '''Get two numbers from user.  Try to make the first an integer.
    If fail, try to make it a float.  If first is an integer,
    try to make the second an integer.  Otherwise, make second
    a float, too.
    '''
    @others
</t>
<t tx="tom.20211211171304.34"># pylint: disable = too-many-arguments
def __init__(self, parent, title='', label1='Integer', label2='Integer', 
        initval1=0, initval2=0):
    self.initval1 = initval1
    self.initval2 = initval2
    self.label1 = label1
    self.label2 = label2
    self.isint = True
    TwoLineInput.__init__(self, parent, title)

</t>
<t tx="tom.20211211171304.35">def body(self, master):
    Tk.Label(master, font='size 12', text=self.label1).grid(row=0)
    Tk.Label(master, font='size 12', text=self.label2).grid(row=1)

    self.e1 = Tk.Entry(master, font='size 12')
    self.e2 = Tk.Entry(master, font='size 12')

    self.e1.grid(row=0, column=1)
    self.e2.grid(row=1, column=1)

    self.e1.insert(0,str(self.initval1)) # preload values
    self.e2.insert(0,str(self.initval2)) 

    return self.e1 # initial focus

</t>
<t tx="tom.20211211171304.36">def validate(self):
    self.result = None
    try:
        first = eval(self.e1.get())  # pylint: disable = eval-used
        if not isinstance(first, int):
            first= float(first)
    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in first parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in first parameter",
            "Fix syntax"
        )
        return False
    except Exception as  e:
        tkMessageBox.showwarning(
            'Error in first parameter',
            "Try again ...%s" % e
        )
        return False

    try:
        second = eval(self.e2.get())  # pylint: disable = eval-used
        if type(second) == type(first):
            self.isint = False
            first = float(first)
            second = float(second)

        self.result = first, second
        return True

    except ValueError:
        tkMessageBox.showwarning(
            "Bad input in second parameter",
            "Illegal value, try again"
        )
        return False
    except SyntaxError:
        tkMessageBox.showwarning(
            "Syntax Error in second parameter",
            "Fix syntax"
        )
        return False
    except Exception as e:
        tkMessageBox.showwarning(
            'Error in second parameter',
            "Try again ...%s" % e
        )
        return False

\\-4.# ============================================================================
</t>
<t tx="tom.20211211171304.37">class TextFade(Tk.Text):
    @others
</t>
<t tx="tom.20211211171304.38">@staticmethod
def incr_in_range(color, base, delta):
    if not delta or color == base: return color
    c = color + delta
    if delta &gt; 0:
        return min(c, base)

    return max(c, base)

</t>
<t tx="tom.20211211171304.39">@staticmethod
def colr_str(r, g, b):
    """Format an r,g,b color group into the right format to set a Tk.Text widget.

    The color values are each scaled to 0xff.  This is necessary because the 
    queries self.winfo_rgb(self.cget('fg')) and self.winfo_rgb(self.cget('bg'))
    return tuples that are scaled to 0xFFFF, but the method to set a color
     - configure(fg=fg_base_color_str) for example - requires them to
     be a string with values scaled to 0xFF instead.

     RETURNS
     a formatted string.
    """
    return '#{:02x}{:02x}{:02x}'.format(r//256, g//256, b//256)


</t>
<t tx="tom.20211211171304.4"># pylint: disable = too-many-ancestors
class Dialog(Tk.Toplevel):
    """Base class for the dialogs.  From 
        http://effbot.org/tkinterbook/tkinter-dialog-windows.htm
    """

    @others
</t>
<t tx="tom.20211211171304.40">def fade(self, dwell=150):        
    '''Fade text to invisibility, then delete it. Then restore
    the text color.

    ARGUMENT
    dwell -- integer dwell time for each increment
    '''

    #colr_str = lambda r,g,b: '#{:02x}{:02x}{:02x}'.format(r//256, g//256, b//256)

    # Initial color values
    r0, g0, b0  = self.winfo_rgb(self.cget('fg'))
    #rb0, gb0, bb0 = bg_base_color = self.winfo_rgb(self.cget('bg'))
    rb0, gb0, bb0 = self.winfo_rgb(self.cget('bg'))
    fg_base_color_str = TextFade.colr_str(r0, g0, b0)

    # Color increments
    delr = (rb0 - r0) // 10
    delg = (gb0 - g0) // 10
    delb = (bb0 - b0) // 10

    self.config(state=Tk.NORMAL)

    r,g,b = (r0, g0, b0)
    while not (r == rb0 and g == gb0 and b == bb0):
        r = TextFade.incr_in_range(r, rb0, delr)
        g = TextFade.incr_in_range(g, gb0, delg)
        b = TextFade.incr_in_range(b, bb0, delb)

        _color_str = TextFade.colr_str(r,g,b)
        self.config(fg=_color_str)
        self.update()
        self.after(dwell)

    self.delete(1.0, Tk.END)
    self.update()
    self.configure(fg=fg_base_color_str)
    self.update()
    self.config(state=Tk.DISABLED)

</t>
<t tx="tom.20211211171304.41">def flash(self, flashcolor):
    '''Flash text background to attract attention to a message.
    '''

    bg0_rgb = self.winfo_rgb(self.cget('bg'))
    bg0_r, bg0_g, bg0_b = bg0_rgb[0]//256, bg0_rgb[1]//256, bg0_rgb[2]//256
    # rgb_f = self.winfo_rgb(flashcolor)
    # r_f, g_f, b_f = rgb_f[0]//256, rgb_f[1]//256, rgb_f[2]//256

    # delr = 0.1*(bg0_r - r_f)
    # delg = 0.1*(bg0_g - g_f)
    # delb = 0.1*(bg0_b - b_f)

    self.config(state=Tk.NORMAL)
    bg_color_str = '#{:02x}{:02x}{:02x}'.format(bg0_r, bg0_g, bg0_b)

    for n in range(4):
        self.config(bg=flashcolor)
        self.update()
        self.after(70)
        self.config(bg=bg_color_str)
        self.update()
        self.after(70)

    self.config(state=Tk.DISABLED)
</t>
<t tx="tom.20211211171304.42">if __name__ == '__main__':

    root = Tk.Tk()
    root.option_add('*tearOff', False) #Tk specific menu option

    root.wm_title('Dialog Testbed')
    root.bind('&lt;Alt-F4&gt;', quit)

    tf = TextFade(root, height=7, font='size 12', bg='LightBlue')
    tf.insert(1.0, 'this is a test')
    tf.pack()

    &lt;&lt; test defs &gt;&gt;

    mainMenu = Tk.Menu(root)
    mainMenu.add_command(label='Pop Up Dialog', command=two_line)
    mainMenu.add_command(label='Single Line Integer Dialog', command=one_line_int)
    mainMenu.add_command(label='Single Line Float  Dialog', command=one_line_float)
    mainMenu.add_command(label='Two Line Float Dialog', command=two_line_float)
    mainMenu.add_command(label='Two Line Integer Dialog', command=two_line_int)
    mainMenu.add_command(label='Two Number Dialog', command=two_number)
    mainMenu.add_command(label='Flash Test', command=test_flash)
    mainMenu.add_command(label='Fade Test', command=test_fade)
    mainMenu.add_command(label='Flash - Fade Test', command=test_flash_fade)
    root.config(menu=mainMenu)



    Tk.mainloop()
</t>
<t tx="tom.20211211171304.44">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171304.45">import sys

import matplotlib
matplotlib.use('TkAgg')

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

#import Tkinter as Tk
import tkinter as Tk

</t>
<t tx="tom.20211211171304.46">class PlotManager():
    @others
</t>
<t tx="tom.20211211171304.47">def __init__(self, root=None):
    self.setupFigure()

</t>
<t tx="tom.20211211171304.48">def setupFigure(self, title='GF4'):
    root = Tk.Tk()

    #f = Figure(figsize=(9,6), dpi=100)
    f = Figure()

    canvas = FigureCanvasTkAgg(f, master=root)
    sys.exit(0)
    canvas.get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)


</t>
<t tx="tom.20211211171304.49">if __name__ == '__main__':
    plotmgr = PlotManager()

    Tk.mainloop()
</t>
<t tx="tom.20211211171304.5">def __init__(self, parent, title = None):

    Tk.Toplevel.__init__(self, parent)
    self.transient(parent)

    if title:
        self.title(title)

    self.parent = parent
    self.result = None
    body = Tk.Frame(self)

    # pylint: disable = assignment-from-no-return
    # This method will be overridden and return a widget
    self.initial_focus = self.body(body)
    body.pack(padx=5, pady=5)

    self.buttonbox()

    self.grab_set()
    if not self.initial_focus:
        self.initial_focus = self

    self.protocol("WM_DELETE_WINDOW", self.cancel)
    self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                              parent.winfo_rooty()+50))

    self.initial_focus.focus_set()

    self.wait_window(self)

#
# construction hooks
</t>
<t tx="tom.20211211171304.51">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171304.52">'''Define line and symbol (i.e., "marker") characteristics for plotting data.
Mostly as defined by the Matplotlib axis class.
'''

CIRCLE = 'o'; HEXAGON = 'H'; DIAMOND = 'D'
SQUARE = 's'; TRIANGLE = '^'; TRIANGLE_LEFT = '&lt;'
SYM_NONE = 'None'
LINE_NONE = 'None'; LINE_SOLID = '-'
LINETHIN = 0.5; LINEMED = 1.2; LINETHICK = 2.5

</t>
<t tx="tom.20211211171304.53">class Linestyle:
    @others
</t>
<t tx="tom.20211211171304.54">def __init__(self):
    self.useSym = False
    self.useLine = True
    self.linewidth = LINETHIN
    self.linecolor = 'black'
    self.linestyle = LINE_SOLID
    self.symbol = CIRCLE
    self.sym_mec = 'black'  # symbol outline
    self.sym_mfc = 'black'  # symbol interior
    self.sym_mew = 0.5

</t>
<t tx="tom.20211211171304.55">def set_linewidth(self, width):
    self.linewidth = width
    
</t>
<t tx="tom.20211211171304.56">def set_sym_style(self, shape):
    self.symbol = shape

</t>
<t tx="tom.20211211171304.57">def set_sym_color(self, color):
    self.sym_mec = 'black' #color
    self.sym_mfc = color
    
</t>
<t tx="tom.20211211171304.58">def set_linecolor(self, color):
    self.linecolor = color
    
</t>
<t tx="tom.20211211171304.59">def get_vals(self):
    return 'useSym: %s\nuseLine: %s\nlinewidth: %s\nlinecolor: %s\nlinestyle: %s\n'\
        % (self.useSym, self.useLine, self.linewidth, self.linecolor,
            self.linestyle) \
        + 'symbol: %s\nsym_mec: %s\nsym_mfc: %s\nsym_mew: %s' \
        % (self.symbol, self.sym_mec, self.sym_mfc,
            self.sym_mew)
</t>
<t tx="tom.20211211171304.6">def body(self, master):
    # create dialog body.  return widget that should have
    # initial focus.  this method should be overridden

    pass

</t>
<t tx="tom.20211211171304.61">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171304.62">FNAME = r'c:\test\gf4.log'

</t>
<t tx="tom.20211211171304.63">def logit(txt):
    f = open(FNAME, 'a')
    f.write(txt + '\n')
    f.close()
</t>
<t tx="tom.20211211171304.65">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171304.66">"""Plotting routines for gf4. This code was removed from the
PlotManager class to reduce the size of the class.  The name
of the parameter "self" has been retained to simplify this
refactoring."""

from curve_generators import (generateExponential, generateSine, generateDampedSine,
                   generateRectangle, generateRamp, generateSquarewave,
                   generateGaussian,generateGaussianCdf)
from entry import GetSingleFloat, GetTwoFloats

from AbstractPlotMgr import MAIN
from Dataset import Dataset
from randnum import rand_vals, uniform_vals, gaussian_vals

</t>
<t tx="tom.20211211171304.67">def makeExponential(self):
    _id = str(self.makeExponential)
    lastparm = self.parmsaver.get(_id, 3.0)

    dia = GetSingleFloat(self.root, 'Parameter', 'Decay', lastparm)
    if not dia.result: return
    self.parmsaver[_id] = dia.result

    decay = dia.result
    N = self.num
    _ds = Dataset(*generateExponential(N, decay))
    _ds.figurelabel = 'Exponential'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.68">def makeSine(self):
    _id = str(self.makeSine)
    lastparm = self.parmsaver.get(_id, 5)

    dia = GetSingleFloat(self.root, 'Number Of Cycles', 'Cycles', lastparm)
    if not dia.result:
        return
    self.parmsaver[_id] = dia.result

    cycles = dia.result
    n = self.num
    _ds = Dataset(*generateSine(n, cycles))
    _ds.figurelabel = 'Sine Wave'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.69">def makeDampedSine(self):
    _id = str(self.makeDampedSine)
    lastc, lastd = self.parmsaver.get(_id, (5, 3.0))

    dia = GetTwoFloats(self.root, 'Parameters', 'Cycles',
                       'Decay', lastc, lastd)
    if not dia.result: return

    cycles, decay = self.parmsaver[_id] = dia.result
    N = self.num
    _ds = Dataset(*generateDampedSine(N, cycles, decay))
    _ds.figurelabel = 'Damped Sine'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.7">def buttonbox(self):
    # add standard button box. override if you don't want the
    # standard buttons

    box = Tk.Frame(self)

    w = Tk.Button(box, text="OK", width=10, command=self.ok, default=Tk.ACTIVE)
    w.pack(side=Tk.LEFT, padx=5, pady=5)
    w = Tk.Button(box, text="Cancel", width=10, command=self.cancel)
    w.pack(side=Tk.LEFT, padx=5, pady=5)

    self.bind("&lt;Return&gt;", self.ok)
    self.bind("&lt;Escape&gt;", self.cancel)

    box.pack()

#
# standard button semantics
</t>
<t tx="tom.20211211171304.70">def makeStep(self):
    N = self.num
    _ds = Dataset()
    _ds.xdata, _ds.ydata = generateRectangle(N)
    _ds.figurelabel = 'Rectangular Step'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.71">def makeDelta(self):
    '''Generate a delta function of amplitude 1, located at the start
    of the waveform
    '''

    N = self.num
    _ds = Dataset()
    _ds.xdata = list(range(N))
    _ds.ydata = [0.0] * N
    _ds.ydata[1] = 1.0
    _ds.figurelabel = 'Delta Function'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.72">def makeRamp(self):
    N = self.num
    _ds = Dataset()
    _ds.xdata, _ds.ydata = generateRamp(N)
    _ds.figurelabel = 'Linear Ramp'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.73">def makeSquarewave(self):
    _id = str(self.makeSquarewave)
    lastparm = self.parmsaver.get(_id, 5)

    dia = GetSingleFloat(self.root, 'Number Of Cycles', 'Cycles', lastparm)
    if not dia.result:
        return
    self.parmsaver[_id] = dia.result

    cycles = dia.result
    N = self.num
    _ds = Dataset()
    _ds.xdata, _ds.ydata = generateSquarewave(N, cycles)
    _ds.figurelabel = 'Squarewave'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.74">def makeRandomNoise(self):
    _x, _y = rand_vals(self.num)
    _ds = Dataset()
    _ds.xdata = _x
    _ds.ydata = _y
    _ds.figurelabel = 'Random Noise'
    _ds.yaxislabel = 'Value'
    _ds.xaxislabel = 'n'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.75">def makeUniformNoise(self):
    _x, _y = uniform_vals(-0.5, 0.5, self.num)
    _ds = Dataset()
    _ds.xdata = _x
    _ds.ydata = _y
    _ds.figurelabel = 'Uniform Noise'
    _ds.yaxislabel = 'Value'
    _ds.xaxislabel = 'n'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.76">def makeGaussianNoise(self):
    _id = str(self.makeGaussianNoise)
    lastm, lasts = self.parmsaver.get(_id, (0.0, 1.0))

    dia = GetTwoFloats(self.root, 'Parameters', 'Mean',
                       'Sigma', lastm, lasts)
    if not dia.result: return
    self.parmsaver[_id] = dia.result

    m, sig = dia.result
    _x, _y = gaussian_vals(m, sig, self.num)
    _ds = Dataset()
    _ds.xdata = _x
    _ds.ydata = _y
    _ds.figurelabel = 'Gaussian Noise m=%0.3f, s=%0.3f' % (m, sig)
    _ds.yaxislabel = 'Value'
    _ds.xaxislabel = 'n'

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.77">def pdfGaussian(self):
    _id = str(self.pdfGaussian)
    lastm, lasts = self.parmsaver.get(_id, (0.0, 2.0))

    dia = GetTwoFloats(self.root, 'Parameters', 'Mean',
                       'Sigma', lastm, lasts)
    if not dia.result: return
    self.parmsaver[_id] = dia.result

    m, sig = dia.result
    _xdata, _ydata = generateGaussian(self.num, m, sig)
    _ds = Dataset()
    _ds.xdata = _xdata
    _ds.ydata = _ydata
    _ds.figurelabel = 'Gaussian PDF m=%0.3f, s=%0.3f' % (m, sig)

    self.set_data(_ds, MAIN)
    self.plot()

</t>
<t tx="tom.20211211171304.78">def cdfGaussian(self):
    _id = str(self.cdfGaussian)
    lastm, lasts = self.parmsaver.get(_id, (0.0, 2.0))

    dia = GetTwoFloats(self.root, 'Parameters', 'Mean',
                       'Sigma', lastm, lasts)
    if not dia.result: return
    self.parmsaver[_id] = dia.result

    m, sig = dia.result
    _xdata, _ydata = generateGaussianCdf(self.num, m, sig)
    _ds = Dataset()
    _ds.xdata = _xdata
    _ds.ydata = _ydata
    _ds.figurelabel = 'Gaussian CDF m=%0.3f, s=%0.3f' % (m, sig)

    self.set_data(_ds, MAIN)
    self.plot()
</t>
<t tx="tom.20211211171304.8">def ok(self, event=None):
    if not self.validate():
        self.initial_focus.focus_set() # put focus back
        return

    self.fade()
    self.withdraw()
    self.update_idletasks()
    self.apply()
    self.cancel()


</t>
<t tx="tom.20211211171304.9">def cancel(self, event=None):
    # put focus back to the parent window
    self.fade()
    self.parent.focus_set()
    self.destroy()

#
# command hooks
</t>
<t tx="tom.20211211171913.10">def gaussian_vals(mu=0.0, sigma=1.0, count=256):
    '''Return values chosen randomly from gaussian distribution having
    specified mean and standard deviation].

    ARGUMENTS
    mu -- distribution mean
    sigma -- distribution standard deviation
    count -- number of values to return.

    RETURNS
    A tuple of lists (x,y).  The y values are the computed random variates,
    and the x values are sequentially numbered from 1.
    '''

    x = []
    y = []
    for n in range(1, count + 1):
        x.append(n)
        y.append(gauss(mu, sigma))

    return (x,y)


if __name__ == '__main__':
    def print_vals(vals):
        x,y  = vals
        _vals = ['%s %0.3f' % (x[i], y[i]) for i in range(len(x))]
        print('\n'.join(_vals))

    print ('rand_vals')
    print_vals(rand_vals(20))
    print()

    print('uniform_vals')
    print_vals(uniform_vals(0,1,20))
    print()

    print ('gaussian_vals')
    print_vals(gaussian_vals(1,.5,20))
</t>
<t tx="tom.20211211171913.12">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171913.13">"""Functions to smooth and fit x,y data."""

import math
from statistics import median

from scipy import interpolate
#from scipy.interpolate import UnivariateSpline
import numpy as np
from csaps import csaps

from randnum import gaussian_vals
#import matplotlib.pyplot as plt


MaxSmoothZone = 100

</t>
<t tx="tom.20211211171913.14">def sqr(x):
    return x**2

</t>
<t tx="tom.20211211171913.15">def cspline(x, y):
    '''Fit cubic spline to sequence of points and interpolate between them.
    Return the interpolated points.

    ARGUMENTS
    x,y -- Arrays containing the x and y values for the sequence of points.

    RETURNS
    A tuple of two arrays containing the x and y interpolated values.
    '''

    tck = interpolate.splrep(x, y, s=0)
    # mean distance between x values
    md = 1.0*((x[-1] - x[0])) / len(x)
    xnew = np.arange(x[0], x[-1] + md/10.0, md/10.0)
    ynew = interpolate.splev(xnew, tck, der=0)

    return (xnew, ynew)

</t>
<t tx="tom.20211211171913.16">def splineSmooth(x, y, s=.5):
    """Fit a set of points with a set of spline functions.  Return
    the fitted Y values.

    The fit is a statistical fit and may not go through any
    specific data point.  The smoothness of the fit can be adjusted
    using the "s" parameter.

    The parameter s is related to the number of knots that will be fitted.
    s = 1 will give the smoothest fit, and higher number wills have more
    inflections.  s must be a positive floating point number.

    The returned points have the same x values as the originals
    (i.e., no interpolation between data points is done).

    ARGUMENTS
    x -- the x-axis data.  May be a sequence or a numpy array.
    y -- the y-axis data.  May be a sequence or a numpy array.
    s -- a floating point positive number.

    RETURNS
    an array containing the y smoothed values.
    """
    ys = csaps(x, y, x, smooth=s)
    return (x, ys)

# ========== Auxiliary classes for use in smoothing routines ======
</t>
<t tx="tom.20211211171913.17">class WtStats:
    @others

</t>
<t tx="tom.20211211171913.18">def __init__(self):
    self.weights = []
    self.smoothzone = 0
    self.Swt = 0

</t>
<t tx="tom.20211211171913.19">def MakeGaussianWeights(self, smoothwidth=4):
    '''Compute weights to use with smoother. These weights
    form a gaussian curve, with a half-width of 2 sigma.

    ARGUMENT
    smoothwidth -- width of window in data points
                  (two-sided). Should be even; adjusted if odd

    RETURNS
    nothing
    '''

    _smoothzone = smoothwidth
    if smoothwidth % 2 == 1:
        _smoothzone = smoothwidth + 1
    self.smoothzone = _smoothzone
    numwts = _smoothzone + 1 # total number of weights
    icenter = _smoothzone / 2 # index of center point
    nSigma = 2
    self.Swt = 0

    # Half-width is nSigma sigma, so sigma = half-width / nSigma
    SmoothSigma = 1.0 * _smoothzone/(2 * nSigma)
    for i in range(numwts):
        self.weights.append(math.exp(-1.0*sqr(i - icenter)/(2*sqr(SmoothSigma))))
        self.Swt = self.Swt + self.weights[i]
#    print('\n'.join([f'{w:.3f}' for w in self.weights]))

</t>
<t tx="tom.20211211171913.2">"""Plotting routine for gf4.  This code was removed from the
PlotManager class to reduce the size of the class.  The name
of the parameter "self" has been retained to simplify this
refactoring."""

@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171913.20">def omitOne(self):
    '''Omit the center point by setting its weight to 0.  This may be used
    in cross-validation studies.
    '''

    if len(self.weights) &gt; 1:
        center = int(len(self.weights) / 2) # Python now returns floor of integer division
        self.weights[center] = 0.0
</t>
<t tx="tom.20211211171913.21">def correlationCoeff(data, fitted):
    '''Given a sequence of data and a sequence of fitted points (e.g.,
    from a least square fit), return the correlation coefficient.

    See http://ocw.usu.edu/Civil_and_Environmental_Engineering/Uncertainty_in_Engineering_Analysis/Regression_DataFitting_Part2.pdf
    Calculate (1) sum of squared deviations from fitted value, and
    (2) sum of squared deviations from the sample mean.

    Correlation Ceofficient r = sqrt(1 - (1) / (2) )

    Note that this formula is only correct when the mean of the fitted data
    equals the mean of the raw data.  This would be true if the fit were
    by a least squares procedure.  Also, (2) has to be larger than 1, so the variations
    in the data have to be larger than the variations from the fitted points.

    For correctly fitted data, this correlation coefficient generally (always?)
    equals Pearson's Correlation Coefficient, r.

    ARGUMENTS
    data -- a sequence of the data values
    fitted -- a sequence of the fitted values for each of the data values

    RETURNS
    the correlation coefficient, or -1 if r^2 would be negative.
    '''

    mean = 1.0*sum(data) / len(data)
    fitted_mean = 1.0*sum(fitted) / len(fitted)

    def corr(x, xf):
        Sdf = 0.0 # Deviations from fitted points
        Sdm = 0.0 # Deviations from mean
        mean = 1.0*sum(x)/len(x)
        for y, yf in zip(x, xf):
            Sdf += 1.0*(y - yf) **2
            Sdm += 1.0*(y - mean) **2
        return 1 - (Sdf / Sdm)

    r = corr(data, fitted)
    if r &gt;= 0:
        return r**0.5

    # Assume either the means are too far apart or the data have
    # more variation than the "fitted" - in case the "fitted"
    # data are not really fitted by just another random variable.
    # Shift data to match the means and try again.
    if fitted_mean != mean:
        delta = mean - fitted_mean
        new_fitted = [x+delta for x in fitted]
    r = corr(data, new_fitted)

    if  r &lt; 0:
        return - 1

    return r**0.5

</t>
<t tx="tom.20211211171913.22">def SmoothPointLowess(xdata, ydata, wt, i, cliplevel=2.0, causal=False):
    '''Fit a point in a sequence using a local linear least squares fit.
    Neighboring points contribute to the fit according to weights
    assigned using a weight table.  Return the fitted point, its square
    deviation, and whether or not if falls outside a clipping level.

    This function implements the core fitting portion of the LOWESS
    smoothing algorithm published by Cleveland.  The code is ported
    and adapted from the original Turbopascal code written by
    Thomas B. Passin for the GSTAT.EXE program.

    ARGUMENTS
    xdata, ydata -- lists of the x and y data.  Must be the same length.
    wt -- a WtStats instance that has the weight table filled in.
    i -- the index of the point (x,y) to be smoothed.
    cliplevel -- threshold for designating points as fliers
    causal -- If True, use only neighbors to left of specified point.  Otherwise,
              use neighbors on both sides.

    RETURNS
    a tuple (s, v, se, is_flier), where s is the smoothed value of the point,
    v is the variance at the point, se is the weighted standard error of the
    mean, and is_flier is boolean that is True if
    the point lies farther than cliplevel standard deviations
    from the fitted point.
    '''
    # pylint: disable=too-many-locals
    Swt = 0.0 # sum of weights
    Swx = 0.0 # weighted sum of x
    Swy = 0.0 # weighted sum of y
    Swxy = 0.0 # weighted sum of xy
    Swxx = 0.0 # weighted sum of xx
    Swyy = 0.0 # weighted sum of yy
    Sww = 0.0 # sum of squared weights
    a = 0.0 # y = ax + b for linear fit within the window
    b = 0.0
    SqrDev = 0

    sz = wt.smoothzone

    N = len(xdata)
    x = xdata[i]

    half = sz / 2
    window_left = int(max(i - half, 0))
    window_right = int(min(1 + i + half, N))
    _offset = i - half

    for j in range(window_left, window_right):
        weight_index = int(j - _offset)
        wj = wt.weights[weight_index]
        xtemp = xdata[j]
        ytemp = ydata[j]
        Swx = Swx +  wj*xtemp
        Swy = Swy +  wj*ytemp
        Swxy = Swxy +  wj* xtemp*ytemp
        Swxx = Swxx + wj * xtemp**2
        Swyy = Swyy + wj * ytemp**2
        Swt = Swt + wj
        Sww += wj**2

    a = (Swt*Swxy - Swx*Swy)/(Swt*Swxx - sqr(Swx))
    b = (Swy - a*Swx)/(Swt)

    y0 = a*x + b

    # Variance
    Svar = 0.
    for j in range(window_left, window_right):
        weight_index = int(j - _offset)
        wj = wt.weights[weight_index]
        xj = xdata[j]
        yj = ydata[j]
        yfit = a*xj + b
        Svar += wj*(yj-yfit)**2

    var = (Svar / Swt) *0.5*sz/(.5*sz - 1)

    # Approximate standard error of the fitted point
    se = ((var * Sww)**0.5) / Swt

    is_flier = (abs(ydata[i] - y0) &gt; cliplevel * math.sqrt(SqrDev))
    return (y0, var, se, is_flier)

</t>
<t tx="tom.20211211171913.23">def lowess(xdata, ydata, smoothzone=10, omitOne=False):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Return the smoothed points.  For each point, neighboring points
    are used to calculate the fit, using a table of weights to weight
    the points.  The window includes smoothzone points on either side of
    the given point.  The window width is adjusted when the given point
    gets too close to either end of the data.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    smoothzone -- the full window width in number of data points.
                  Should be even, adjusted up if not.
    omitOne -- For each point, omit that point when computing the fit.
               This can be used for cross-validation assessment.
               Implemented by setting the weight for the point to 0.

    RETURNS
    A tuple of two arrays containing the original x and smoothed y values.
    '''

    wt = WtStats()
    N = len(xdata)
    if N % 2 == 1:
        smoothzone = smoothzone + 1
    smoothzone = min(N - 1, smoothzone)
    wt.MakeGaussianWeights(smoothzone)
    if omitOne:
        wt.omitOne()

    fliers = []
    smooths = []
    for i, _ in enumerate(xdata):
        y, v, se, is_flier = SmoothPointLowess(xdata, ydata, wt, i)
        smooths.append(y)
        if is_flier:
            fliers.append((xdata[i], ydata[i]))

    return (xdata, smooths)

</t>
<t tx="tom.20211211171913.24">def lowess1(xdata, ydata, smoothzone=10, omitOne=False):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Return the smoothed points, and the autocorrelation of the residuals
    (calculated according to p49 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.)

    For each point, neighboring points are used to calculate the fit,
    using a table of weights to weight the points.  The window includes
    smoothzone points on either side of the given point.  The window width
    is adjusted when the given point gets too close to either end of the data.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    smoothzone -- the full window width for the smoothing weights.
    omitOne -- For each point, omit that point when computing the fit.
               This can be used for cross-validation assessment.
               Implemented by setting the weight for the point to 0.

    RETURNS
    A tuple (x, yf, r) where x is the original x series, yf is the fitted
        series, and r is the lag-1 autocorrelation of the residuals.
    '''

    wt = WtStats()
    N = len(xdata)
    if N % 2 == 1:
        smoothzone = smoothzone + 1
    smoothzone = min(N - 1, smoothzone)
    wt.MakeGaussianWeights(smoothzone)
    if omitOne:
        wt.omitOne()

    fliers = []
    smooths = []
    for i, _ in enumerate(xdata):
        y, v, se, is_flier = SmoothPointLowess(xdata, ydata, wt, i)
        smooths.append(y)
        if is_flier:
            fliers.append((xdata[i], ydata[i]))

    e = [smooths[i] - ydata[i] for i in range(len(ydata))] # residuals
    num = 0.0
    denom = 0.0
    for i in e:
        denom += sqr(i)
    for i in range(1, len(ydata)):
        num += e[i] * e[i - 1]
    r = abs(num / denom)

    return (xdata, smooths, r)

</t>
<t tx="tom.20211211171913.25">def deriv(xdata, ydata):
    '''Estimate the derivative dy/dx for (possibly) unequally-spaced
    data.  Return a tuple (xnew, dy) where xnew is a list of the
    x values and dy is a list of the derivative values at each of those
    x values. Note that there will be one fewer points than the original data.

    ARGUMENTS
    xdata, ydata -- sequences containing the x and y data values.

    RETURNS
    dy -- list of (x values, derivative values.
    '''

    derivs = []
    for i in range(len(xdata) - 1):
        if i == 0:
            dy = (ydata[i+1] - ydata[i])/(xdata[i+1] -xdata[i])
            derivs.append(dy)
        else:
            dx1 = xdata[i+1] - xdata[i]
            dx = xdata[i] - xdata[i-1]
            dy = (ydata[i+1] - ydata[i]) / dx1 + (ydata[i] - ydata[i-1]) / dx
            dy = 0.5*dy
            derivs.append(dy)

    return xdata[:-1], derivs

</t>
<t tx="tom.20211211171913.26">def lowess2(xdata, ydata, smoothzone=10, omitOne=False):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Return the smoothed points, and the rms of the residuals
    (calculated according to p36 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.)

    For each point, neighboring points are used to calculate the fit,
    using a table of weights to weight the points.  The window includes
    smoothzone points on either side of the given point.  The window width
    is adjusted when the given point gets too close to either end of the data.

    Store the fitted point +- 1 s.d. into two subgraphs.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    smoothzone -- the full window width for the smoothing weights.
    omitOne -- For each point, omit that point when computing the fit.
               This can be used for cross-validation assessment.
               Implemented by setting the weight for the point to 0.

    RETURNS
    A tuple (x, yf, rms, upperbound, lowerbound) where x is the original x series,
    yf is the fitted series, rms is the rms deviation from fitted points,
    and upperbound, lowerbound are the y values for y +/- 2 std dev.
    '''

    wt = WtStats()
    N = len(xdata)
    if N % 2 == 1:
        smoothzone = smoothzone + 1
    smoothzone = min(N - 1, smoothzone)
    wt.MakeGaussianWeights(smoothzone)
    if omitOne:
        wt.omitOne()
    fliers = []
    smooths = []
    ses = []
    upperlimit = []
    lowerlimit = []
    ERRORLIMIT = 2.0

    for i, _ in enumerate(xdata):
        y, v, se, is_flier = SmoothPointLowess(xdata, ydata, wt, i)
        smooths.append(y)
        ses.append(se)
        upperlimit.append(y + ERRORLIMIT *se)
        lowerlimit.append(y - ERRORLIMIT *se)
        if is_flier:
            fliers.append((xdata[i], ydata[i]))

    mean_err = sum(ses) / len(xdata)

    return (xdata, smooths, mean_err, upperlimit, lowerlimit)

</t>
<t tx="tom.20211211171913.27">def lowessAdaptive(xdata, ydata, weight=1.0,
                   spans=(3, 5, 10, 15, 20, 25, 30, 40, 60, 70, 80)):
    """Smooth sequence of points using Cleveland's LOWESS algorithm.
    Estimate the best span of points by making multiple LOWESS
    runs with different spans.  This span balances fit with smoothness
    of the fitted curve.  Return the points smoothed with the
    estimated best span.

    Score each run using a penalty expression (to be minimized) that includes
    the mean squared error and a roughness function, as in Eq. 6.1 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.)

    The penalty expression is

        p = (mse) + w * (msr)

    mse = mean squared error, computed using the cross-validation
          method, that is, to set omitOne = True (i.e., by
          omitting the focal point of the LOWESS calculation).
    msr = mean square of the second derivative.
    w = a weight parameter.  0 neglects the roughness of the fit, very large
        values maximize the importance of a smooth fit.  A value of 1
        is likely to be a useful value to start with.

    To score the set of runs, scale the smoothness function so that its
    average value across the runs equals the average value of the
    mean squared error across the runs.  Then use the weight parameter
    to adjust the multiplier for the smoothness.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    weight -- relative weight to give to the roughness factor.
    spans -- a sequence of span values to use when estimating the best span.

    RETURNS
    A tuple (x, yf, bestspan, rms, upperbound, lowerbound) where x is the original
        x series, yf is the fitted series, bestspan is the estimated best span
        used to compute the fitted series, rms is the rms deviation
        from fitted points, and
        upperbound, lowerbound are the y values
        for y +- sqrt(var).
    """
    # pylint: disable=too-many-locals
    weight = float(weight)
    mse = []
    rough = []

    if type(xdata) is type(np.ndarray([])):
        xdata = xdata.tolist()
    N = len(xdata)

    for s in (s1 for s1 in spans if s1 &lt;= N):
        xi, yi, rms, upperlimit, lowerlimit = lowess2(xdata, ydata, s, True)
        var = sum([float((_y - _yfit)**2)/(N-1) for _y, _yfit in zip(ydata, yi)])
        mse.append(var)

        xp, dy = deriv(xi, yi)
        xpp, ddy = deriv(xp, dy)
        k = sum([abs(_d) for _d in ddy]) / len(ddy) # Mean absolute curvature
        rough.append(k)

    mean_rough = sum(rough) / len(rough)

    mean_mse = sum(mse) / (len(mse) - 1)

    rough_scale_factor = weight * mean_mse / mean_rough

    if __name__ == '__main__':
        print ( 'Roughness Weight:', weight)
        print ( 'roughness scale factor:', rough_scale_factor)
        print ( 'Span \tPenalty   \tmse  \t  Roughness')

    penalty = []
    for i, _ in enumerate(mse):
        penalty.append(mse[i] + rough[i] * rough_scale_factor)

    bestindex = penalty.index(min(penalty))
    best = spans[bestindex]

    xi, yi, rms, upperlimit, lowerlimit = lowess2(xdata, ydata, best, False)
    return xi, yi, best, rms, upperlimit, lowerlimit

</t>
<t tx="tom.20211211171913.28">def leastsqr(xdata, ydata, deg=1):
    '''Calculate a least squares fit to a set of x,y points.
    Return a list of the fitted Y values evaluated at the original
    X values, the mean, the rms deviation from fitted points,
    the correlation coefficient, and upperbound, lowerbound are the
    y values for y +- sqrt(var).

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    deg -- the degree of the fit (1 = linear, 2 = quadratic, etc): 2 max

    RETURNS
    a tuple  (list of the fitted values, mean, s.e., r, upperbound, lowerbound).
    '''

    coeffs = np.polyfit(xdata, ydata, deg)
    p = np.poly1d(coeffs)
    fitted_y = [p(x) for x in xdata]

    var = 0.0
    #mean = 0.0
    N = len(fitted_y)

    y_mean = 1.0 * sum(ydata) / N
    x_mean = 1.0 * sum(xdata) / N

    for ys, y in zip(ydata, fitted_y):
        var += (1.0*ys - y)**2

    var = var / (N - 2)  # Variance of any one fitted point
    #rms = (var**0.5)
    se = (var/(N-1))**0.5 # std error of residuals

    # Estimated SD of slope from least-squares formula:
    # Var(slope) = (1/(N-2)) * sum(yi_fitted - yi)^2 / sum(xi - x_avg)^2
    # See https://en.wikipedia.org/wiki/Simple_linear_regression#Confidence_intervals
    y_mean = 1.0 * sum(ydata) / N
    x_mean = 1.0 * sum(xdata) / N
    #var_slope = (1.0/(N-2)) * sum([(y_fit - _y)**2 for y_fit, _y in zip(fitted_y, ydata)]) \
    #            / sum([(xi - x_mean)**2 for xi in xdata])
    #sd_slope = var_slope**0.5

    # See Wikipedia:
    # https://en.wikipedia.org/wiki/Simple_linear_regression#Confidence_intervals
    eps_2 = [(_y - _yf)**2 for _y, _yf in zip(ydata, fitted_y)]
    Sx2 = sum([(_xi - x_mean)**2 for _xi in xdata])
    var_all = [(1./(N-2)) * sum(eps_2) * (1./N + ((_xi - x_mean)**2)/Sx2) \
                for _xi in xdata]
    se_all = [_v**0.5 for _v in var_all]

    upper = [y + 2*se for y,se in zip(fitted_y, se_all)]
    lower = [y - 2*se for y,se in zip(fitted_y, se_all)]

    r = correlationCoeff(ydata, fitted_y)

    return (fitted_y, y_mean, se, r, upper, lower)

</t>
<t tx="tom.20211211171913.29">def determinant(x11, x12, x13, x21, x22, x23,
        x31, x32, x33):
    '''Compute determinant of 3X3 matrix.  Return the value
    of the determinant.

    ARGUMENTS
    x11, ... x33 -- the nine elements of the 3 X 3 matrix.

    RETURNS
    the value of the matrix's determinant.
    '''
    # pylint: disable=too-many-arguments
    return x11*(x22*x33 - x23*x32) + x12*(x23*x31 - x33*x21) \
                + x13*(x21*x32 -x22*x31)

</t>
<t tx="tom.20211211171913.3">from Linestyle import LINE_SOLID, LINETHIN, SYM_NONE, LINE_NONE
from AbstractPlotMgr import MAIN, STACKDEPTH

</t>
<t tx="tom.20211211171913.30">def SmoothPointLowessQuad(xdata, ydata, wt, i, cliplevel=2.0, causal=False):
    '''Fit a point in a sequence using a local quadratic least squares fit.
    Neighboring points contribute to the fit according to weights
    assigned using a weight table.  Return the fitted point, its square
    deviation, and whether or not if falls outside a clipping level.

    This function implements the core fitting portion of the LOWESS
    smoothing algorithm published by Cleveland.  The code is ported
    and adapted from the original Turbopascal code written by
    Thomas B. Passin for the GSTAT.EXE program.

    ARGUMENTS
    xdata, ydata -- lists of the x and y data.  Must be the same length.
    wt -- a WtStats instance that has the weight table filled in.
    i -- the index of the point (x,y) to be smoothed.
    cliplevel -- threshold for designating points as fliers
    causal -- If True, use only neighbors to left of specified point.  Otherwise,
              use neighbors on both sides.

    RETURNS
    a tuple (s, v, se, is_flier), where s is the smoothed value of the point,
    v is the variance at the point, se is the weighted standard deviation of the
    fitted point, and is_flier is a boolean that is True if
    the point lies farther than cliplevel standard deviations
    from the fitted point.
    '''
    # pylint: disable=too-many-locals
    # y = axx + bx + c for quadratic fit within the window
    a = np.float64(0.0) # y = axx + bx + c for quadratic fit within the window
    b = np.float64(0.0)
    c = np.float64(0.0)
    SqrDev = np.float64(0)

    sz = wt.smoothzone #Full width of smoothing window in data points

    xdata = [np.float64(z) for z in xdata]
    ydata = [np.float64(z) for z in ydata]

    N = len(xdata)
    x = xdata[i]
    #yfocal = ydata[i]

    half = int(sz / 2)
    window_left = max(i - half, 0)
    window_right = min(1 + i + half, N)
    _offset = i - half

    def compute_dets(wt, xdata, ydata, window_left, window_right, offset):
        ''' Accumulate terms to be summed in lists, so that they can be
        summed using math.fsum().  fsum uses higher precision for the
        intermediate sums.  This avoids occasional problems with
        insufficient precision that we can get if directly adding up
        each term as it is calculated.  See
        http://docs.python.org/2/library/math.html
        '''

        _swt = [] # sum of weights
        _swx = [] # weighted sum of x
        _swy = [] # weighted sum of xy
        _swxy = [] # weighted sum of xy
        _swxx = [] # weighted sum of xx
        _swyy = [] # weighted sum of yy
        _swxxx = [] # weighted sum of xxx
        _swxxxx = [] # weighted sum of x^4
        _swyxx = [] # weighted sum of y*x^2
        _sww = [] # Sum of squared weights

        for j in range(window_left, window_right):
            weight_index = j - offset
            wj = wt.weights[weight_index]
            xtemp = xdata[j]
            ytemp = ydata[j]
            xsqr = xtemp**2
            x3 = xtemp**3
            x4 = xtemp**4
            ysqr = ytemp**2
            _swx.append(wj*xtemp)
            _swy.append(wj*ytemp)
            _swxy.append( wj* xtemp*ytemp)
            _swxx.append(wj* xsqr)
            _swyy.append(wj * ysqr)
            _swt.append(wj)
            _swxxx.append(wj * x3)
            _swxxxx.append(wj * x4)
            _sww.append(wj**2)

            Swx = math.fsum(_swx)
            Swy = math.fsum(_swy)
            Swxy = math.fsum(_swxy)
            Swxx = math.fsum(_swxx)
            #Swyy = math.fsum(_swyy)
            Swt = math.fsum(_swt)
            Swxxx = math.fsum(_swxxx)
            Swxxxx = math.fsum(_swxxx)
            Swyxx = math.fsum(_swyxx)
            #Sww = math.fsum(_sww)

        det = determinant(Swxxxx, Swxxx, Swxx,
                          Swxxx, Swxx, Swx,
                          Swxx, Swx, Swt)

        a = determinant(Swyxx, Swxxx, Swxx,
                        Swxy, Swxx, Swx,
                        Swy, Swx, Swt) / det

        b = determinant(Swxxxx, Swyxx, Swxx,
                        Swxxx, Swxy, Swx,
                        Swxx, Swy, Swt) / det

        c = determinant(Swxxxx, Swxxx, Swyxx,
                        Swxxx, Swxx, Swxy,
                        Swxx, Swx, Swy) / det
        return det, a, b ,c

    det, a,b,c = compute_dets(wt, xdata, ydata, window_left, window_right, _offset)
    y0 = a*x**2 + b*x + c
    parms = a,b,c

    dabs = abs(det)
    #ylim = max([abs(_y) for _y in ydata ])
    recentered = False
    if True or dabs &lt; 100000 and not recentered:
        #  recenter x data
        _xmax = max(xdata)
        _xmin = min(xdata)
        xc = 1.0*(_xmax-_xmin)
        orig_x = xdata[:]
        _xdata = [_x - xc for _x in orig_x]
        recentered = True

        # Quick and dirty check for matrix conditioning
        # Larger determinant is better for stability.
        # Perturb data, then recenter x data, then see
        # which determinant is bigger.
        eps = .2
        delta = [abs((_y2 - _y1))/N for _y2, _y1 in zip(ydata[1:], ydata[:-1])]
        sigma = eps * sum(delta) / N
        _rands = gaussian_vals(0.0, sigma, N)[1]

        _newy = [_y + _r for _y, _r in zip(ydata, _rands)]
        det, a,b,c = compute_dets(wt, _xdata, _newy, window_left, window_right, _offset)
        _x_recen = _xdata[i]
        y0_est = a*_x_recen**2 + b*_x_recen + c

        if abs(det) &gt; dabs:
            y0 = y0_est
            parms = a,b,c
            xdata = _xdata

    Svar = 0.
    Swt = 0.
    Sww = 0.
    A, B, C = parms
    for j in range(window_left, window_right):
        weight_index = j - _offset
        wj = wt.weights[weight_index]
        xj = xdata[j]
        yj = ydata[j]
        yfit = A*xj**2 + B*xj + C
        Svar += wj*(yj-yfit)**2
        Swt += wj
        Sww += wj*wj

    var = (Svar / Swt) *0.5*sz/(.5*sz - 1)

    # Approximate standard error of the fitted point
    #se = ((var * Sww)**0.5) / Swt
    se = ((Svar/Swt) / ((Swt**2 / Sww) - 1))**0.5

    is_flier = (abs(ydata[i] - y0) &gt; cliplevel * math.sqrt(SqrDev))

    return (y0, var, se, is_flier)

</t>
<t tx="tom.20211211171913.31">def ySmoothPointLowessQuad(xdata, ydata, wt, i, cliplevel=2.0, causal=False):
    '''Fit a point in a sequence using a local quadratic least squares fit.
    Neighboring points contribute to the fit according to weights
    assigned using a weight table.  Return the fitted point, its square
    deviation, and whether or not if falls outside a clipping level.

    This function implements the core fitting portion of the LOWESS
    smoothing algorithm published by Cleveland.  The code is ported
    and adapted from the original Turbopascal code written by
    Thomas B. Passin for the GSTAT.EXE program.

    ARGUMENTS
    xdata, ydata -- lists of the x and y data.  Must be the same length.
    wt -- a WtStats instance that has the weight table filled in.
    i -- the index of the point (x,y) to be smoothed.
    cliplevel -- threshold for designating points as fliers
    causal -- If True, use only neighbors to left of specified point.  Otherwise,
              use neighbors on both sides.

    RETURNS
    a tuple (s, d, se, is_flier), where s is the smoothed value of the point,
    d is the variance at the point, se is the weighted standard deviaton of the
    fitted point, and is_flier is a boolean that is True if
    the point lies farther than cliplevel standard deviations
    from the fitted point.
    '''
    # pylint: disable=too-many-locals
    Swt = 0.0 # sum of weights
    Swx = 0.0 # weighted sum of x
    Swy = 0.0 # weighted sum of y
    Swxy = 0.0 # weighted sum of xy
    Swxx = 0.0 # weighted sum of xx
    Swyy = 0.0 # weighted sum of yy
    Swxxx = 0.0 # weighted sum of xxx
    Swxxxx = 0.0 # weighted sum of x^4
    Swyxx = 0.0 # weighted sum of y*x^2
    Sww = 0.0 # Sum of squared weights

    a = 0.0 # y = axx + bx + c for quadratic fit within the window
    b = 0.0
    c = 0.0
    SqrDev = 0

    sz = wt.smoothzone #Full width of smoothing window in data points

    N = len(xdata)
    x = xdata[i]

    half = sz / 2
    window_left = max(i - half, 0)
    window_right = min(1 + i + half, N)
    _offset = i - half

    for j in range(window_left, window_right):
        weight_index = j - _offset
        wj = wt.weights[weight_index]
        xtemp = xdata[j]
        ytemp = ydata[j]
        xsqr = xtemp**2
        x3 = xtemp**3
        x4 = xtemp**4
        ysqr = ytemp**2
        Swx = Swx +  wj*xtemp
        Swy = Swy +  wj*ytemp
        Swxy = Swxy +  wj* xtemp*ytemp
        Swxx = Swxx + wj* xsqr
        Swyy = Swyy + wj * ysqr
        Swt = Swt + wj
        Swxxx = Swxxx + wj * x3
        Swxxxx = Swxxxx + wj * x4
        Swyxx = Swyxx + wj * ytemp * xsqr
        Sww = wj**2

    det = determinant(Swxxxx, Swxxx, Swxx,
                      Swxxx, Swxx, Swx,
                      Swxx, Swx, Swt)

    a = determinant(Swyxx, Swxxx, Swxx,
                    Swxy, Swxx, Swx,
                    Swy, Swx, Swt) / det

    b = determinant(Swxxxx,Swyxx, Swxx,
                    Swxxx, Swxy, Swx,
                    Swxx, Swy, Swt) / det

    c = determinant(Swxxxx, Swxxx, Swyxx,
                    Swxxx, Swxx, Swxy,
                    Swxx, Swx, Swy) / det

    y = a*x**2 + b*x + c
    var = (Swyy - 2.*y*Swy + Swt*y**2) / Swt
    var = max(var, 0)

    se = (var * Sww)**0.5/Swt

    is_flier = (abs(ydata[i] - y) &gt; cliplevel * math.sqrt(SqrDev))
    return (y, var, se, is_flier)

</t>
<t tx="tom.20211211171913.32">def lowess2Quad(xdata, ydata, smoothzone=10, omitOne=False):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Return the smoothed points, and the mean square error of the residuals
    (calculated according to p36 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.)

    For each point, neighboring points are used to calculate the fit using
    a quadratic weighted least squares fit, using a table of weights to
    weight the points.  The window includes smoothzone points on either
    side of the given point.  The window width is adjusted when the given
    point gets too close to either end of the data.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    smoothzone -- the full window width for the smoothing weights.
    omitOne -- For each point, omit that point when computing the fit.
               This can be used for cross-validation assessment.
               Implemented by setting the weight for the point to 0.
               [Not implemented yet]

    RETURNS
    A tuple (x, yf, rms) where x is the original x series, yf is the fitted
        series, rms is the rms deviation from fitted points,
        and upperbound, lowerbound are the y values for y +- standard error.
    '''

    wt = WtStats()
    N = len(xdata)
    if N % 2 == 1:
        smoothzone = smoothzone + 1
    smoothzone = min(N - 1, smoothzone)

    wt.MakeGaussianWeights(smoothzone)
    if omitOne:
        wt.omitOne()
    wt.weights = [np.float64(z) for z in wt.weights]

    fliers = []
    smooths = []
    ses = []
    upperlimit = []
    lowerlimit = []
    errorlimit = 2.0

    for i, _ in enumerate(xdata):
        y, v, se, is_flier = SmoothPointLowessQuad(xdata, ydata, wt, i)
        if y &gt; 2:
            pass #print xdata[i], ydata[i], y, type(ydata[i])
        smooths.append(y)
        ses.append(se)
        upperlimit.append(y + errorlimit * se)
        lowerlimit.append(y - errorlimit * se)
        if is_flier:
            fliers.append((xdata[i], ydata[i]))

    mean_err = sum(ses) / len(xdata)

    return (xdata, smooths, mean_err, upperlimit, lowerlimit)

</t>
<t tx="tom.20211211171913.33">def xlowessAdaptiveAC(xdata, ydata):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Estimate the best span of points by making multiple LOWESS
    runs with different spans.  The fit criterion is the value of the
    autocorrelation.   autocorrelation of the residuals is
    calculated according to p49 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.

    Return the points smoothed with the
    estimated best span.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.

    RETURNS
    A tuple (x, yf, bestspan, rms, ac, upperbound, lowerbound) where x is the original
        x series, yf is the fitted series, bestspan is the estimated best span
        used to compute the fitted series, rms is the rms error, ac is the best
        autocorrelation, and upperbound, lowerbound are the y values for y +- sqrt(var).
    '''

    spans=(3, 5, 10, 15, 20, 25, 30, 40, 60)

    if type(xdata) is type(np.ndarray([])):
        xdata = xdata.tolist()
    #N = len(xdata)

    param = []
    for s, _ in enumerate(spans):
        xi, yi, r = lowess1(xdata, ydata, spans[s])
        param.append((abs(r), spans[s]))

    param.sort()
    rmin, sbest = param[0]

    xi, yi, rms, upperlimit, lowerlimit = lowess2Quad(xdata, ydata, sbest, False)

    return xi, yi, sbest, rms, rmin, upperlimit, lowerlimit

</t>
<t tx="tom.20211211171913.34">def lowessAdaptiveAC(xdata, ydata):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Estimate the best span of points by making multiple LOWESS
    runs with different spans.  The fit criterion is the value of the
    autocorrelation.   autocorrelation of the residuals is
    calculated according to p49 of

    "Nonparametric Simple Regression", J. Fox, Sage University, 2000.

    Return the points smoothed with the
    estimated best span.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.

    RETURNS
    A tuple (x, yf, bestspan, rms, ac, upperbound, lowerbound) where x is the original
        x series, yf is the fitted series, bestspan is the estimated best span
        used to compute the fitted series, rms is the rms error, ac is the best
        autocorrelation, and upperbound, lowerbound are the y values for y +- sqrt(var).
    '''

    #spans=(3, 5, 10, 15, 20, 25, 30, 40, 60)

    if type(xdata) is type(np.ndarray([])):
        xdata = xdata.tolist()
    #N = len(xdata)

    thresh = 0.05
    eps = 0.001
    reps = 0
    rep_limit = 20
    delta = 3 # step size
    #overshot = False
    converged = False
    too_many = False
    #smallest = 0.0
    last_r = 0.0

    smallest_yet = None

    width = 4
    last_r = 0

    #print 'width\tdelta\tr\t\tlast r\tr - last_r'
    while not converged and not too_many:
        xi, yi, r = lowess1(xdata, ydata, int(width))
        #print width, '\t', delta, '\t%f' % r, '\t%f' % last_r,
        reps += 1
        r = abs(r)
        if reps == 1:
            #smallest = r
            last_r = 3*r
            smallest_yet = (r, width)

        #print '%0.4f' % (abs(r - last_r)),  abs(r - last_r) &lt; eps
        if reps &gt; 1 and abs(r - last_r) &lt; eps:
            converged = True
            break

        last_r = r
        converged = (abs(r) &lt; thresh)
        too_many = (reps &gt; rep_limit)

        #print '%s\t%s\t%s\t%0.3f'  % (reps, width, delta, r)
        if r &gt; smallest_yet[0]:
            # reverse and halve distance to best width
            delta = int((smallest_yet[1] - width) / 2.0)
        elif r &lt; smallest_yet[0]:
            smallest_yet = (r, width)

        if delta == 0:
            converged = True
           # print 'Converged'
            break
        width += delta
        if width &lt; 2:
            break

    #print 'Final: %f %s' % smallest_yet
    #print 'results'
    #print '%s\t%s\t%s\t%0.3f'  % (reps, smallest_yet[1], delta, smallest_yet[0])

    xi, yi, rms, upperlimit, lowerlimit = lowess2(xdata, ydata,  smallest_yet[1], False)

    return xi, yi, smallest_yet[1], rms, smallest_yet[0], upperlimit, lowerlimit

</t>
<t tx="tom.20211211171913.35">def SmoothPointPoisson(xdata, ydata, i, smoothzone):
    '''Fit a point in a sequence using a local linear least squares fit.
    Neighboring points contribute to the fit according to weights
    assigned as the estimated inverse variance of the point.  The
    variance is assumed to equal the data value.

    Return the fitted point, its square deviation, and standard error.

    The y data points must be &gt;= 0

    If a y value is zero, we set its variance to 1, since with a Poisson
    distribution, a count of 0 has the same probability as a count of 1.

    This function implements the core fitting portion of the LOWESS
    smoothing algorithm published by Cleveland.  The code is adapted  from the
    LOWESS smoothing code from the gf4 program.

    ARGUMENTS
    xdata, ydata -- lists of the x and y data.  Must be the same length.
    i -- the index of the point (x,y) to be smoothed.
    smoothzone -- width of smoothing window, in data points.

    RETURNS
    a tuple (s, v, se), where s is the smoothed value of the point,
    v is the variance at the point, se is the weighted standard error of the
    mean.
    '''
    # pylint: disable=too-many-locals
    Swt = 0.0 # sum of weights
    Swx = 0.0 # weighted sum of x
    Swy = 0.0 # weighted sum of y
    Swxy = 0.0 # weighted sum of xy
    Swxx = 0.0 # weighted sum of xx
    Swyy = 0.0 # weighted sum of yy
    Sww = 0.0 # sum of squared weights
    a = 0.0 # y = ax + b for linear fit within the window
    b = 0.0
    #SqrDev = 0

    sz = smoothzone

    N = len(xdata)
    x = xdata[i]

    half = sz / 2
    window_left = int(max(i - half, 0))
    window_right = int(min(1 + i + half, N))
    #_offset = i - half


    if ydata[window_left : window_right] == [0] * (window_left - window_right):
        return (0., 0., 0.)

    for j in range(window_left, window_right):
        #weight_index = j - _offset
        xtemp = xdata[j]
        ytemp = ydata[j]
        if ytemp == 0:
            wj = 1.
        else:
            wj = 1./ytemp

        Swx = Swx +  wj*xtemp
        Swy = Swy +  wj*ytemp
        Swxy = Swxy +  wj* xtemp*ytemp
        Swxx = Swxx + wj * xtemp**2
        Swyy = Swyy + wj * ytemp**2
        Swt = Swt + wj
        Sww += wj**2

    try:
        a = (Swt*Swxy - Swx*Swy)/(Swt*Swxx - sqr(Swx))
        b = (Swy - a*Swx)/(Swt)

        y = a*x + b
        var = (Swyy - 2.*y*Swy + Swt*y**2) / Swt

        var = max(var, 0)

        # Approximate standard error of the fitted point
        se = ((var * Sww)**0.5)/Swt
    except ZeroDivisionError:
        return (0., 0., 0.)

    return (y, var, se)

</t>
<t tx="tom.20211211171913.36">def poissonSmooth(xdata, ydata, smoothzone=10):
    '''Smooth sequence of points using Cleveland's LOWESS algorithm.
    Return the smoothed points.  For each point, neighboring points
    are used to calculate the fit, using a table of weights to weight
    the points.  The window includes smoothzone points on either side of
    the given point.  The window width is adjusted when the given point
    gets too close to either end of the data.

    If the x-axis data is not in increasing order, the data are re-ordered
    before smoothing.

    ARGUMENTS
    xdata,ydata -- sequences containing the x and y data values.
    smoothzone -- the full window width in number of data points.
                  Should be even, adjusted up if not.

    RETURNS
    A tuple of (x, y, mse) x is a sequence containing the sorted x values,
    y contains the smoothed y values, and mse of the fitted points.

    RAISES
    ValueError if any input y value is less than 0.
    '''

    # Test data values for &gt;= 0
    neg_values = []
    for y in ydata:
        if y &lt; 0:
            neg_values.append(y)
    if neg_values:
        raise ValueError ('Negative values not allowed: %0.3f, ...' % neg_values[0])

    N = len(xdata)
    if N % 2 == 1:
        smoothzone = smoothzone + 1
    smoothzone = min(N - 1, smoothzone)
    smooths = []

    _temp = list(zip(xdata, ydata))
    _temp.sort()
    xdata, ydata = zip(*_temp)
    xdata = list(xdata)
    ydata = list(ydata)

    for i in range(len(xdata)):
        y, v, se = SmoothPointPoisson(xdata, ydata, i, smoothzone)
        smooths.append(y)

    e = [sqr(smooths[i] - ydata[i]) for i in range(len(smooths))] # residuals
    mse = 0.0
    for r in e:
        mse += r
    mse = (mse / (len(smooths) - 1))**0.5

    return (xdata, smooths, mse)

</t>
<t tx="tom.20211211171913.37">def thiel_sen(x,y):
    """Fit line robustly to X,Y data using Thiel-Sen algorithm.  Return the
    fitted y points as a sequence.

    This is a brute force implementation: the slope between all pairs
    of points is calculated, and the median value is assigned as
    the estimated slope.  The intercept is estimated by
    the median value of b = y - ax, where "a" is the median slope.

    The standard deviation of the slope is estimated using the linear
    least squares formula (since the Thiel-Sen slope is usually
    close to the least squares slope).  This will overestimate the
    S.D. of the slope if there are too many fliers.

    ARGUMENTS
    x -- a sequence of x-values (assumed exact).
    y -- a sequence of y-values (assumed to have errors).

    RETURNS
    a tuple (a list of the fitted y values, slope, intercept, estimated S.D. of slope)
    """

    slopes = []
    for i, _ in enumerate(x):
        for j in range(i+1, len(x)):
            if i == j or x[i] == x[j]:
                continue

            slope = 1.0*(y[j] - y[i]) / (x[j] - x[i])
            if x[i] &gt; x[j]:
                slope = -slope
            slopes.append(slope)

    med_slope = median(slopes)

    # y = ax + b
    b = median([_y - med_slope*_x for _x,_y in zip(x,y)])

    fitted = [med_slope * _x + b for _x in x]

    # Estimated SD of slope from least-squares formula:
    # Var(slope) = (1/(N-2)) * sum(yi_fitted - yi)^2 / sum(xi - x_avg)^2

    N = len(x)
    x_mean = 1.0 * sum(x) / N
    var_slope = (1.0/(N-2)) * sum([(y_fit - _y)**2 for y_fit, _y in zip(fitted, y)]) \
                / sum([(xi - x_mean)**2 for xi in x])
    sd_slope = var_slope**0.5

    return (fitted, med_slope, b, sd_slope)

</t>
<t tx="tom.20211211171913.38">def moving_median(xdata, ydata, w = 7):
    """Smooth a sequence of data values using a moving median.

    The median value within the window is placed at the center
    of the window.  For points closer to the start or end
    of the data set than the window width, the median is
    not computed.  This entails that the start and end of
    the data is truncated by half the window width.

    The window width should be odd;  if not, it is coerced
    to the next higher odd value.

    ARGUMENTS
    ydata -- the sequence of values to smooth
    w -- the width of the smoothing window to use.

    RETURNS
    a tuple (x, y), where y is the smoothed ydata.
    """

    if w % 2 == 0:
        w += 1

    results = []
    offset = w // 2
    for i in range(offset, len(ydata) - offset):
        results.append(median(ydata[i - offset:i + offset]))

    return xdata[offset: -offset], results


if __name__ == '__main__':

    from testing import smoother_tests

    for t in smoother_tests.Tests:
        t()
</t>
<t tx="tom.20211211171913.4">def plot(self, stackposition=MAIN, clearFirst=True):
    """Plot a 2-D graph.

    ARGUMENTS
    self -- an instance of a PlotManager
    stackposition -- an integer denoting which data set to plot.
    clearFirst -- True if the previous plot should be cleared, else False.

    RETURNS
    nothing
    """
    # pylint: disable = too-many-locals
    # pylint: disable = too-many-branches
    _dat = self.stack[stackposition]

    if stackposition &lt; STACKDEPTH:
        _linestyles = self.linestyles[stackposition]
    else:
        _linestyles = self.errorbar_linestyles

    if not _dat:
        self.announce('No data to plot')
        self.flashit()
        return

    _xdata = _dat.xdata
    _ydata = _dat.ydata

    f = self.figure
    &lt;&lt; get axes &gt;&gt;
    &lt;&lt; bail if no data &gt;&gt;
    &lt;&lt; setup labels &gt;&gt;
    canvas = self.canvas
    &lt;&lt; set axes appearance &gt;&gt;
    &lt;&lt; set linestyles &gt;&gt;
    &lt;&lt; set log or linear &gt;&gt;

    ax.plot(_xdata, _ydata, _color,
            linestyle=_ls, linewidth=_lw,
            marker=_marker, mec=_mec, mfc=_mfc, mew=_mew)

    self.fix_ticks()
    &lt;&lt; set max-min &gt;&gt;

    canvas.draw()
    if clearFirst:
        self.announce('')
</t>
<t tx="tom.20211211171913.40">@language python
@tabwidth -4
"""Compute various statistical measures for 2D data."""
@others
</t>
<t tx="tom.20211211171913.41">from __future__ import print_function

import math
import scipy.special
from scipy.stats import norm, t as t_test
from scipy.stats import spearmanr
import numpy as np

from smoother import correlationCoeff

</t>
<t tx="tom.20211211171913.42">def cdf(ydata):
    '''Compute Cumulative Distribution Function.  CDF is
    P(X &lt;= x), where X is a value of the random variable, and x
    is some chosen value. See e.g., Wikipedia at

    http://en.wikipedia.org/wiki/Cumulative_distribution_function#Definition

    The estimated variance of each point is P * (1-P)/N, where P is the
    CDF probability (see http://en.wikipedia.org/wiki/Empirical_distribution_function),
    and N is the number of data points.

    Return val, p, upperbound, lowerbound, where val are the input values,
    p are the calculated CDF probabilities, and upper/lowerbound are the
    estimated p +/- 1 standard deviations.
    point.

    ARGUMENT
    ydata -- a sequence of random values

    RETURNS
    A tuple of sequences (x, y, upperbound, lowerbound). x is a list of the ydata values.
    y is a list of the CDF values.  Upper/lowerbound are sequences of
    y +/-std. dev.
    '''

    _y = ydata[:]

    # To prevent ties between exactly equal values, increment adds a tiny
    # amount so none are exactly equal.  This may be a hack, but it
    # doesn't adversely affect the results and makes a number of
    # calculations much easier.
    dupes = {}
    temp = []
    for _val in _y:
        count = dupes.get(_val, 0) + 1
        dupes[_val] = count
        v = _val
        if count &gt; 1:
            v = v * (1.0 + count * 0.00001)
        temp.append(v)

    _y = temp
    _y.sort()

    # Cumulative probabilities
    x = []
    y = []
    upperbound = []
    lowerbound = []
    N = len(ydata)
    delta = 1.0 / (N + 1)
    prob = 0.0
    for val in _y:
        prob += delta
        sigma = (prob*(1-prob)/N)**0.5
        x.append(val)
        y.append(prob)
        upperbound.append(prob + sigma)
        lowerbound.append(prob - sigma)

    return (x, y, upperbound, lowerbound)

</t>
<t tx="tom.20211211171913.43">def histogram(data, nbins=10):
    '''Given a list of data points, compute the histogram.  The histogram's area
    sums to one, so that it is a probability distribution.  A data point
    will go into a bin when lower &lt;= y &lt; upper.  A bin is added to either end,
    so that the first bin will have zero counts and the last bin will contain
    the count of points with the highest value.  Thus, therre will be two
    more bins than requested.  The histogram is normalized to have an area of 1,
    so that its integral will be a CDF curve.

    ARGUMENTS
    data -- an array of data points.
    nbins -- the number of bins to put the values into.

    RETURNS
    a tuple of lists (x, y).  The format is

     pt p: 0   1  2   3   4   5   6            n
    x = [ 0, d, d,  2d,  2d,  3d,  3d,  4d,  ..., dxn-1, dxn]
    y = [y0, y0, y1, y1, y2, y2, ..., yn/2-1, yn/2-1]

    where d = bin width
    '''

    data.sort()
    ymax = 1.0 * data[-1]
    ymin = 1.0 * data[0]

    binwidth = (ymax - ymin) / nbins
    nbins = nbins + 2
    nmax = len(data)

    ny = 0  # index of y (data) array
    lower = ymin
    upper = ymin + binwidth

    binned = [(lower - binwidth, 0)]
    done = False
    count = 0

    while not done:
        if data[ny] &lt; upper:
            count += 1
            ny += 1
            if ny == nmax:
                binned.append((lower, count))
                done = True
        else:
            binned.append((lower, count))
            count = 0
            upper += binwidth
            lower += binwidth
        if ny == nmax:
            done = True

    sum = 0
    for lower, cnt in binned:
        sum += cnt
    _norm = 1.0 / (sum * binwidth)
    _x = []
    _y = []

    for lower, count in (binned):
        #lower, count = binned[n]
        _x.append(lower)
        _x.append(lower + binwidth)
        _ynorm = 1.0 * count * _norm
        _y.append(_ynorm)
        _y.append(_ynorm)

    lower += binwidth
    _x.append(lower)
    _x.append(lower + binwidth)
    _y.append(0)
    _y.append(0)

    return _x, _y

</t>
<t tx="tom.20211211171913.44">def meanstd(ydata):
    '''Compute the sample standard deviation s and mean of a set of data.
    Return a tuple (mean, s).

    ARGUMENT
    ydata -- a sequence of random values

    RETURNS
    a tuple (mean, stddev), or None if there are less than three points in the data
    '''

    N = len(ydata)
    if N &lt; 3: return None

    mean = 1.0*sum(ydata)/N
    sumsqr = sum([a**2 for a in ydata])
    std = math.sqrt((sumsqr - N*mean**2) / (N - 1))

    return (mean, std)

</t>
<t tx="tom.20211211171913.45">def fitNormalToCdf(values, probs, N=100):
    '''Fit a normal distribution to a CDF by matching its mean and std dev,
    then computing the normal CDF. A CDF curve has the data values
    in the x axis, and their probabilities in the y axis.  The CDF must
    have been created from data with no duplicate values.

    Return a normal CDF with N points running from
    m-4*sigma to m+4*sigma.

    Return a tuple of lists (xdata, ydata, mean, stddev).

    ARGUMENTS
    values -- a sequence of the CDF x-data points.
    probs -- a sequence of the CDF probability values.
    N -- Number of points to return.

    RETURNS
    a tuple (values, probs) of the normal CDF values.
    '''

    m, sigma = meanstd(values)

    lower = m - 4 * sigma
    upper = m + 4 * sigma

    stepsize = 1.0 * (upper - lower) / N
    _range = np.arange(lower, upper, stepsize)
    _gauss = norm.cdf(_range, m, sigma)

    _ydata = _gauss.tolist()
    _xdata = _range.tolist()

    return _xdata, _ydata, m, sigma

</t>
<t tx="tom.20211211171913.46">def calcNormalForCdf(values, mean=0.0, sigma=1.0):
    '''For a list of values, calculate the cumulative probability
    for a normal distribution.  Typically, the values are the
    x-axis values of a CDF curve.  Return a sequence of the
    calculated probabilities for each of the input points.

    ARGUMENTS
    values -- a list of values whose probabilities will be calculated.
    mean -- the mean of the normal distribution.
    sigma -- the standard deviation of the normal distribution.

    RETURNS
    a list of cumulative probabilities in the same order as the input values.
    '''

    # Scale values to t = (x - mean)/sigma*sqrt(2)
    mean = 1.0 * mean
    sigma = 1.0 * sigma
    scaled_values = [(v - mean) / (sigma * 2**0.5) for v in values]
    probs = scipy.special.erf(scaled_values)  # pylint: disable = no-member

    # erf() returns results in the range of (-1,1)
    # Rescale results back to the desired probability range (0,1)
    probs = [0.5 + 0.5*p for p in probs]

    return probs

</t>
<t tx="tom.20211211171913.47">def fitNormalToCdfAdaptive(values, probs, tolerance=.01):
    '''Given a CDF curve, fit a normal distribution to it by an
    adaptive process.  Return the final calculated probabilities, and
    the final mean standard deviation, and correlation coefficient between
    data and fitted curve..

    ARGUMENTS
    values -- a sequence of the CDF x-data points.
    probs -- a sequence of the CDF probability values.
    tolerance -- the maximum mean squared error allowed, as a fraction
                 of the mean of the original data.

    RETURNS
    a tuple (xdata, ydata, ms, sigma, correl)

    '''
    # pylint: disable = too-many-locals

    m, sigma = meanstd(values)

    # Calculate mean square error
    def sqrerror(values, probs, mean, sigma):
        '''Given a list of values and cdf probabilities, and a target
        mean and standard deviation for a normal distribution,
        Return the mse between the input and a normal distribution
        with the given mean and sigma.

        ARGUMENT
        values -- a list of data values
        probs -- a list of probabilities (the CDF) of the data

        RETURNS
        the mean squared error
        '''

        merr = 0.0
        Sxx = 0.0
        normalprobs = calcNormalForCdf(values, mean, sigma)
        numvals = len(values)
        for i in range(len(values)):
            data_prob = probs[i]
            err = normalprobs[i] - data_prob
            merr += err
            Sxx += (err**2) * data_prob
        merr = merr / numvals
        var = Sxx / numvals
        return var

    # Calculate mean absolute error
    def sqr_abs_error(values, probs, mean, sigma):
        '''Given a list of values and cdf probabilities, and a target
        mean and standard deviation for a normal distribution,
        Return the square of the mean absolute error between the input and
        a normal distribution with the given mean and sigma.

        ARGUMENT
        values -- a list of data values
        probs -- a list of probabilities (the CDF) of the data

        RETURNS
        the mean absolute error squared
        '''

        merr = 0.0
        normalprobs = calcNormalForCdf(values, mean, sigma)
        numvals = len(values)
        for i in range(len(values)):
            data_prob = probs[i]
            err = abs(normalprobs[i] - data_prob)
            merr += err
        merr = merr / numvals
        var = merr**2
        return var

    # Set initial iteration values
    ms = m - 3*sigma
    delta = 0.9 * sigma
    delta_limit = 0.5 * tolerance * sigma

    mse = sqr_abs_error(values, probs, ms, sigma)
    #print 'Iteration 0: mse=%0.2f, m=%0.2f' % (mse, ms)

    # Criteria for leaving the iteration
    # Sanity checks:
    #   delta &gt; delta min ... so we don't get stuck with a zero delta
    #   |ms - m| &lt; 5 sigma ... in case we start to diverge
    #
    # Convergence
    #    rmse/sigma &lt; tolerance  ... we've reached the goal
    #    delta/sigma &lt;= 2 * tolerance ... and we've been converging
    #
    # done = (not sanity) or converged

    done = False
    #count = 1
    new_mse = mse
    sane = True
    converged = False
    overshot = False
    #last_m = m

    while not done:
        #print 'Iteration', count
        #last_sign = (ms &lt;= last_m) # True for negative
        last_mse = new_mse
        #last_m = ms

        if overshot:
            delta = - delta / 2
            #print '   Overshot, changing delta/sigma to %0.3f' % (delta/sigma)
        ms += delta

        new_mse = sqrerror(values, probs, ms, sigma)

        overshot = new_mse &gt; last_mse

        delta_in_limits = (abs(delta) &gt; delta_limit)
        sane = delta_in_limits and abs(ms - m) &lt; 5 * sigma
        error_in_tolerance = (mse**0.5 &lt;= tolerance)
        converged = error_in_tolerance or not delta_in_limits

        done = ((abs(delta/sigma) &gt; 2 * tolerance) and (converged and overshot)) \
                    or not sane
#        print '   rms: %0.3f, ms: %0.3f, m: %0.3f, delta: %0.3f, tol %0.3f' %\
#                (new_mse**0.5, ms, m, delta, tolerance * sigma)
#        print '   Delta in limits? %s' % delta_in_limits
#        print '   Sane? %s' % sane
#        print '   Converged? %s' % converged
#        print '   Done? %s' % done
#        count += 1

    if converged:
        pass  #print 'Final mean: %0.3f' % ms
    else:
        #print 'Iterations are diverging too much'
        return [], [], m, sigma, 0

    # Set return values
    _probs = calcNormalForCdf(values, ms, sigma)
    _correl = correlationCoeff(probs, _probs)
    _xdata = values
    _ydata = _probs

    return _xdata, _ydata, ms, sigma, _correl

</t>
<t tx="tom.20211211171913.48">def spearman(x,y):
    '''Compute Spearman's rank correlation coefficient for two data sequences.
    Return the coefficient and its 95% confidence limit .

    See https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient

    We avoid ties by slightly altering equal values.  Then we can use the
    simplified formula

    R = 1 - 6 * (sum(di^2) /(n*(n^2-1))
    where di = yi - xi and n = number of points in either sequence.

    [Standard error of R is 0.6326/sqrt(n-1)]

    For Z-test:

        F = 0.5 ln((1 + r)/(1 - r))
        Z = F * sqrt((n-3)/1.06)

    Z indicates how large the sample R is relative to expected sample variation.

    For Student's t-test, t = r * sqrt((n-2)/(1-r^2))

    ARGUMENTS
    x, y -- The data sequences whose correlation is to be computed.  Must have same length.

    RETURNS
    a tuple (R, t, C), or None if the sequences are not the same length.  T is the
    value of Student's t, C is the width of the 95% confidence band for no
    correlation (actually, half the total width).
    '''

    # Alter data to avoid ties and calculate ranks

    if len(x) != len(y):
        return None

    def rank(data):
        '''Transform (pos, val) -&gt; {pos:rank} for the data.
        '''

        counts = {}
        delta = 0.00001
        newdata = []

        for pos, _ in enumerate(data):
            val = data[pos]
            n = counts.get(val, 0)
            if n &gt; 0:
                val = val*(1 + n * delta)
            n += 1
            newdata.append((val,pos))
        newdata.sort()

        ranks = {}
        for i, _ in enumerate(newdata):
            val, pos = newdata[i]
            ranks[pos] = i

        return ranks

    _x = rank(x)
    _y = rank(y)

    N = len(x)
    N2 = N**2

    #R = 0.0
    #for r in _x.keys():
        #d = _x[r] - _y[r]
        #R += d**2

    #_sum = sum(map(lambda x,y: (x-y)**2, _x.values(), _y.values()))
    _sum = sum([(x-y)**2 for x, y in zip(_x.values(), _y.values())])

    R = 1.0 - _sum*6.0 / (N * (N2 - 1))

#    #stderr = 0.6325 / (N - 1)**.5
#    if R == 1.0:
#        Z = 0.6325 / (N - 1)**.5
#    else:
#        F = 0.5 * math.log((1 + R)/(1 - R))
#        Z = F * math.sqrt((N-3.)/1.06)

    if R == 1.0:
        return R, 0., 0.

    t = R * math.sqrt((N - 2)/(1. - R*R))
    C = t_test.interval(0.95, N-2)[1]  # t-test 95% confidence interval
    return R, t, C

</t>
<t tx="tom.20211211171913.49">def pearson(x,y):
    '''Given two sequences of the same length, return the sample Pearson correlation coefficient.
    See
        http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient

    ARGUMENTS
    x, y -- equal-length sequences of numbers.

    RETURNS
    Pearson's correlation coefficient, r
    '''

    N = len(x)
    xm = 1.0*sum(x)/N
    ym = 1.0*sum(y)/N

    # Deviations x - xm, y - ym
    xdev = [z - xm for z in x]
    ydev = [z - ym for z in y]

    # Cross products
    xy = sum(map(lambda a,b: a*b, xdev, ydev))

    # Sum Squares
    x2 = sum(map(lambda a: a**2, xdev))
    y2 = sum(map(lambda a: a**2, ydev))

    r = xy / (x2*y2)**.5

    return r
</t>
<t tx="tom.20211211171913.51">"""Draw vertical marker at specified x-axis position.

This method will be imported by the PlotManager class, hence
the use of the "self" argument.
"""
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171913.52">from colors import CORNFLOWERBLUE
from Linestyle import LINETHIN

</t>
<t tx="tom.20211211171913.53">def timehack(self, x=118):
    """Draw vertical line at the specified location on the x-axis.

    Used to mark a specific x-axis value.
    """
    ax = self.axes
    # This calculation could be improved.  It should use the graph pane
    # limits, but instead it uses the data limits.
    ax.plot((x, x), ax.get_ylim(), CORNFLOWERBLUE, linewidth=LINETHIN)
    self.canvas.draw()

    return 'break'
</t>
<t tx="tom.20211211171913.55">"""This module contains tests relating to trends in data series."""

@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171913.56">from __future__ import print_function

import numpy as np
import scipy.stats

YESNO = {True:'yes', False:'no'}

</t>
<t tx="tom.20211211171913.57">def mann_kendall(x, alpha = 0.05):
    """
    &lt;&lt;docstring &gt;&gt;
    """

    n = len(x)

    # calculate S    
    listMa = np.matrix(x)               # convert input List to 1D matrix
    subMa = np.sign(listMa.T - listMa)  # calculate all possible differences in matrix
                                        # with itself and save only sign of difference (-1,0,1)
    s = np.sum( subMa[np.tril_indices(n,-1)] ) # sum lower left triangle of matrix

    # calculate the unique data
    # return_counts=True returns a second array that is equivalent to tp in old version    
    unique_x = np.unique(x, return_counts=True)
    g = len(unique_x[0])

    # calculate the var(s)
    if n == g: # there is no tie
        var_s = (n*(n-1)*(2*n+5))/18
    else: # there are some ties in data       
        tp = unique_x[1]
        var_s = (n*(n-1)*(2*n+5) + np.sum(tp*(tp-1)*(2*tp+5)))/18

    if s&gt;0:
        z = (s - 1)/np.sqrt(var_s)
    elif s == 0:
        z = 0
    elif s&lt;0:
        z = (s + 1)/np.sqrt(var_s)

    # calculate the p_value
    p = 2*(1-scipy.stats.norm.cdf(abs(z))) # two tail test
    h = abs(z) &gt; scipy.stats.norm.ppf(1-alpha/2)

    return s, z, h, p

if __name__ == '__main__':
    dat = np.random.rand(100)
    s, z, h, p = mann_kendall(dat)
    print(f's: {s}, z: {z:.3f}, trend? {YESNO[h]}, p: {p:.3f}')
</t>
<t tx="tom.20211211171913.6">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211171913.7">from __future__ import print_function

from random import random as rand
from random import uniform, gauss

</t>
<t tx="tom.20211211171913.8">def rand_vals(count=256):
    '''Return values chosen randomly from interval [0,1).

    ARGUMENT
    count -- number of values to return.

    RETURNS
    A tuple of lists (x,y).  The y values are the computed random variates,
    and the x values are sequentially numbered from 1.
    '''

    x = []
    y = []
    for n in range(1, count + 1):
        x.append(n)
        y.append(rand())

    return (x,y)

</t>
<t tx="tom.20211211171913.9">def uniform_vals(a=-0.5, b=0.5, count=256):
    '''Return values chosen randomly from interval [min, max].

    ARGUMENTS
    a -- minimum value to return
    b -- maximum value to return
    count -- number of values to return.

    RETURNS
    A tuple of lists (x,y).  The y values are the computed random variates,
    and the x values are sequentially numbered from 1.
    '''

    x = []
    y = []
    for n in range(1, count + 1):
        x.append(n)
        y.append(uniform(a,b))

    return (x,y)

</t>
<t tx="tom.20211211181438.10">def readfile(fname):
    if not fname: return None
    with open(fname, encoding = ENCODING) as f:
        lines = f.readlines()

    xdata = []
    ydata = []
    for line in lines:
        text = line.strip()
        if not text: continue
        if text[0] == ';': continue
        fields = text.split()
        if len(fields) &lt; 2: return None

        xdata.append(float(fields[0]))
        ydata.append(float(fields[1]))

    return xdata, ydata


if __name__ == '__main__':
    import matplotlib.pyplot as plt
    from os.path import basename

    def plot_permutes_lstsrq(parms):
        xdata = parms['xdata']
        ydata = parms['ydata']
        N = parms['N']
        deg = parms.get('deg') or 1
        fname = parms.get('fname') or ''

        permutes = permuted_lstsqr(xdata, ydata, N, deg)

        # Statistics of ydata
        mean = 0
        meansqr = 0
        num = len(ydata)

        for y in ydata:
            mean += y
            meansqr += sqr(y)
        mean = float(mean) / num
        meansqr = float(meansqr) / num

        var = meansqr - sqr(mean)
        sigma = sqrt(var) * sqrt(num/(num-1))
        stderr = sigma /sqrt(num)

        print('Y mean: %0.3f   Y sigma: %0.3f   Y std err: %0.3f' % (mean, sigma, stderr))

        #fig = plt.figure()
        plt.get_current_fig_manager().set_window_title('Randomization Test Of Null Hypothesis') 
        plt.subplot(1, 1, 1)

        for p in permutes:
            plt.plot(xdata, p, '0.75', linewidth=1)

        plt.plot(xdata, ydata, 'ko')

        # Plot least squares fit
        coeffs = polyfit(xdata, ydata, deg)
        p = poly1d(coeffs)
        plt.plot(xdata, [p(x) for x in xdata], 'k', linewidth=2)

        if fname: plt.suptitle(fname)
        plt.title('%s Linear Least Square Fits to Permuted Data' % N)
        
        plt.show()

    def plot_permutes_lowess(parms={}):
        xdata = parms['xdata']
        ydata = parms['ydata']
        smooth = parms.get('smooth') or 5
        fname = parms.get('fname') or ''

        rss0, ymean, stddev = null_rss(ydata)
        print('Null hypothesis RSS: %0.3f' % rss0)
        print('Null hypothesis mean, std dev: %0.3f, %0.3f' % (ymean, stddev))

        n = len(ydata)
        x, y, mse, _, _ = lowess2(xdata, ydata, smooth)
        print('RSS for LOWESS fit: %0.3f' % (mse*n))

        Tnull = null_T(rss0, n * mse)

        print('Fitted T statistic for null hypothesis: %0.3f' % Tnull)

        tstats = permuted_T(xdata, ydata, 1000, smooth, rss0)

        p = pnull(tstats, Tnull)
        print('Probability of fitted curve if null hypothesis is right:',)
        if p &lt; 1.0e-3:
            print('%1.2e' % p)
        else:
            print('%0.3f' % p)

        #fig = plt.figure()
        plt.get_current_fig_manager().set_window_title('Randomization Test Of Null Hypothesis - LOWESS fits') 
        plt.subplot(1, 1, 1)
        plt.plot(xdata, ydata, 'bo')
        plt.plot(xdata, y, 'b')

        plt.title('Prob(Fitted Curve) = %0.3f If Null Hypothesis Is Right' % p)
        if fname: plt.suptitle(fname)

        plt.show()

    if len(sys.argv) &gt; 1:
        fname = sys.argv[1]
        xdata, ydata = readfile(fname)
        file = basename(fname)
    else:
        xdata = [1,2,3,4,5,6,7]
        ydata = [1,3,2,5,5,7,6]
        file = ''

        #xdata = [1,2,3,4,5,6,7]
        #ydata = [1,3,8,18,29,31,50]

    if len(sys.argv) &gt; 2:
        smooth = int(sys.argv[2])
        N = smooth
    else:
        smooth = 8
        N = 100

    tests = {'Permute-LOWESS': plot_permutes_lowess,
                'Permute-Lstsqr': plot_permutes_lstsrq}

    parms = {'Permute-LOWESS': {
                'xdata':xdata,
                'ydata':ydata,
                'smooth':smooth,
                'fname':file},
             'Permute-Lstsqr': {
                'xdata':xdata,
                'ydata':ydata,
                'N':N,
                'deg': 1,
                'fname':file}
            }

    t = 'Permute-Lstsqr'
    #t = 'Permute-LOWESS'
    tests[t](parms[t])
</t>
<t tx="tom.20211211181438.12">@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211181438.13">"""Piecewise Linear and other curve fitting procedures."""

from __future__ import print_function

import pwlf

</t>
<t tx="tom.20211211181438.14">def piecewiseLinear(x, y, num):
    """Return an optimum piece-wise 2-D linear fit.

    ARGUMENTS
    x -- (sorted) list or numpy array of independent variable values.
    y -- list or numpy array of dependent values corresponding
         to the x values.
    num -- number of segments to use for the fit.

    RETURNS
    a numpy 1-D array of fitted y values
    """
    
    fitter = pwlf.PiecewiseLinFit(x, y, False)
    
    fitter.fit(num)    
    yHat = fitter.predict(x)

    return yHat

if __name__ == '__main__':
    def show(a,b):
        for i, z in enumerate(a):
            print (z, b[i])

    x = [1,2,3,4,5,6]
    y = [1.1,2.05,2.85,5.07,6.92,9.3]
    show(x, y)
    print()

    yh = piecewiseLinear(x, y, 2)

    show(x, yh)
</t>
<t tx="tom.20211211181438.2"># pylint: disable = consider-using-f-string
@others
@language python
@tabwidth -4
</t>
<t tx="tom.20211211181438.3">'''Test a fitted regression against the null hypothesis of no relationship.'''

import sys
from math import sqrt
from random import sample
from numpy import polyfit, poly1d

from smoother import lowess2, sqr

ENCODING = 'utf-8'
</t>
<t tx="tom.20211211181438.4">def null_rss(ydata):
    '''Calculate the residual sum of squares of a sequence (i.e.,
    the square deviations from the mean).

    ARGUMENT
    ydata -- a sequence of data values.

    RETURNS
    a tuple containing the sum of squares of the residuals, the mean
    y value, and the sample standard deviation
    '''

    n = len(ydata)
    mean = 0.0
    for y in ydata:
        mean += y
    mean = mean / n
#    y0sqr = mean * mean

    rss0 = 0.0
    for y in ydata:
        rss0 += sqr(y - mean)

    var = rss0
    try:
        stddev = sqrt(var) / sqrt(n-1)
    except Exception as e:
        print(e)
        print(n, var)
        sys.exit(0)

    return rss0, mean, stddev

</t>
<t tx="tom.20211211181438.5">def null_T(rss0, rssx):
    '''Calculate a T statistic for two sets of points, using their residual
    sum of squares.  Return the T statistic.  T is used to assess
    whether the two sets of data points differ only by chance or not.
    T is calculated by

        T = (rss0 - rssx)/ rss0

    ARGUMENTS
    rss0 -- the residual sum of squares for the null hypothesis
    rssx -- the residual sum of squares for a fitted curve to the original 
    data set.

    RETURNS
    the T statistic.
    '''

    return (rss0 - rssx) / rss0

</t>
<t tx="tom.20211211181438.6">def permuted_T(xdata, ydata, N, smooth, rss0):
    '''Permute xdata, then fit using LOWESS.  Repeat N times.
    Return the T statistic of the permuted data.

    ARGUMENTS
    xdata, ydata -- the original sequence of data points
    N -- the number of permutations to perform
    smooth -- the one-sided width of the smoothing zone for LOWESS smoothing
    rss0 -- the residual sum of squares of the null hypothesis

    RETURNS
    a list of the N T statistics
    '''

    n = len(ydata)

    Tstat = []
    for i in range(N):
        newy = sample(ydata, n)
        x, y, mse, _, _ = lowess2(xdata, newy, smooth)
        Tstat.append(null_T(rss0, n * mse))
        
    return Tstat

</t>
<t tx="tom.20211211181438.7">def permuted_lstsqr(xdata, ydata, N, deg=1):
    '''Permute xdata, then fit using linear least sqiares.  Repeat N times.
    Return a list of the fitted curves

    ARGUMENTS
    xdata, ydata -- the original sequence of data points
    N -- the number of permutations to perform

    RETURNS
    a list of the fitted curves [ [y11,y12,...], [y21,y22,...], ...]
    '''

    n = len(ydata)
    fitted_curves = []
    for i in range(N):
        newy = sample(ydata, n)
        coeffs = polyfit(xdata, newy, deg)
        p = poly1d(coeffs)
        fitted_curves.append([p(x) for x in xdata])

    return fitted_curves

</t>
<t tx="tom.20211211181438.8">def pnull(tstats, tfit):
    '''Calculate probability that the null hypothesis is correct.
    Return the probability.

    ARGUMENTS
    tstats -- a sequence of the randomized test statistics
    tfit -- the test statistic for the fitted data

    RETURNS
    the probability that the fitted test statistic would be larger than it
    is, just by chance, if the null hypothesis were true.
    '''

    count = 0
    for t in tstats:
        if t &gt; tfit: count += 1

    return (1.0 * count) / len(tstats)

</t>
<t tx="tom.20211211181438.9">def dist(tstats):
    '''Calculate the probability distribution of the test statistic.
    Return a list of (p, count) values.

    ARGUMENT
    tstats -- a sequence of the randomized test statistics
    
    RETURNS
    a list [(p1, n1), ...] sorted by the p values
    '''

    probs = []
    counts = {}
    for t in tstats:
        counts[t] = counts.get(t, 0) + 1

    N = float(len(tstats))
    for t in counts:
        counts[t] = counts[t] / N

    probs = counts.items()
    probs.sort()

    return probs

</t>
<t tx="tom.20211211223207.1">from __future__ import print_function

try:
    import Tkinter as Tk
except:
    import tkinter as Tk

# try:
    # from Tkinter import Toplevel
# except:
    # from tkinter import Toplevel

try:
    import tkFont
except:
    import tkinter.font as tkFont

try:
    import ttk
except:
    from tkinter import ttk

from buttondefs import (SPACER, CURVE_FIT_BUTTONS, STATS_BUTTONS,
                        GENERATOR_BUTTONS, PLOT_BUTTONS, LOAD_BUTTONS,
                        STACK_BUTTONS, CURVE_BUTTONS, MATH_BUTTONS,
                        DATA_PROCESSING_BUTTONS, WINDOW_BUTTONS, 
                        SMOOTHER_FIT_BUTTONS, TREND_BUTTONS)
</t>
<t tx="tom.20211212001620.1">if __name__ == '__main__':
    import matplotlib.pyplot as plt
    from pylab import gcf  # rcParams
    import randnum

    def self_printer(f):
        def new_f():
            print(f.__name__)
            if f.__doc__: 
                print (f.__doc__)
            print()
            f()
            print()
        return new_f

    randn = np.random.randn

    def testCDF():
        data = [1,5,2,6,2,3,5]
        data = [randn() for n in range(50)]
        xdata, ydata, _, _ =  cdf(data)

        plt.plot(xdata, ydata, '-')
        plt.plot(xdata, ydata, 'bo')

        plt.show()

    def testCDF2Normal():
        data = [randn() for n in range(20)]
        data = [28,8,-3,7,-1,1,18,12]
        xdata, ydata, _, _ =  cdf(data)

        normvalues = fitNormalToCdf(xdata, ydata, 100)

        x,y, m, s = normvalues
        print('mean:', m)
        print('sigma:', s)
        print()

        plt.plot(xdata, ydata, 'bo')
        plt.plot(x, y, 'r-')
        plt.show()

    def testCalcNorm():
        data = [28,8,-3,7,-1,1,18,12]
        #data = [randn() for n in range(8)]
        xdata, ydata, _, _ = cdf(data)

        probs = calcNormalForCdf(xdata, 6, 10.44)

        plt.plot(xdata, ydata, 'bo')
        plt.plot(xdata, probs, 'r-')
        plt.show()

    def testNormCDF():
        lower = -4 # in sigma
        upper = 4
        m = 1
        sigma = 1.0
        N = 1000
        stepsize = 1.0 * (upper - lower) / N
        _range = np.arange(lower, upper, stepsize)
        _gauss = norm.cdf(_range, m, sigma)

        _ydata = _gauss.tolist()
        _xdata = _range.tolist()

        plt.plot(_xdata, _ydata, '-')
        plt.show()

    def testFitNormalAdaptive():
        data = [28,8,-3,7,-1,1,18,12]
        #data = [randn() for n in range(10000)]
        xdata, ydata, _, _ = cdf(data)

        tolerance = 0.001

        values, probs, m, s, _ = fitNormalToCdfAdaptive(xdata, ydata, tolerance)
        print(f'mean: {m:.3f}, sigma: {s:.2f}')

        plt.plot(xdata, ydata, 'bo')
        plt.plot(values, probs, 'r-')
        plt.show()

    def testSdevDist():
        '''Compute mean and variance of variances of a Gaussian distribution.
        '''

        size = 100000
        sample_sdev = 10.44
        sample_size = 8
        vars = []  # Sample variances
        means = []
        for i in range(size):
            index, counts = randnum.gaussian_vals(0, sample_sdev, sample_size)
            m, s = meanstd(counts)
            vars.append(s**2)

        index1, varprob, _, _ = cdf(means)

        m,s = meanstd(vars)
        print('sample size={}, sample standard deviation={:.3f}'.format (\
            sample_size, sample_sdev))
        print('variances: mean={:.3f}, sdev = {:.3f}'.format (m**.5, s**.5))

        x, sdev, _, _ = cdf(vars)
        plt.plot(x, sdev, '-')
        plt.show()

    @self_printer
    def testSpearman():
        x = (106,86,100,101,99,103,97,113,112,110)
        y = (7,0,27,50,28,29,20,12,6,17)

        r, t, C = spearman(x,y)
        N = len(x)
        print('1) r={:.3f}, t: {:.3f} Confidence limit={:.3f}'.format(r, t, C), )
        rmax = C * math.sqrt((1 - r*r)/(N -2))
        print('Rmax = {:.3f}'.format(rmax))

        x = (1, 2, 3 ,4, 5)
        y = (1.5, 2.2, 5, 4.5, 6)
        r, t, C = spearman(x,y)
        N = len(x)
        print('2) r={:.3f}, t: {:.3f} Confidence limit={:.3f}'.format(r, t, C),)
        rmax = C * math.sqrt((1 - r * r) / (N - 2))
        print('Rmax = {:.3f}'.format(rmax))

    @self_printer
    def testCorrelations():
        '''Calculate Pearson and Spearman correlation coefficients'''
        x = (106,86,100,101,99,103,97,113,112,110)
        y = (7,0,27,50,28,29,20,12,6,17)

        r = pearson(x,y)
        rspear, t, C = spearman(x,y)
        s = 0.6326/math.sqrt(len(x)-1)

        print("1) Pearson's r: {:.3f}".format(r))
        print("1) Spearman's r: {:.3f}, t={:.3f}, C={:.3f}, SE={:.3f}".format(rspear, t, C, s))
        print()

        x = (1, 2, 3 ,4, 5)
        y = (1.5, 2.2, 5, 4.5, 6)
        r = pearson(x,y)
        rspear, t, C = spearman(x,y)
        s = 0.6326/math.sqrt(len(x)-1)

        print("2) Pearson's r: {:.3f}".format(r))
        print("2) Spearman's r: {:.3f}, t={:.3f}, C={:.3f}, SE={:.3f}".format(rspear, t, C, s))

    @self_printer
    def test_spearmanr():
        '''Pearson correlation coefficient using Scipy library routine.'''
        x = (106,86,100,101,99,103,97,113,112,110)
        y = (7,0,27,50,28,29,20,12,6,17)
        r, p = spearmanr(x, y)
        print('1) r={:.3f}, p={:.3f}'.format(r,p))

        x = (1, 2, 3 ,4, 5)
        y = (1.5, 2.2, 5, 4.5, 6)
        r, p = spearmanr(x, y)
        print('2) r={:.3f}, p={:.3f}'.format(r,p))

    @self_printer
    def test_meanstd():
        x = [1,2,3,4,5]
        m, s = meanstd(x)
        print('Mean\tstd')
        print('{:.3f}\t{:.3f}'.format(m, s))

    def runtests(testlist):
        for t in testlist:
            #print 'Running %s' % t.func_name
            #if t.func_doc: print t.func_doc
            figure = gcf()
            #figure.canvas.set_window_title(t.func_doc or t.func_name)
            figure.canvas.set_window_title(t.__name__)
            t()
            print()

    Tests = (testCalcNorm, )  #, testCorrelations, test_spearmanr#, testSpearman
    runtests(Tests)</t>
<t tx="tom.20220115175032.1">    if _dat is None or \
            (_xdata is None or len(_xdata) == 0) or \
            (_ydata is None or len(_ydata) == 0):
        if clearFirst:
            ax.clear()
            self.fix_ticks()
            self.canvas.show()
        return

</t>
<t tx="tom.20220115175205.1">_figlabel = ''
_xlabel = ''
_ylabel = ''
if clearFirst:
    _figlabel = _dat.figurelabel
    _xlabel = _dat.xaxislabel
    _ylabel = _dat.yaxislabel
else:
    _main = self.stack[MAIN]
    _figlabel = _main.figurelabel
    _xlabel = _main.xaxislabel
    _ylabel = _main.yaxislabel

self.set_editable_labels()
</t>
<t tx="tom.20220115175337.1">if self.semilogY:
    ax.set_yscale('log')
else:
    ax.set_yscale('linear')

if self.semilogX:
    ax.set_xscale('log')
else:
    ax.set_xscale('linear')

</t>
<t tx="tom.20220115175458.1">_color = _linestyles.linecolor
_lw = _linestyles.linewidth
_mec = _linestyles.sym_mec
_mfc = _linestyles.sym_mfc
_mew = _linestyles.sym_mew

_plotsyms = _linestyles.useSym
_plotline = _linestyles.useLine

if _plotsyms:
    _marker = _linestyles.symbol
else:
    _marker = SYM_NONE

if _plotline:
    _ls = _linestyles.linestyle
else:
    _ls = LINE_NONE
</t>
<t tx="tom.20220115175642.1">if not self.axes:
    try:  # Python 2.7
        ax = f.add_subplot(111, axisbg=self.bgcolor)
    except:  # Python 3.7
        ax = f.add_subplot(111, facecolor=self.bgcolor)
    self.axes = ax
else:
    ax = self.axes
</t>
<t tx="tom.20220115175943.1">if hasattr(_dat, 'ymin'):
    ax.set_ylim(bottom=_dat.ymin)

if hasattr(_dat, 'ymax'):
    ax.set_ylim(top=_dat.ymax)
</t>
<t tx="tom.20220115225226.1">lab_fontsize = int(lab.get_size())
tkfont = tkFont.Font(size=lab_fontsize)

bbox = lab.get_window_extent()
ul, lr = bbox.get_points()
ulx, uly = ul
lrx, lry = lr

canvas = self.canvas
dpi = canvas.figure._dpi
canvas_bbox_ul = canvas.figure.bbox_inches.get_points()[1]
canv_ulx, canv_uly = \
    int(dpi * canvas_bbox_ul[0]), int(dpi * canvas_bbox_ul[1])

ew.configure(font=tkfont)
</t>
<t tx="tom.20220401195652.1">plotSubmenu = Tk.Menu(self.root)

commands = (
    ("Plot", self.plotmain, 0),
    ("Overplot Main", self.overplot, 10),
    ("Overplot Buffer", self.overplotbuff, 9)
)

for label, command, underline in commands:
    plotSubmenu.add_command(label = label, command = command, underline = underline)

plotSubmenu.add_separator()


commands = (
    ('Lin-lin', self.setLinLin),
    ('Semilog(Y)', self.setSemilogY),
    ('Semilog(X)', self.setSemilogX),
    ('Log-log', self.setLogLog)
)

for label, command in commands:
    plotSubmenu.add_radiobutton(label = label, command = command)

</t>
<t tx="tom.20220401195940.1">fileSubmenu = Tk.Menu(self.root)
fileSubmenu.add_command(label='Open',
    command=self.load_data,
    underline=0)
fileSubmenu.add_command(label='Load From Dialog', 
    command=self.load_data_from_popup, underline=0)
fileSubmenu.add_command(label='Save',
    command=self.save_data,
    underline=0, state=Tk.ACTIVE)
fileSubmenu.add_separator()
fileSubmenu.add_command(label="eXit", command=self.quit,
    accelerator='&lt;Alt-F4&gt;', underline=1)
</t>
<t tx="tom.20220401195954.1">stackSubmenu = Tk.Menu(self.root)
stackSubmenu.add_command(label='Copy To Buffer', 
            command=self.copyToBuffer, underline=0)
stackSubmenu.add_command(label='Swap Main and Buffer', 
            command=self.swap_data, underline=1)
stackSubmenu.add_command(label='Copy From Buffer', 
            command=self.paste_data, underline=0)
stackSubmenu.add_separator()
stackSubmenu.add_command(label='Copy From Top',
            command=self.copy_from_top, underline=5)
stackSubmenu.add_command(label='Copy To Top',
            command=self.copy_to_top, underline=3)
stackSubmenu.add_separator()
stackSubmenu.add_command(label='Push with Copy',
            command=self.push_with_copy, underline=3)
stackSubmenu.add_command(label='Drop', 
            command=self.drop_stack, underline=0)
stackSubmenu.add_command(label='Rotate Up', 
            command=self.rotate_stack_up, underline=7)
stackSubmenu.add_command(label='Rotate Down', 
            command=self.rotate_stack_down, underline=7)
</t>
<t tx="tom.20220401200034.1">curveSubmenu = Tk.Menu(self.root)
curveSubmenu.add_command(label='Pad/Truncate',
    command=self.pad_truncate,
    underline=4)
curveSubmenu.add_command(label='Shift Left/Right',
    command=self.shift, underline=1)
curveSubmenu.add_command(label='Thin',
    command=self.decimate, underline=0)
curveSubmenu.add_command(label='Transpose', 
    command=self.transpose, underline=1)
curveSubmenu.add_command(label='Sort On X',
    command=self.sortX, underline=2)
curveSubmenu.add_command(label='Make Phase Space', 
    command=self.make_phasespace, underline=1)
curveSubmenu.add_command(label='Y vs X',
    command=self.YvsX, underline=1)
curveSubmenu.add_separator()
curveSubmenu.add_command(label='Set Number Of Points',
    command=self.setNumPoints, underline=4)
curveSubmenu.add_command(label='Replace X Axis',
    command=self.replaceX, underline=8)
</t>
<t tx="tom.20220401200047.1">waveformMathSubmenu = Tk.Menu(self.root)

waveformMathSubmenu.add_command(label='Add Buffer',
    command=self.addBuffer, underline=0)
waveformMathSubmenu.add_command(label='Subtract From Buffer',
    command=self.subFromBuffer, underline=0)
waveformMathSubmenu.add_command(label='Multiply By Buffer',
    command=self.mulBuffer, underline=0)
waveformMathSubmenu.add_command(label='Divide Into Buffer',
    command=self.divBuffer, underline=0)

waveformMathSubmenu.add_separator()

waveformMathSubmenu.add_command(label='Differentiate',
    command=self.differentiate, underline=0)
waveformMathSubmenu.add_command(label='Integrate',
    command=self.integrate, underline=0)

waveformMathSubmenu.add_separator()

waveformMathSubmenu.add_command(label='Add Constant',
    command=self.add_constant, underline=4)
waveformMathSubmenu.add_command(label='Scale', command=self.scale,
    underline=3)
waveformMathSubmenu.add_command(label='Log10', command=self.log10,
    underline=2)
waveformMathSubmenu.add_command(label='Natural Log', 
    command=self.log, underline=0)

waveformMathSubmenu.add_separator()

waveformMathSubmenu.add_command(label='Square', command=self.square,
    underline=1)
waveformMathSubmenu.add_command(label='Rectify', command=self.rectify,
    underline=0)
waveformMathSubmenu.add_command(label='Normalize', command=self.normalize,
    underline=0)
</t>
<t tx="tom.20220401200120.1">dataProcessingSubmenu = Tk.Menu(self.root)
dataProcessingSubmenu.add_command(label='FFT', command=self.fft,
    underline=0)
dataProcessingSubmenu.add_command(label='Convolve With Buffer',
    command=self.convolveWithBuffer, underline=2)
dataProcessingSubmenu.add_command(label='Correlate With Buffer',
    command=self.correlateWithBuffer, underline=0)
dataProcessingSubmenu.add_command(label='AutoCorrelation',
    command=self.autocorrelate, underline=0)
dataProcessingSubmenu.add_command(label='Moving Median',
    command=self.moving_median, underline=0)

dataProcessingSubmenu.add_command(label='Low Pass RC Filter',
    command=self.lopass, underline=0)
dataProcessingSubmenu.add_command(label='High Pass RC Filter',
    command=self.hipass, underline=0)
</t>
<t tx="tom.20220401200152.1">windowSubmenu = Tk.Menu(self.root)
dataProcessingSubmenu.add_cascade(label='Window', menu=windowSubmenu)
windowSubmenu.add_command(label='Half Cos Window',
    command=self.h_cosine, underline=0)
windowSubmenu.add_command(label='Full Cosine Window',
    command=self.full_cosine, underline=0)
windowSubmenu.add_command(label='Half Supergaussian Window',
    command=self.h_super_gaussian, underline=0)
windowSubmenu.add_command(label='Gaussian Window',
    command=self.gaussian_window, underline=0)
windowSubmenu.add_command(label='Supergaussian Window',
    command=self.super_gaussian, underline=0)
</t>
<t tx="tom.20220401200202.1">smoothSubmenu = Tk.Menu(self.root)
smoothSubmenu.add_command(label='Cubic Spline Fit',
    command=self.cubicSpline)
smoothSubmenu.add_command(label='Linear Least Squares Fit',
    command=self.leastsqr)
smoothSubmenu.add_command(label='Least Square Quadratic Fit',
    command=self.leastsqr_quad)
smoothSubmenu.add_separator()
smoothSubmenu.add_command(label='Lowess Linear', command=self.lowess,
                 underline=0)
smoothSubmenu.add_command(label='Lowess Quadratic', command=self.lowess2Quad,
                 underline=7)
smoothSubmenu.add_command(label='Lowess Adaptive',
    command=self.lowess_adaptive, underline=7)
smoothSubmenu.add_command(label='Adaptive LOWESS by Autocorrelation',
    command=self.lowess_adaptive_ac, underline=23)
smoothSubmenu.add_separator()

smoothSubmenu.add_command(label='Poisson Smooth', command=self.poissonSmooth,
                underline=1)
smoothSubmenu.add_separator()

smoothSubmenu.add_command(label='Spline Smooth',
    command=self.spline_smooth, underline=0)
</t>
<t tx="tom.20220401200234.1">statsSubmenu = Tk.Menu(self.root)
statsSubmenu.add_command(label='CDF', command=self.cdf, underline=1)
statsSubmenu.add_command(label='Fit CDF With Normal', 
    command=self.fitCdfWithNormal, underline=0)
statsSubmenu.add_command(label='Fit CDF With Normal Adaptive',
    command=self.fitCdfNormalAdaptive, underline=20)
statsSubmenu.add_command(label='Histogram', command=self.histogram,
    underline=0)
statsSubmenu.add_separator()
statsSubmenu.add_command(label='Mean, Std Dev', underline = 0,
    command=self.mean_std)
statsSubmenu.add_command(label='Correlation Coefficient',
    command=self.correlationCoeff, underline=15)
statsSubmenu.add_command(label='Spearman Rank Correlation',
    command=lambda x='spearman': self.interpret(x), underline=4)

statsSubmenu.add_command(label='Sliding Variance',
    command = self.sliding_var)
</t>
<t tx="tom.20220401200248.1">generateSubmenu = Tk.Menu(self.root)
generateSubmenu.add_command(label='Exponential',
    command=self.makeExponential, underline=0)
generateSubmenu.add_command(label='Sine Wave',
    command = self.makeSine, underline=0)
generateSubmenu.add_command(label='Damped Sine',
    command = self.makeDampedSine, underline=0)
generateSubmenu.add_separator()

generateSubmenu.add_command(label='Delta Function', 
    command=self.makeDelta, underline=0)
generateSubmenu.add_command(label='Step',
    command = self.makeStep, underline=0)
generateSubmenu.add_command(label='Ramp',
    command = self.makeRamp, underline=3)
generateSubmenu.add_command(label='Square Wave', 
    command=self.makeSquarewave, underline=2)

generateSubmenu.add_separator()
generateSubmenu.add_command(label='Gaussian PDF', 
    command = self.pdfGaussian, underline=0)
generateSubmenu.add_command(label='Gaussian CDF', 
    command = self.cdfGaussian, underline=10)
generateSubmenu.add_separator()

generateSubmenu.add_command(label='Random Noise',
    command=self.makeRandomNoise, underline=0)
generateSubmenu.add_command(label='Uniform Noise',
    command=self.makeUniformNoise, underline=0)
generateSubmenu.add_command(label='Gaussian Noise',
    command=self.makeGaussianNoise, underline=0)

</t>
<t tx="tom.20220401200301.1">mainMenu.add_cascade(label='File', menu=fileSubmenu)

mainMenu.add_cascade(label='Plot', menu=plotSubmenu)
# mainMenu.add_cascade(label='Stack', menu=stackSubmenu, underline=4)
# mainMenu.add_cascade(label='Curve', menu=curveSubmenu)
# mainMenu.add_cascade(label='Waveform Math', menu=waveformMathSubmenu,
    # state=Tk.NORMAL)
# mainMenu.add_cascade(label='Data Processing',
    # menu=dataProcessingSubmenu)
# mainMenu.add_cascade(label='Fit/Smooth',
    # menu=smoothSubmenu, underline=1)
# mainMenu.add_cascade(label='Statistics', menu=statsSubmenu,
    # state=Tk.ACTIVE, underline=0)
# mainMenu.add_cascade(label='Generate', menu=generateSubmenu)
mainMenu.add_cascade(label='Help', menu = helpSubmenu)</t>
<t tx="tom.20220401200321.1"># ========== Test Only ==================================
testMenu = Tk.Menu(self.root)
testMenu.add_command(label='Open Aux Window', command=self.openAuxWin)
testMenu.add_command(label='Overplot Y (lambda)', 
    command=lambda x='overplotbuf': self.interpret(x))
testMenu.add_command(label='Variance Ratio', command=self.var_ratio)
#        testMenu.add_command(label='Change Background Color', command=self.set_axis_bg)
testMenu.add_command(label='Overplot Error Bands', command=self.overplot_errorbands)
testMenu.add_command(label='Y vs X', command=self.y_vs_y)
testMenu.add_command(label='Run Macro', command=self.testMacro)
testMenu.add_command(label='Copy Data To Clipboard', command=self.copy_data_to_clipboard)
testMenu.add_command(label='Make Sine', command=self.commands['sine'])
testMenu.add_command(label='Mann-Kendall Trend', command=self.commands['mann_kendall'])

testMenu.add_separator()

testMenu.add_command(label='Timehack', command=self.addTimehack)

#mainMenu.add_cascade(label='Test', menu=testMenu)#, state=Tk.DISABLED)
</t>
<t tx="tom.20220401201301.1">plotSubmenu.add_separator()

mainMarkerSubmenu = Tk.Menu(self.root)
plotSubmenu.add_cascade(label='Main Marker Style',
    menu=mainMarkerSubmenu)

self.main_marker_style = Tk.StringVar()
mainMarkerSubmenu.add_radiobutton(
    label='Line', variable=self.main_marker_style, value=1,
    command=self.setMainMarkerStyle)
mainMarkerSubmenu.add_radiobutton(
    label='Symbol', variable=self.main_marker_style, value=2,
    command=self.setMainMarkerStyle)
mainMarkerSubmenu.add_radiobutton(
    label='Both', variable=self.main_marker_style, value=3,
    command=self.setMainMarkerStyle)

bufferMarkerSubmenu = Tk.Menu(self.root)
plotSubmenu.add_cascade(label='Buffer Marker Style',
    menu=bufferMarkerSubmenu)
self.buffer_marker_style = Tk.StringVar()
bufferMarkerSubmenu.add_radiobutton(
    label='Line', variable=self.buffer_marker_style, value=1,
    command=self.setBufferMarkerStyle)
bufferMarkerSubmenu.add_radiobutton(
    label='Symbol', variable=self.buffer_marker_style, value=2,
    command=self.setBufferMarkerStyle)
bufferMarkerSubmenu.add_radiobutton(
    label='Both', variable=self.buffer_marker_style, value=3,
    command=self.setBufferMarkerStyle)
</t>
<t tx="tom.20220401201342.1">lineStyleSubmenu = Tk.Menu(self.root)
plotSubmenu.add_cascade(label='Linestyles', menu=lineStyleSubmenu)
mainLinestyleSubmenu = Tk.Menu(self.root)
bufferLinestyleSubmenu = Tk.Menu(self.root)
lineStyleSubmenu.add_cascade(label='Main', menu=mainLinestyleSubmenu)
lineStyleSubmenu.add_cascade(label='Buffer',
    menu=bufferLinestyleSubmenu)

plotSubmenu.add_separator()

for _label, _width in (
        ('Thin', str(LINETHIN)),
        ('Medium', str(LINEMED)),
        ('Thick', str(LINETHICK))):
    mainLinestyleSubmenu.add_radiobutton(
            label=_label,
            variable=self.radio_main_linestyle, value=_width,
            command=self.setMainLineWidth, underline=0)
    bufferLinestyleSubmenu.add_radiobutton(
            label=_label,
            variable=self.radio_buffer_linestyle, value=_width,
            command=self.setBufferLineWidth, underline=0)
</t>
<t tx="tom.20220401201409.1">symbolStyleSubmenu = Tk.Menu(self.root)
plotSubmenu.add_cascade(label='Symbol Shapes', menu=symbolStyleSubmenu)
mainSymbolstyleSubmenu = Tk.Menu(self.root)
bufferSymbolstyleSubmenu = Tk.Menu(self.root)
symbolStyleSubmenu.add_cascade(label='Main', menu=mainSymbolstyleSubmenu)
symbolStyleSubmenu.add_cascade(label='Buffer', menu=bufferSymbolstyleSubmenu)

mainSymbolstyleSubmenu.add_radiobutton(
    label='circle', variable=self.main_symbol_shape,
    value=CIRCLE, command=self.setSymShapeMain)
mainSymbolstyleSubmenu.add_radiobutton(
    label='diamond', variable=self.main_symbol_shape,
    value=DIAMOND, command=self.setSymShapeMain)
mainSymbolstyleSubmenu.add_radiobutton(
    label='hexagon', variable=self.main_symbol_shape,
    value=HEXAGON, command=self.setSymShapeMain)
mainSymbolstyleSubmenu.add_radiobutton(
    label='square', variable=self.main_symbol_shape,
    value=SQUARE, command=self.setSymShapeMain)
mainSymbolstyleSubmenu.add_radiobutton(
    label='triangle', variable=self.main_symbol_shape,
    value=TRIANGLE, command=self.setSymShapeMain)
mainSymbolstyleSubmenu.add_radiobutton(
    label='triangle-left', variable=self.main_symbol_shape,
    value=TRIANGLE_LEFT, command=self.setSymShapeMain)

bufferSymbolstyleSubmenu.add_radiobutton(
    label='circle', variable=self.buffer_symbol_shape,
    value=CIRCLE, command=self.setSymShapeBuffer)
bufferSymbolstyleSubmenu.add_radiobutton(
    label='diamond', variable=self.buffer_symbol_shape,
    value=DIAMOND, command=self.setSymShapeBuffer)
bufferSymbolstyleSubmenu.add_radiobutton(
    label='hexagon', variable=self.buffer_symbol_shape,
    value=HEXAGON, command=self.setSymShapeBuffer)
bufferSymbolstyleSubmenu.add_radiobutton(
    label='square', variable=self.buffer_symbol_shape,
    value=SQUARE, command=self.setSymShapeBuffer)
bufferSymbolstyleSubmenu.add_radiobutton(
    label='triangle', variable=self.buffer_symbol_shape,
    value=TRIANGLE, command=self.setSymShapeBuffer)
bufferSymbolstyleSubmenu.add_radiobutton(
    label='triangle-left', variable=self.buffer_symbol_shape,
    value=TRIANGLE_LEFT, command=self.setSymShapeBuffer)
</t>
<t tx="tom.20220401201458.1">colorSubmenu = Tk.Menu(self.root)
plotSubmenu.add_cascade(label='Colors', menu=colorSubmenu)

# Menu to change plot background color
bgColorSubmenu = Tk.Menu(self.root)
colorSubmenu.add_cascade(label='Plot BG Color', menu=bgColorSubmenu)
for _label, _color in (
        ('White', WHITE), 
        ('Black', BLACK),
        ('Light Blue', LIGHTBLUE),
        ('Deep Sky Blue', DEEPSKYBLUE),
        ('Cornflower Blue', CORNFLOWERBLUE),
        ('Medium Gray', MEDGRAY)):
    bgColorSubmenu.add_radiobutton(
            label=_label, variable=self.graph_bg_color, value=_color,
            command=self.setBgColor)

mainSymColorSubmenu = Tk.Menu(self.root)
colorSubmenu.add_cascade(label='Main Symbol Color',
    menu = mainSymColorSubmenu)
bufferSymColorSubmenu = Tk.Menu(self.root)
colorSubmenu.add_cascade(label='Buffer Symbol Color',
    menu=bufferSymColorSubmenu)
mainLineColorSubmenu = Tk.Menu(self.root)
colorSubmenu.add_cascade(label='Main Line Color',
    menu=mainLineColorSubmenu)
bufferLineColorSubmenu = Tk.Menu(self.root)
colorSubmenu.add_cascade(label='Buffer Line Color',
    menu=bufferLineColorSubmenu)

for _label, _color in (
        ('White', WHITE),
        ('Black', BLACK),
        ('Blue', 'blue'),
        ('Cyan', 'cyan'),
        ('Green', 'green'),
        ('Magenta', 'Magenta'),
        ('Red', 'red'),
        ('Yellow', 'Yellow'),
        ('Gray', 'gray')):
    mainSymColorSubmenu.add_radiobutton(
            label=_label, variable=self.main_symbol_color,
            value=_color, command=self.setSymColorMain)
    bufferSymColorSubmenu.add_radiobutton(
            label=_label, variable=self.buffer_symbol_color,
            value=_color, command=self.setSymColorBuffer)
    mainLineColorSubmenu.add_radiobutton(
            label=_label, variable=self.main_line_color,
            value=_color, command=self.setLineColorMain)
    bufferLineColorSubmenu.add_radiobutton(
            label=_label, variable=self.buffer_line_color,
            value=_color, command=self.setLineColorBuffer)
</t>
<t tx="tom.20220401205037.1">Get data from a sequence of ASCII text lines - normally read from a file.
Blank lines and lines that start with a ';' or '#' are ignored. 
If the first non-ignorable line has only a single field, then
the file is assumed to contain single-column data, and the X-axis data
equals the data row count.  Otherwise, the first two columns are used,
split into floating point numbers.

The x- and y- data sequences are assigned to the data set

Metadata such as labels are each on a single line starting with 
two or more ';' characters.  The name of the metadata follows, 
separated by a ':' or a space from the value.  Example:

;;FIGURELABEL:Damped Sine

Current metadata names are:
    FIGURELABEL
    XLABEL
    YLABEL
    YMIN
    YMAX

As a special case, a line that starts with the XLABEL meta comment may
also contain a "YLABEL" tag embedded in the line.  In this case,
the text before the YLABEL tag will be assigned to the figure's
X axis label, and the text following the YLABEL tag will be assigned 
to the figure's Y axis label.

ARGUMENT
lines -- a sequence of text lines, with whitespace-separated data columns
filename -- The file that sourced the data, if it came from a file.

RETURNS
the exception if data can't be converted, else None
</t>
<t tx="tom.20220401205124.1">self.orig_filename = filename
_x = []
_y = []
count = 0
_rowcount = 0
_datalines = 0
_isSingleCol = False
_firstline = True
e = None
retval = ''
</t>
<t tx="tom.20220401205417.1">_rowcount += 1
line = line.strip()
if line and line[0] in (';', '#') and line[:2] != ';;': continue
if not line or line == ';' or line == ';;': continue
if line[0] == ';' and line[1] != ';': continue

&lt;&lt; handle special comments &gt;&gt;
&lt;&lt; get numeric data &gt;&gt;
</t>
<t tx="tom.20220401205645.1">if line[0] == ';' and line[1] == ';':
    _line = line.lstrip(';')
    _line = _line.lstrip()
    if _line.strip()  == ';;':
        continue
    try:
        key, val = _line.split(':',1)
        key = key.strip()
        val = val.strip()
    except ValueError:
        try:
            key, val = _line.split(' ',1)
            key = key.strip()
            val = val.strip()
        except ValueError:
            key, val = ('', '')

    if not (key and val): continue

    if key == 'FIGURELABEL': self.figurelabel = val
    elif key == 'XLABEL': 
        _label_parts = val.split('YLABEL')
        self.xaxislabel = _label_parts[0].strip()
        if len(_label_parts) &gt; 1:
            _ylabel = _label_parts[1].replace(':', ' ', 1)
            _ylabel = _ylabel.lstrip()
            self.yaxislabel = _ylabel
    elif key == 'YLABEL': self.yaxislabel = val
    elif key == 'YMIN': 
        try:
            self.ymin = float(val)
        except Exception: pass
    elif key == 'YMAX': 
        try:
            self.ymax = float(val)
        except Exception: pass

    continue
</t>
<t tx="tom.20220401205749.1">fields = line.split()

# Use first non-blank, non-comment line to decide one or 2 column data
if _firstline and len(fields) == 1:
    _isSingleCol = True
_firstline = False

#retval = None
try:
    if _isSingleCol:
        count = count + 1
        _x.append(count)
        _y.append(float(fields[0]))
    else:
        _x.append(float(fields[0]))
        _y.append(float(fields[1]))
    _datalines += 1
except Exception:
    sys.stderr.write('%s at line %s\n' % (e, _rowcount))
    retained_length = min(len(_x), len(_y))
    _x = _x[:retained_length]
    _y = _y[:retained_length]
    self.figurelabel = 'Data truncated: error  at line %s; %s' % (_rowcount, e)
    #retval = f'{e}'
    #break
</t>
<t tx="tom.20220401210413.1">if clearFirst:
    ax.clear()
    self.setFigureTitle(_figlabel or 'Figure Label')

ax.grid(b=True, linestyle=LINE_SOLID, color=self.gridcolor,
        linewidth=LINETHIN)
ax.set_xlabel(_xlabel or 'X Axis')
ax.set_ylabel(_ylabel or 'Y Axis')
</t>
<t tx="tom.20220402001046.1">phantom = Tk.Button(text='phantom')
_font =  tkFont.nametofont(phantom['font'])
sz_def = _font['size']
sz = int(.9*sz_def)

NEWFONT = tkFont.Font()
NEWFONT.config(**_font.config())
NEWFONT.config(size=sz, weight='bold')
phantom = None
</t>
<t tx="tom.20220402001212.1">host_height = sz*3*(len(CURVE_FIT_BUTTONS)
                    + len(STATS_BUTTONS)
                    + len(GENERATOR_BUTTONS)
                    + 4
                    + 6*sz_def)

host_width = BUTTONWIDTH*(COLS)*sz + len('Data Processing')*sz_def + 6*COLS
#host.geometry('%sx650' % (BUTTONWIDTH*COLS*10 + 12))
host.geometry('%sx%s' % (host_width, host_height))

</t>
<t tx="tom.20220402001714.1">entryframe = Tk.Frame(host, height=20, bd=3, relief='groove', bg='lightblue')
entryframe.pack_propagate(0)
entryframe.pack(fill=Tk.X)

entry = Tk.Label(entryframe, bg='lightcyan')
entry.pack(fill=Tk.X)

cmd_frame = Tk.Frame(host, bd=1, relief='sunken', bg='red')
cmd_frame.pack(fill=Tk.Y)

configure_horizontal_button_list(host, GENERATOR_BUTTONS, plotmgr)
configure_macro_buttons(host, plotmgr)
</t>
<t tx="tom.20220402002421.1">Perform Mann-Kendall non-parametric test for existence of a monotonic trend.
Adapted from https://www.uni-goettingen.de/en/524376.html
which was originally from:

http://www.ambhas.com/codes/statlib.py

Also see:

http://michaelpaulschramm.com/simple-time-series-trend-analysis/
http://www.stats.uwo.ca/faculty/mcleod/2003/DBeirness/MannKendall.pdf

Seasonal variations should preferably be removed before the trend analysis.
though that is not done here.

Calculate the "S" test statistic, which is the number of data increases minus
decreases, for every combination of two points, ordered from first to last.
If S is positive, there appears to be an increasing trend. If negative, 
a decreasing trend

Then calculate the variance of S, and use it to calculate the Z-statistic,
which is roughly normally distributed and denotes the number of standard
deviations away from 0 that S is.  This value is used to compute the
probability of such a deviation.  If the probability is low enough,
the existence of a trend is asserted.

Return the calculated S, Z, trend, and p values.

ARGUMENTS
x -- a sequence of 1-D numpy array of numbers.  Must be time-ordered.
alpha -- false rejection level (probability of false rejection).

RETURNS
a tuple (S, z, h, p), where
S is the trend statistic
z -- the number of standard deviations from 0 of the "S" statistic.
h -- boolean where True indicates a trend is present
p -- p-value for the trend's existence.
</t>
<t tx="tom.20220402080844.1">def two_line():
    dia = TwoLineInput(root, 'Test Dialog')
    print (dia.result)

def one_line_int():
    dia = GetSingleInt(root, 'Single Line Input', 'width', 2)
    print (dia.result)

def one_line_float():
    dia = GetSingleFloat(root, 'Single Line Input', 'width', 2)
    print (dia.result)

def two_line_float():
    dia = GetTwoFloats(root, 'Two Line Float Input', 'width', 'height', 2.0, 3.2)
    print (dia.result)

def two_line_int():
    dia = GetTwoInts(root, 'Two Line Float Input', 'width', 'height', 2, 3)
    print (dia.result)

def two_number():
    dia = GetTwoNumbers(root,' Two Number Input', 'start', 'delta', 0, 1)
    print (dia.result)

def test_flash():
    tf.flash('yellow')

def test_fade():
    tf.fade(150)

def test_flash_fade():
    tf.flash('yellow')
    tf.fade(150)
</t>
<t tx="tom.20220402082428.1"></t>
<t tx="tom.20220402082507.1"></t>
<t tx="tom.20220402082631.1"></t>
<t tx="tom.20220402083822.1"></t>
<t tx="tom.20220402084339.1"></t>
<t tx="tom.20220411133313.1">The software in this GF4 project is writtten by and copyrighted by: Thomas B. Passin 2014 - 2022.
</t>
<t tx="tom.20220411133954.1">The GF4 software package is covered by the standard MIT license, reproduced below:

The MIT License (MIT)
Copyright © 2022 Thomas B. Passin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</t>
<t tx="tom.20220411171338.1">GF4 is a computer program for visualizing and processing two-dimensional data such as X-Y and time series data.  The user interface is modeled after a reverse-polish notation (RPN) style of desk calculator, with the roles of numbers being replaced by 2D data sets.

As in Hewlett-Packard RPN calculators, the stack bottom is called "X", the stack position above that is called "Y", and the top of the stack is called "T".  Data sets may be pushed, popped, or rotated on the stack.  GF4's stack has a depth of 3.

The main program is called "gf4.pyw".</t>
<t tx="tom.20220411201434.1">def about(parent = None):
    msg = """
       GF4 Waveform Calculator/Plotter
--------------------------------------------------------
Plots 2D curves and performs calculations on them. GF4 is modeled after a reverse polish notation (RPN) calculator, where 2D waveforms take the place of plain numbers.

@others
"""

    msg_window(msg, parent)
</t>
<t tx="tom.20220411201602.1">helpSubmenu = Tk.Menu(self.root)
helpSubmenu.add_command(label='About',
    command=lambda: about(self), underline=0)
helpSubmenu.add_command(label = "User's Guide",
    command=tutorial, underline = 0)</t>
<t tx="tom.20220411202149.1">@language python
@others

if __name__ == '__main__':
#    msg_window('This is the help message', None)
    about()
    Tk.mainloop()
</t>
<t tx="tom.20220411202245.1">def tutorial():
    helpdoc = 'GF4_Users_Guide.html'
    path = join(dirname(__file__), 'doc', 'html', helpdoc)
    path = path.replace('\\', '/')
    url = f'file:///{path}'
    webbrowser.open_new_tab(url)</t>
<t tx="tom.20220411210306.1">def msg_window(text, plotmgr=None):
    _geom = ''
    if plotmgr:
        win = Tk.Toplevel(plotmgr.root)
        win.transient(plotmgr.root)
        _geom = plotmgr.root.geometry()
    else:
        win = Tk.Tk()

    win.title("GF4 Information")

    win.grid_columnconfigure(0, weight=1)
    win.grid_rowconfigure(0, weight=1)

    text_box = Tk.Text(win, wrap = 'word', padx = 15, width = 100, height = 50)
    text_box.grid(row=0, column=0, sticky='ew')

    # Thanks to https://www.pythontutorial.net/tkinter/tkinter-scrollbar/
    scroll_bar = Tk.Scrollbar(win,  command=text_box.yview)
    scroll_bar.grid(row=0, column=1, sticky='ns')
    text_box['yscrollcommand'] = scroll_bar.set

    font = ('sans-serif', 10, 'normal')
    text_box.configure(font = font)

    text_box.insert(Tk.END, text)
    text_box['state'] = 'disabled'

    win.update_idletasks()
    if plotmgr:
        plotmgr.root.update_idletasks()

    # Set initial window position in screen
    if _geom:
        #902x670+182+182
        root_dims, root_xoffset, root_yoffset = _geom.split('+')
        root_width, root_height = root_dims.split('x')
        xoffset = int(root_xoffset) + int(root_width) + 5
        yoffset = int(root_yoffset)
        #win.geometry(f'600x{root_height}')
        win.geometry('600x800')
        win.geometry('+%s+%s' %(xoffset, yoffset))
    else:
        win.geometry('600x800')

</t>
<t tx="tom.20220411210428.1">from os.path import dirname, join
import webbrowser

try:
    import Tkinter as Tk
except:
    import tkinter as Tk

# try:
    # import tkFont
# except:
    # import tkinter.font as tkFont

# try:
    # import ttk
# except:
    # from tkinter import ttk
</t>
<t tx="tom.20220411232217.1"></t>
<t tx="tom.20220412003223.1">  Input Data Format
-----------------------------------------------
GF4 accepts one or two-column whitespace-separated text files, one data point per row. If there is only one column, GF4 inserts an imputed first column with values being consecutive integers beginning with 1.

Here is an example data file:

# A comment line
; Another comment line.  Also, blank lines are ignored.
# x  y
1  1
2  4
3  9
# etc 

Data points do not need to be equally spaced on the x axis.

There are specially formatted (optional) comments to specify a title, axis labels, and a break between data sets:

;; FIGURELABEL: The Title
;; XLABEL: The x axis
;; YLABEL: the y axis
1    3.0
2    4.0
3    6.0
4    7.0
;; ENDDATASET

The special comment key words are case sensitive.  If there is more than one dataset, the second one goes into the y position in the stack, and so on up to the stack depth.  Beyond that additional data sets are ignored.

</t>
<t tx="tom.20220412003352.1">    The Waveform Stack
-------------------------------------
The stack is a group of data sets, where new data sets get added to the "bottom" or "X" slot, and there are other slots "above" X, namely "Y" (the next one "up"), and "T", the "topmost" slot.  In computer terms, the stack can be pushed, popped, or rotated. Data sets can also be added directly to the various slots.

New data sets are always loaded into the "X" slot.  The File/Save... menu item saves the data in the "X" slot as a text file.

Slots in the stack:

    | --- Top --- |
    | ---  Y  --- |
    | ---  X  --- |    &lt;--- Stack Bottom
    </t>
<t tx="tom.20220412003444.1">    Data Input
----------------------------
GF4 has two ways to get data:

    1. Read a text data file in the format described above;
    2. Type into an edit dialog box, or paste from the clipboard into the edit box.

New data from either source always gets inserted into the "X" slot, replacing whatever was there.  If the data file contains the special comment ";; ENDDATASET", then the data following that comment will get loaded into the next higher slot in the stack, replacing the previous contents.  If there should be another data section, it will load into the next higher slot, the top slot.  Data sections beyond this will get ignored.

</t>
<t tx="tom.20220412003456.1">    Data Output
-------------------------
Data in the "X" slot can be saved in two ways:

    1. By using the File/Save... menu item;
    2. By copying it to the clipboard.

Saved data will include the plot title and the axis labels, if any have been added.  The are denoted using the special comments described above.

</t>
<t tx="tom.20220412003510.1">    Plotting Data
-----------------------------
</t>
<t tx="tom.20220412075521.1"></t>
<t tx="tom.20220412080203.1">@language python
from sys import executable
import subprocess

c.k.simulateCommand('rst3')

# Other likely themes: 
#'-D', 'html_theme=sphinx_book_theme',
#'-D', 'html_theme=bizstyle',

cmd = [executable, '-m', 'sphinx', '-C',
        '-b', 'html',
        '-D', "master_doc=GF4_Users_Guide",
        '-D', 'source_suffix=.rst',
        '-D', 'html_theme=pyramid',
        '-D', 'project=GF4',
        '-D', 'copyright=Thomas B. Passin 2022',

        # sourcedir, outputdir:
        r'.', r'html']

subprocess.call(cmd)</t>
<t tx="tom.20220412080628.1">===================
GF4 User's Guide
===================
This User's Guide Covers the Use and Capabilities of the GF4 Waveform Calculator.</t>
<t tx="tom.20220412080711.1">GF4 - "GF" being short for "Graphics Functions" - is a program to display two-dimensional data, such as time series data, and to perform mathematical operations on the data or between two related data sets.  We will often call the 2D data sets "waveforms" for historical reasons, and because the data often represents time domain waveforms.  Otherwise we generally call the data by the term "datasets".  The program aims to make data exploration easy and enjoyable.

The program's interface is modeled after hand-held calculators of the "reverse polish notation" (RPN) style.  This kind of calculator was made famous by Hewlett-Packard, starting with their HP-35 and HP-45 calculators.  GF4 works with waveforms in place of the numbers manipulated by the hand calculators.

Thus, a waveform can be scaled, squared, have its logarithm taken, integrated and differentiated  [1]_, be normalized and rectified, and so on. A discrete Fast Fourier Transform is provided that is not limited to powers of two in data length.  Data can be trimmed or padded.  Curve fitting and smoothing of several varieties can be done.  Two waveforms can be added, subtracted, multiplied, and divided (where possible), correlated or convolved together, among others.

A certain number of basic waveforms can be generated, including a delta function, step, ramp, sine and damped sine, Gaussian PDF and CDF distributions, and more.  Altogether there are nearly 80 different operations available.

A basic macro facility is provided to automate a sequence of repeated operations.

Like RPN calculators, GF4 operations are organized around a stack of data sets.  Unlike those calculators, the various stack levels can be accessed directly as well.


.. rubric:: Footnote

.. [1] That is, the discrete differencing equivalent of these operations.

</t>
<t tx="tom.20220412082324.1"></t>
<t tx="tom.20220412085319.1">For a quick introduction, we will work through an example. GF4 will generate the data for us. The file to launch is named gf4.pyw.  It can be launched with pythonw as a GUI application with no console, or with python to also have a console.  The console is not needed except it could display error messages, which are unlikely.  GF4 should be run with some version of python 3.6+.

To launch the program, you can double-click on its icon in the Windows Explorer file manager or the Linux equivalent, or run with python from the directory that contains gf4::

    python3 gf4.pyw

or, for systems with the "py" launcher, either of::

    pyw gf4.pyw
    py gf4.pyw

With a data file name also on the command line, GF4 will open and plot that file on launch.</t>
<t tx="tom.20220412085326.1">Input Data Format
------------------
GF4 accepts one or two-column whitespace-separated text files, one data point per row. If there is only one column, GF4 inserts an imputed first column with values being consecutive integers beginning with 1.

Here is an example data file::

    # A comment line
    ; Another comment line.  Also, blank lines are ignored.
    # x  y
    1  1
    2  4
    3  9
    # etc 

Data points do not need to be equally spaced on the x axis.

There are specially formatted (optional) comments to specify a title, axis labels, and a break between data sets::

    ;; FIGURELABEL: The Title
    ;; XLABEL: The x axis label
    ;; YLABEL: the y axis label
    1    3.0
    2    4.0
    3    6.0
    4    7.0
    ;; ENDDATASET

The special comment key words are case sensitive.  If there is more than one dataset, the second one goes into the **Y** position in the stack, and so on up to the stack depth.  Beyond that additional data sets are ignored.

</t>
<t tx="tom.20220412085521.1"></t>
<t tx="tom.20220412085541.1"></t>
<t tx="tom.20220412085559.1"></t>
<t tx="tom.20220412085615.1"></t>
<t tx="tom.20220412085648.1"></t>
<t tx="tom.20220412085726.1"></t>
<t tx="tom.20220412085756.1">We encountered one of GF4's waveform generators in the `Quick Start`_ section.</t>
<t tx="tom.20220412091831.1"></t>
<t tx="tom.20220412091839.1"></t>
<t tx="tom.20220412091853.1"></t>
<t tx="tom.20220412091943.1"></t>
<t tx="tom.20220412095053.1">Typical uses of GF4 include curve fitting and observing the fit quality, comparing observed cdf curves against a gaussian of the same mean and standard distribution, smoothing noisy time series data, and creating FFT transforms to try to identify prominent frequencies in a waveform.
GF4 would make an excellent educational tool since it makes exploring the data so easy, which would help the student come to understand basic statistical limitations that are hard to convey otherwise.

The effect of zero-padding and windowing a waveform before running an FFT is quite illuminating and easy to study.  Cumulative data, such as total covid case counts vs time, can be converted into daily rates by differentiating.  This leads to a very noisy dataset, and that can be smoothed with, for example, a LOWESS smoothing routine. The study of the shape of residuals after fitting a function is interesting and easy to do.

No code need be written to perform any of these operations on datasets.</t>
<t tx="tom.20220412171300.1"></t>
<t tx="tom.20220412183611.1">GF4 is a fifth generation implementation of the basic waveform calculator concept (the first generation - implemented on a 64K Z-80 CP/M machine - was not named).  The implementation language has changed from FORTH to Turbo Pascal to Delphi to the current Python.  Over this time the basic concept has not been changed, while the user interface has evolved and been refined, and more math operations added.</t>
<t tx="tom.20220412191239.1">Figure IN-1 depicts a fairly typical view of GF4 in action.  The ramp curve generator has produced a straight line, which was copied to the second stack position.  Then a Gaussian noise series was generated and added to the straight line to produce a very noisy ramp.  The underlying straight line, which still was available in its stack position, was then overlayed onto the noisy version.

Of note is the title of the graph.  It was generated automatically, capturing a description of each processing step as a reminder for the user.  This is one of many "affordances" the program provides to reduce demands on the user.  The title can be changed by clicking on it, which turns the title line into an edit box.

.. figure:: images/GF4_Screen_Example.png

    Figure IN-1. Screen Shot Of GF4 In Action.

    The main plotting window is on the left, and the command window is on the right.
</t>
<t tx="tom.20220412214305.1">GF4 is not a rigorous tool for statistical calculations.  Although the mathematical operations are done as carefully as possible, usually using well-established scientific libraries such as numpy and scipy, various subtleties are not taken into account.  For example, error bars can be shown for a LOWESS smooth, but they do not take into account possible autocorrelation in the dataset.  FFTs, and correlations and convolutions between waveforms, are not normalized according to usual conventions.  This generally makes no practical difference to exploratory use, since it is the relative shapes and features that are normally of interest.  In addition, although processed data sets can be saved to files, and image files of the curves seen on the screen can be saved as well, error bars, regression coefficients, and the like cannot be output.

GF4 is best used for understanding the features of a 2D dataset, and working out how effective various kinds of processing will be.  Is it too noisy or too contaminated to get useful results? Does a linear least squares fit make sense? Does this kind of a correlation seem to be meaningful? Is a smoothing window of 50 too wide?  Will a cosine or a supergaussian window produce a cleaner FFT for this particular data?  Will zero-padding the dataset improve the resolution?  Is this increase really "exponential"?  What will be the effect of a D.C offset on the FFT?

If more than this is needed, the user should take that understanding and use it with other tools to produce a more complete analysis in depth.  The "R" language might be one suitable tool, for example.  After that is done, GF4 can again be used to assess the results as a kind of quality check.</t>
<t tx="tom.20220412231039.1">In this example, we will create a dataset that consists of a straight line with Gaussian noise added.  We will fit a line to the noisy data.  Then we will display the fitted line, and overlay the noisy data, the original line, and the error bars for the fit.



</t>
<t tx="tom.20220412233838.1">**Create a Straight Line**
---------------------------
To generate the line, click the "Ramp" button. The line will be plotted in the left hand plotting window. this line has been placed in the bottom position of the stack, which is always called "**X**". Copy it to the "**Y**" position (the next one up in the stack) by clicking on the "Copy2Y" button in the "Stack" group.

**Create a Noise Dataset**
---------------------------
With the original line safely stored in **Y**, now create a dataform of noise.  Click on the "Gaussian Noise" button.  In the dialog box that pops up, change the "Sigma" value to 0.3. If we leave it at the default value of 1.0, there will be too much noise.  Even with the smaller value of sigma, there will be a lot of noise.  Accept the values by clicking the OK button or pressing the &lt;ENTER&gt; key.  The noise waveform will display in the plot window.

**Add The Noise To the Original Line**
---------------------------------------
Next we will add the noise to the straight line we saved in **Y**.  In the "Math" column, click on "X + Y".  This will add the two curves together point-by-point and leave the result in the **X** stack position.  The original straight line is unchanged in **Y**.

The sum of the two datasets is a noisy line in **X**, and it has been automatically plotted in the plot window.  In one last touch, click on the "Overplot Y" button in the "Plot" column.  This will overlay the original straight line which is still in **Y**. The result is shown in Figure EX-1a.  Your result may be a little different because you will have gotten a different noise dataset.

.. figure:: images/gf4_example_1_noisy.png

    Figure EX-1a. The Noisy Ramp With Original (Clean) Curve Overlaid.

**Plot the Noisy Data With Point Symbols Instead Of Lines**
------------------------------------------------------------
The Gaussian noise data points don't really form a curve because they are independent.  Perhaps it would be better to plot the noisy ramp with points instead of lines.  Try this out by using the "Plot" menu on the left-hand plot window. Select Plot/Main Marker Style/Symbol.  Then click on the "Plot" item in the "Plot" Menu or the "Plot X" button in the commands window.  Then overplot the original ramp in **Y** using the "Overplot Y" button.

The results will resemble Figure EX-1b.

.. Figure:: images/gf4_example_1_noisy_symbols.png

    Figure EX-1b. The Noisy Ramp Plotted With Symbols Instead Of Lines.

Finally, set the main marker style back to "Line"

**Save The Noisy Line For Later Viewing**
------------------------------------------
For this example, at the end we will overlay this noisy line on the plot of the fitted line.  Copy it to the **T** stack position by clicking the "Copy2T" button in the "Stack" group.
</t>
<t tx="tom.20220412234039.1">To fit a linear least squares fit to the noisy ramp, click on the "Lst Sqr Lin" button in the upper right of the commands window.  The best fit straight line will plot in the plotting window.

**Overplot The Other Datasets For Comparison**
----------------------------------------------
For this example we will overplot the original ramp and the noisy version of the ramp.  These datasets are still in **Y** and **T** where we put them.

Click on the "Overplot Y" button in the "Plot" group at the left of the command window. The original straight line will be plotted in a light cyan color.  It will probably be a little different from the fitted line.  That is normal, because the noisy sample we used is unlikely to have exactly the same properties as the original.

Click on the "Overplot T" button to overplot the noisy dataset.

**Overlay Error Bands For The Fit**
-----------------------------------
Error bands for the fit are available for most of the fitting routines.  Click the "Error Bands" button to see them.  Each time this button is clicked, the error band area gets less transparent, so you can adjust the visibility if needed.

The results are shown in Figure EX-1c.

.. figure:: images/gf4_example_1_fitted.png

    Figure EX-1c. The Least Squares Fitted Line With Error Bands And Original Data.

</t>
<t tx="tom.20220413002412.1">Examples like this are usually much harder to describe than to do.  With a little practice, these kinds of operations become familiar and they go very quickly.  One gets used to the location of the command buttons that are commonly used, and the stack positions stop feeling strange.  Just like a physical calculator, in fact.</t>
</tnodes>
</leo_file>
